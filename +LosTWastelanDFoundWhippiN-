Fork System
===========
Branching paths in the narrative/physics.

A Fork represents a decision point with multiple branches.
Each branch has a type (KINETIC/POTENTIAL/STORE) determining
how potential energy is handled.

Forks are physics - they represent real divergence in possibilities.
"""

from typing import Dict, List, Optional, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
import time

from ..constants import (
    FORK_TYPES,
    FORK_MAX_BRANCHES,
    FORK_DECAY_RATE,
    PHI,  # Golden ratio
)


class ForkType(Enum):
    """Types of fork branches."""
    KINETIC = "KINETIC"   # Bark - immediate action
    POTENTIAL = "POTENTIAL"  # Bite - stored for later
    STORE = "STORE"  # Wait - observe and learn


@dataclass
class ForkBranch:
    """
    A single branch of a fork.
    
    Attributes:
        branch_id: Unique identifier
        fork_type: How this branch handles energy
        label: Human-readable label
        potential: Stored potential energy
        cooldown: Ticks before can be taken again
        current_cooldown: Current cooldown remaining
        metadata: Additional data
    """
    branch_id: str
    fork_type: ForkType
    label: str = ""
    potential: float = 0.0
    cooldown: int = 0
    current_cooldown: int = 0
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def is_available(self) -> bool:
        """Check if this branch can be taken."""
        return self.current_cooldown <= 0
    
    def tick(self):
        """Process a tick for this branch."""
        if self.current_cooldown > 0:
            self.current_cooldown -= 1
        
        # Decay stored potential over time
        if self.fork_type == ForkType.POTENTIAL and self.potential > 0:
            self.potential *= (1 - FORK_DECAY_RATE)
    
    def add_potential(self, amount: float):
        """Add potential energy to this branch."""
        if self.fork_type == ForkType.POTENTIAL:
            self.potential += amount
    
    def use_potential(self) -> float:
        """Use stored potential and return the amount."""
        if self.fork_type != ForkType.POTENTIAL:
            return 0.0
        
        amount = self.potential
        self.potential = 0.0
        return amount
    
    def trigger_cooldown(self):
        """Start the cooldown timer."""
        self.current_cooldown = self.cooldown
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize branch state."""
        return {
            "branch_id": self.branch_id,
            "fork_type": self.fork_type.name,
            "label": self.label,
            "potential": self.potential,
            "cooldown": self.cooldown,
            "current_cooldown": self.current_cooldown,
            "metadata": self.metadata,
        }
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "ForkBranch":
        """Reconstruct branch from data."""
        return cls(
            branch_id=data["branch_id"],
            fork_type=ForkType[data["fork_type"]],
            label=data.get("label", ""),
            potential=data.get("potential", 0.0),
            cooldown=data.get("cooldown", 0),
            current_cooldown=data.get("current_cooldown", 0),
            metadata=data.get("metadata", {}),
        )


@dataclass
class Fork:
    """
    A decision point with multiple branches.
    
    Forks are created when significant choices emerge.
    They persist until all branches expire or are taken.
    
    The 0 = 3 invariant: A fork is never truly deleted, only archived.
    
    Attributes:
        fork_id: Unique identifier
        source: Entity or system that created this fork
        branches: Available branches
        created_tick: When this fork was created
        archived: Whether this fork is archived
        outcome: Which branch was ultimately taken (if any)
    """
    fork_id: str
    source: Any
    branches: Dict[str, ForkBranch] = field(default_factory=dict)
    created_tick: int = 0
    archived: bool = False
    outcome: Optional[str] = None  # branch_id of taken branch
    
    _fork_counter = 0
    
    @classmethod
    def create(cls, source: Any, tick: int = 0) -> "Fork":
        """Create a new fork with a unique ID."""
        fork_id = f"fork_{cls._fork_counter}"
        cls._fork_counter += 1
        return cls(fork_id=fork_id, source=source, created_tick=tick)
    
    def add_branch(self, branch_type: ForkType, label: str = "",
                   cooldown: int = 0, metadata: Dict = None) -> ForkBranch:
        """
        Add a branch to this fork.
        
        Args:
            branch_type: KINETIC, POTENTIAL, or STORE
            label: Human-readable label
            cooldown: Cooldown ticks for this branch
            metadata: Additional data
            
        Returns:
            The created branch
        """
        if len(self.branches) >= FORK_MAX_BRANCHES:
            raise ValueError(f"Fork cannot have more than {FORK_MAX_BRANCHES} branches")
        
        branch_id = f"{self.fork_id}_branch_{len(self.branches)}"
        branch = ForkBranch(
            branch_id=branch_id,
            fork_type=branch_type,
            label=label,
            cooldown=cooldown,
            metadata=metadata or {},
        )
        
        self.branches[branch_id] = branch
        return branch
    
    def get_branch(self, branch_id: str) -> Optional[ForkBranch]:
        """Get a branch by ID."""
        return self.branches.get(branch_id)
    
    def get_available_branches(self) -> List[ForkBranch]:
        """Get all branches that can currently be taken."""
        return [b for b in self.branches.values() if b.is_available()]
    
    def take_branch(self, branch_id: str) -> Optional[ForkBranch]:
        """
        Take a branch, consuming its potential.
        
        Returns the branch if successful, None if unavailable.
        """
        branch = self.branches.get(branch_id)
        
        if branch is None or not branch.is_available():
            return None
        
        # Handle based on branch type
        if branch.fork_type == ForkType.KINETIC:
            # Immediate action - trigger cooldown
            branch.trigger_cooldown()
        
        elif branch.fork_type == ForkType.POTENTIAL:
            # Use stored potential
            branch.use_potential()
            branch.trigger_cooldown()
        
        elif branch.fork_type == ForkType.STORE:
            # No cooldown, just observe
            pass
        
        self.outcome = branch_id
        return branch
    
    def add_potential_to_branch(self, branch_id: str, amount: float):
        """Add potential to a specific branch."""
        branch = self.branches.get(branch_id)
        if branch and branch.fork_type == ForkType.POTENTIAL:
            branch.add_potential(amount)
    
    def tick(self):
        """Process a tick for all branches."""
        for branch in self.branches.values():
            branch.tick()
    
    def is_expired(self) -> bool:
        """Check if all branches are unavailable and on cooldown."""
        return all(
            not b.is_available() and b.current_cooldown > 0 
            for b in self.branches.values()
        )
    
    def archive(self):
        """Archive this fork (soft delete - 0 = 3)."""
        self.archived = True
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize fork state."""
        return {
            "fork_id": self.fork_id,
            "branches": {
                bid: branch.serialize() 
                for bid, branch in self.branches.items()
            },
            "created_tick": self.created_tick,
            "archived": self.archived,
            "outcome": self.outcome,
        }
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any], source: Any) -> "Fork":
        """Reconstruct fork from data."""
        fork = cls(
            fork_id=data["fork_id"],
            source=source,
            created_tick=data.get("created_tick", 0),
            archived=data.get("archived", False),
            outcome=data.get("outcome"),
        )
        
        for bid, bdata in data.get("branches", {}).items():
            fork.branches[bid] = ForkBranch.deserialize(bdata)
        
        return fork


class ForkManager:
    
    Manages all active forks in the system.
    
    Forks are created, tracked, and archived here.
    Implements the 0 = 3 invariant for fork lifecycle.
    """
    
    def __init__(self):
        self._active_forks: Dict[str, Fork] = {}
        self._archived_forks: List[Fork] = []
        self._fork_history: List[Dict] = []  # 0 = 3 archive
    
    def create_fork(self, source: Any, tick: int = 0) -> Fork:
        """Create a new fork."""
        fork = Fork.create(source, tick)
        self._active_forks[fork.fork_id] = fork
        return fork
    
    def get_fork(self, fork_id: str) -> Optional[Fork]:
        """Get a fork by ID."""
        return self._active_forks.get(fork_id)
    
    def get_forks_for_source(self, source: Any) -> List[Fork]:
        """Get all active forks for a specific source."""
        return [f for f in self._active_forks.values() if f.source == source]
    
    def take_branch(self, fork_id: str, branch_id: str) -> Optional[ForkBranch]:
        """Take a branch from a fork."""
        fork = self._active_forks.get(fork_id)
        if fork:
            return fork.take_branch(branch_id)
        return None
    
    def tick(self):
        """Process all active forks."""
        expired = []
        
        for fork_id, fork in self._active_forks.items():
            fork.tick()
            
            if fork.is_expired():
                expired.append(fork_id)
        
        # Archive expired forks (0 = 3)
        for fork_id in expired:
            fork = self._active_forks.pop(fork_id)
            fork.archive()
            self._archived_forks.append(fork)
            self._fork_history.append({
                "fork_id": fork_id,
                "action": "expired",
                "outcome": fork.outcome,
                "timestamp": time.time(),
            })
    
    def archive_fork(self, fork_id: str) -> Optional[Fork]:
        """Manually archive a fork."""
        fork = self._active_forks.pop(fork_id, None)
        if fork:
            fork.archive()
            self._archived_forks.append(fork)
            self._fork_history.append({
                "fork_id": fork_id,
                "action": "archived",
                "outcome": fork.outcome,
                "timestamp": time.time(),
            })
        return fork
    
    def get_archived_forks(self, limit: int = 100) -> List[Fork]:
        """Get recently archived forks."""
        return self._archived_forks[-limit:]
    
    def restore_fork(self, fork_id: str) -> Optional[Fork]:
        """Restore an archived fork (0 = 3)."""
        for i, fork in enumerate(self._archived_forks):
            if fork.fork_id == fork_id:
                fork.archived = False
                self._active_forks[fork_id] = fork
                self._archived_forks.pop(i)
                return fork
        return None
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize all fork state."""
        return {
            "active_forks": {
                fid: fork.serialize() 
                for fid, fork in self._active_forks.items()
            },

"""
Core module - Foundation classes for the DLC.
"""

from .component import Component, ComponentHolder
from .event import EventManager, DLC_EVENT, Event
from .fork import Fork, ForkBranch, ForkType

__all__ = [
    "Component",
    "ComponentHolder", 
    "EventManager",
    "DLC_EVENT",
    "Event",
    "Fork",
    "ForkBranch",
    "ForkType",
]
            "archived_count": len(self._archived_forks),
        }

"""
DLC Components
==============
Data containers that attach to entities.
Components are physics properties, not rules.
"""

from .faygo import FaygoComponent, FaygoMode, FaygoFlavor
from .madrox import MadroxComponent
from .carnie import CarnieComponent
from .danger_state import DangerStateComponent, DangerState
from .loyalty import LoyaltyComponent
from .authority import AuthorityComponent, AuthorityLevel
from .hidden_potential import HiddenPotentialComponent
from .toxicity import ToxicityComponent

__all__ = [
    "FaygoComponent", "FaygoMode", "FaygoFlavor",
    "MadroxComponent",
    "CarnieComponent",
    "DangerStateComponent", "DangerState",
    "LoyaltyComponent",
    "AuthorityComponent", "AuthorityLevel",
    "HiddenPotentialComponent",
    "ToxicityComponent",
]

"""
Faygo Component
===============
The fizzy fuel of the carnival.

Faygo is a physics-based consumable with 6 modes and 6 flavors.
Each mode represents a different way of interacting with Faygo,
each flavor has different effects on entities.

Modes:
- FLAT: Old, no fizz, minimal effect
- SHOOK: Agitated, explosive potential
- SPRAY: Distributed application
- BATHE: Full immersion
- HIT_IN_FACE: Shock application
- CHUG: Maximum consumption

Design: Faygo is physics - the fizz is real carbonation energy.
"""

from typing import Optional, Dict, Any, List
from dataclasses import dataclass, field
from enum import Enum, auto

from ..core.component import Component
from ..constants import (
    FAYGO_FRESH_DURATION,
    FAYGO_FLAVORS,
    FAYGO_MODE_EFFECTS,
    PHI,
)


class FaygoMode(Enum):
    """The 6 modes of Faygo interaction."""
    FLAT = auto()
    SHOOK = auto()
    SPRAY = auto()
    BATHE = auto()
    HIT_IN_FACE = auto()
    CHUG = auto()


class FaygoFlavor(Enum):
    """The 6 sacred flavors of Faygo."""
    WATERMELON = auto()
    PINEAPPLE = auto()
    GRAPE = auto()
    ORANGE = auto()
    ROOT_BEER = auto()
    COTTON_CANDY = auto()


@dataclass
class FaygoParticle:
    """
    A single particle of Faygo fizz.
    Used for spray and bathe modes.
    """
    x: float = 0.0
    y: float = 0.0
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    fizz_level: float = 1.0
    sticky: bool = False
    
    def tick(self, delta: float = 1.0):
        """Update particle physics."""
        # Apply velocity
        self.x += self.velocity_x * delta
        self.y += self.velocity_y * delta
        
        # Decay fizz
        self.fizz_level *= 0.95
        
        # Gravity effect
        self.velocity_y -= 0.1 * delta
        
        # Air resistance
        self.velocity_x *= 0.98
        self.velocity_y *= 0.98


class FaygoComponent(Component):
    """
    Component for Faygo soda interaction.
    
    Entities with this component can carry, use, and be affected by Faygo.
    
    Attributes:
        flavor: Current flavor of Faygo
        mode: Current mode (changes with interaction)
        volume: Amount remaining (0.0 - 1.0)
        fizz_level: Carbonation energy (0.0 - 1.0)
        age: Ticks since opened
        shake_level: How much the Faygo has been shaken
        particles: Active particles for spray/bathe modes
    """
    
    def __init__(
        self,
        flavor: FaygoFlavor = FaygoFlavor.GRAPE,
        mode: FaygoMode = FaygoMode.FLAT,
        volume: float = 1.0,
        **kwargs
    ):
        super().__init__(**kwargs)
        
        self.flavor = flavor
        self.mode = mode
        self.volume = volume
        self.fizz_level = 1.0 if mode != FaygoMode.FLAT else 0.1
        self.age = 0
        self.shake_level = 0.0
        self.particles: List[FaygoParticle] = []
        self._sticky_accumulator = 0.0
        self._opened = False
        self._last_mode_change_tick = 0
    
    @property
    def is_fresh(self) -> bool:
        """Check if Faygo is still fresh."""
        return self.age < FAYGO_FRESH_DURATION and self.fizz_level > 0.3
    
    @property
    def is_empty(self) -> bool:
        """Check if Faygo is empty."""
        return self.volume <= 0.0
    
    @property
    def is_shakeable(self) -> bool:
        """Check if Faygo can be shaken more."""
        return self.volume > 0.0 and self.shake_level < 1.0
    
    def open(self, tick: int = 0) -> Dict[str, Any]:
        """
        Open the Faygo (first interaction).
        
        Returns event data about the opening.
        """
        if self._opened:
            return {"success": False, "reason": "already_open"}
        
        self._opened = True
        self.age = 0
        
        # Shake level affects what happens
        if self.shake_level > 0.8:
            # Explosive opening!
            self.mode = FaygoMode.SPRAY
            return {
                "success": True,
                "explosive": True,
                "spray_potential": self.shake_level * self.fizz_level,
            }
        
        return {"success": True, "explosive": False}
    
    def shake(self, intensity: float = 0.1) -> Dict[str, Any]:
        """
        Shake the Faygo, building pressure.
        
        Args:
            intensity: How hard to shake (0.0 - 1.0)
            
        Returns:
            Data about shake result
        """
        if self.is_empty:
            return {"success": False, "reason": "empty"}
        
        # Increase shake level based on fizz
        shake_gain = intensity * self.fizz_level
        self.shake_level = min(1.0, self.shake_level + shake_gain)
        
        # Shaking preserves fizz
        self.fizz_level = min(1.0, self.fizz_level + intensity * 0.05)
        
        return {
            "success": True,
            "shake_level": self.shake_level,
            "fizz_level": self.fizz_level,
            "warning": self.shake_level > 0.7,
        }
    
    def set_mode(self, mode: FaygoMode, tick: int = 0) -> bool:
        """
        Change the Faygo mode.
        
        Some modes require conditions.
        """
        # Check conditions
        if mode == FaygoMode.CHUG and self.volume < 0.5:
            return False
        
        if mode == FaygoMode.SPRAY and self.fizz_level < 0.3:
            return False
        
        self.mode = mode
        self._last_mode_change_tick = tick
        return True
    
    def consume(self, amount: float = 0.1) -> Dict[str, Any]:
        """
        Consume some Faygo.
        
        Returns effect data based on mode and flavor.
        """
        if self.is_empty:
            return {"success": False, "reason": "empty"}
        
        actual_amount = min(amount, self.volume)
        self.volume -= actual_amount
        
        # Get mode effects
        mode_effects = FAYGO_MODE_EFFECTS.get(self.mode.name, {})
        
        # Calculate refresh based on mode
        refresh_base = mode_effects.get("refresh", 1.0)
        refresh = refresh_base * actual_amount * self.fizz_level
        
        # Calculate sticky
        sticky = mode_effects.get("sticky", 0.0) * actual_amount
        self._sticky_accumulator += sticky
        
        # Create result
        result = {
            "success": True,
            "amount_consumed": actual_amount,
            "refresh": refresh,
            "sticky": sticky,
            "flavor": self.flavor.name,
            "mode": self.mode.name,
            "fizz_at_delivery": self.fizz_level,
        }
        
        # Mode-specific effects
        if self.mode == FaygoMode.HIT_IN_FACE:
            result["shock"] = mode_effects.get("shock", 0) * self.fizz_level
        
        if self.mode == FaygoMode.CHUG:
            result["risk"] = mode_effects.get("risk", "NONE")
            result["burp_imminent"] = self.volume < 0.2
        
        # Reduce fizz on consumption
        self.fizz_level *= 0.9
        
        return result
    
    def spray(self, target_x: float, target_y: float, 
              spread: float = 1.0) -> List[FaygoParticle]:
        """
        Create spray particles toward a target.
        
        Args:
            target_x, target_y: Target coordinates
            spread: How spread out the spray is
            
        Returns:
            List of created particles
        """
        if self.mode not in (FaygoMode.SPRAY, FaygoMode.SHOOK):
            return []
        
        if self.is_empty:
            return []
        
        particles = []
        particle_count = int(10 * self.fizz_level * spread)
        
        for i in range(particle_count):
            import random
            import math
            
            angle = random.uniform(0, 2 * math.pi)
            speed = random.uniform(1, 5) * self.fizz_level
            
            particle = FaygoParticle(
                x=0,
                y=0,
                velocity_x=math.cos(angle) * speed + (target_x * 0.1),
                velocity_y=math.sin(angle) * speed + (target_y * 0.1),
                fizz_level=self.fizz_level,
                sticky=self._sticky_accumulator > 0.5,
            )
            particles.append(particle)
        
        self.particles.extend(particles)
        
        # Consumption
        self.volume -= 0.05 * particle_count / 10
        
        return particles
    
    def bathe(self, radius: float = 3.0) -> Dict[str, Any]:
        """
        Create a bathing area of Faygo.
        
        Used for full immersion effects.
        """
        if self.mode != FaygoMode.BATHE:
            return {"success": False, "reason": "wrong_mode"}
        
        if self.is_empty:
            return {"success": False, "reason": "empty"}
        
        # Bathe consumes more
        self.volume -= 0.2
        
        mode_effects = FAYGO_MODE_EFFECTS.get("BATHE", {})
        duration_mult = mode_effects.get("duration_mult", 2.0)
        
        return {
            "success": True,
            "radius": radius * self.fizz_level,
            "duration_mult": duration_mult,
            "refresh_per_tick": 0.1 * self.fizz_level,
            "sticky_zone": True,
            "flavor": self.flavor.name,
        }
    
    def tick(self, current_tick: int = 0):
        """
        Process a tick of Faygo physics.
        
        Handles aging, fizz decay, and particle updates.
        """
        if not self._opened:
            return
        
        # Age the Faygo
        self.age += 1
        
        # Natural fizz decay
        if self.age > FAYGO_FRESH_DURATION:
            self.fizz_level *= 0.98
            if self.fizz_level < 0.1:
                self.mode = FaygoMode.FLAT
        
        # Shake level naturally decreases
        self.shake_level *= 0.99
        
        # Update particles
        for particle in self.particles[:]:
            particle.tick()
            if particle.fizz_level < 0.01:
                self.particles.remove(particle)
    
    def get_flavor_effect(self) -> Dict[str, float]:
        """
        Get the special effects of the current flavor.
        
        Each flavor has different properties.
        """
        effects = {
            FaygoFlavor.WATERMELON: {
                "refresh": 1.2,
                "summer_vibe": 0.5,
                "hydration": 1.5,
            },
            FaygoFlavor.PINEAPPLE: {
                "refresh": 1.0,
                "tropical": 0.7,
                "sweetness": 1.3,
            },
            FaygoFlavor.GRAPE: {
                "refresh": 1.1,
                "royal": 0.3,
                "stain_potential": 0.8,
            },
            FaygoFlavor.ORANGE: {
                "refresh": 1.3,
                "citrus_burst": 0.6,
                "vitamin_c": 0.4,
            },
            FaygoFlavor.ROOT_BEER: {
                "refresh": 0.9,
                "creaminess": 0.7,
                "vintage": 0.5,
            },
            FaygoFlavor.COTTON_CANDY: {
                "refresh": 0.8,
                "carnival_nostalgia": 1.0,
                "sugar_rush": 0.9,
            },
        }
        
        return effects.get(self.flavor, {"refresh": 1.0})
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "flavor": self.flavor.name,
            "mode": self.mode.name,
            "volume": self.volume,
            "fizz_level": self.fizz_level,
            "age": self.age,
            "shake_level": self.shake_level,
            "opened": self._opened,
            "sticky_accumulator": self._sticky_accumulator,
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "FaygoComponent":
        """Reconstruct from serialized data."""
        return cls(
            flavor=FaygoFlavor[data.get("flavor", "GRAPE")],
            mode=FaygoMode[data.get("mode", "FLAT")],
            volume=data.get("volume", 1.0),
        )

"""
Madrox Component
================
Overthinking as physics.

Named after the X-Men character Multiple Man, this component
represents the anxiety spiral and thought multiplication.

When an entity overthinks, Madrox particles spawn and float.
They are attracted to calm sources and repelled by chaos.

The spiral: Overthinking → More particles → More overthinking → CHAOS

Design: Anxiety is physics, not a rule. The particles are real.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import math
import random

from ..core.component import Component
from ..constants import (
    MADROX_MAX_DURATION,
    MADROX_BIAS_MULTIPLIER,
    MADROX_CALM_ATTRACTION,
    MADROX_CHAOS_REPULSION,
    MADROX_PARTICLE_COUNT,
    MADROX_SPIRAL_THRESHOLD,
    MADROX_CALM_THRESHOLD,
    MADROX_MAX_ANXIETY,
    PHI,
)


class ThoughtType(Enum):
    """Types of overthinking thoughts."""
    WORRY = auto()
    SCENARIO = auto()
    REGRET = auto()
    DOUBT = auto()
    CATASTROPHE = auto()
    REPLAY = auto()
    COMPARISON = auto()
    SHOULD_HAVE = auto()


@dataclass
class MadroxParticle:
    """
    A single thought particle.
    
    Particles float around the entity and interact with
    magnetic fields (calm/chaos sources).
    """
    particle_id: int
    thought_type: ThoughtType
    x: float = 0.0
    y: float = 0.0
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    energy: float = 1.0
    age: int = 0
    anchored: bool = False  # Anchored particles don't move
    
    def tick(self, calm_sources: List[Tuple[float, float]] = None,
             chaos_sources: List[Tuple[float, float]] = None):
        """
        Update particle physics.
        
        Particles are attracted to calm, repelled by chaos.
        """
        if self.anchored:
            return
        
        self.age += 1
        
        # Natural drift
        self.velocity_x += random.uniform(-0.1, 0.1)
        self.velocity_y += random.uniform(-0.1, 0.1)
        
        # Attraction to calm sources
        if calm_sources:
            for cx, cy in calm_sources:
                dx = cx - self.x
                dy = cy - self.y
                dist = math.sqrt(dx*dx + dy*dy) + 0.1
                
                # Inverse square attraction
                force = MADROX_CALM_ATTRACTION / (dist * dist)
                self.velocity_x += (dx / dist) * force
                self.velocity_y += (dy / dist) * force
        
        # Repulsion from chaos sources
        if chaos_sources:
            for cx, cy in chaos_sources:
                dx = self.x - cx
                dy = self.y - cy
                dist = math.sqrt(dx*dx + dy*dy) + 0.1
                
                # Inverse square repulsion
                force = MADROX_CHAOS_REPULSION / (dist * dist)
                self.velocity_x += (dx / dist) * force
                self.velocity_y += (dy / dist) * force
        
        # Apply velocity
        self.x += self.velocity_x
        self.y += self.velocity_y
        
        # Damping
        self.velocity_x *= 0.95
        self.velocity_y *= 0.95
        
        # Energy decay
        self.energy *= 0.99
    
    def is_expired(self) -> bool:
        """Check if particle should be removed."""
        return self.energy < 0.1 or self.age > MADROX_MAX_DURATION


class MadroxComponent(Component):
    """
    Component for overthinking and anxiety spiral mechanics.
    
    Entities with this component can enter a state of overthinking,
    spawning thought particles that interact with the environment.
    
    Attributes:
        is_overthinking: Currently in overthinking state
        anxiety_level: Current anxiety (0.0 - 1.0)
        particles: Active thought particles
        spiral_depth: How deep into spiral (0-5)
        bias: Past experience bias multiplier
        calm_sensitivity: How affected by calm sources
        chaos_sensitivity: How affected by chaos sources
        thought_history: Recent thought types for patterns
    """
    
    _particle_counter = 0
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        self.is_overthinking = False
        self.anxiety_level = 0.0
        self.particles: List[MadroxParticle] = []
        self.spiral_depth = 0
        self.bias = MADROX_BIAS_MULTIPLIER
        self.calm_sensitivity = 1.0
        self.chaos_sensitivity = 1.0
        self.thought_history: List[ThoughtType] = []
        self._duration = 0
        self._calm_sources: List[Tuple[float, float]] = []
        self._chaos_sources: List[Tuple[float, float]] = []
    
    @property
    def particle_count(self) -> int:
        """Current number of active particles."""
        return len(self.particles)
    
    @property
    def is_spiraling(self) -> bool:
        """Check if in a spiral state."""
        return self.anxiety_level >= MADROX_SPIRAL_THRESHOLD
    
    @property
    def is_calm(self) -> bool:
        """Check if calm enough."""
        return self.anxiety_level <= MADROX_CALM_THRESHOLD
    
    def start_overthinking(self, trigger: str = "") -> Dict[str, Any]:
        """
        Enter overthinking state.
        
        Args:
            trigger: What caused the overthinking
            
        Returns:
            Data about the state entry
        """
        if self.is_overthinking:
            return {"success": False, "reason": "already_overthinking"}
        
        self.is_overthinking = True
        self._duration = 0
        
        # Spawn initial particles based on trigger
        initial_count = random.randint(2, 5)
        for _ in range(initial_count):
            self._spawn_particle()
        
        return {
            "success": True,
            "trigger": trigger,
            "initial_particles": initial_count,
            "anxiety_level": self.anxiety_level,
        }
    
    def stop_overthinking(self, reason: str = "calm") -> Dict[str, Any]:
        """
        Exit overthinking state.
        
        Args:
            reason: Why overthinking stopped
            
        Returns:
            Data about the state exit
        """
        if not self.is_overthinking:
            return {"success": False, "reason": "not_overthinking"}
        
        self.is_overthinking = False
        particles_dissolved = len(self.particles)
        
        # Particles fade when calm
        self.particles.clear()
        
        result = {
            "success": True,
            "reason": reason,
            "duration": self._duration,
            "particles_dissolved": particles_dissolved,
            "final_anxiety": self.anxiety_level,
        }
        
        self._duration = 0
        self.spiral_depth = 0
        
        return result
    
    def _spawn_particle(self, thought_type: ThoughtType = None) -> MadroxParticle:
        """Spawn a new thought particle."""
        MadroxComponent._particle_counter += 1
        
        if thought_type is None:
            thought_type = random.choice(list(ThoughtType))
        
        # Spawn near entity center with random offset
        angle = random.uniform(0, 2 * math.pi)
        dist = random.uniform(0.5, 2.0)
        
        particle = MadroxParticle(
            particle_id=MadroxComponent._particle_counter,
            thought_type=thought_type,
            x=math.cos(angle) * dist,
            y=math.sin(angle) * dist,
            velocity_x=random.uniform(-0.5, 0.5),
            velocity_y=random.uniform(-0.5, 0.5),
            energy=1.0,
        )
        
        self.particles.append(particle)
        self.thought_history.append(thought_type)
        
        # Keep history manageable
        if len(self.thought_history) > 50:
            self.thought_history.pop(0)
        
        return particle
    
    def add_calm_source(self, x: float, y: float, strength: float = 1.0):
        """Add a calm source that attracts particles."""
        # Scale by strength
        self._calm_sources.append((x * strength, y * strength))
    
    def add_chaos_source(self, x: float, y: float, strength: float = 1.0):
        """Add a chaos source that repels particles."""
        self._chaos_sources.append((x * strength, y * strength))
    
    def clear_sources(self):
        """Clear all sources (call each tick before adding new ones)."""
        self._calm_sources.clear()
        self._chaos_sources.clear()
    
    def tick(self, current_tick: int = 0):
        """
        Process a tick of Madrox physics.
        
        Updates particles, checks for spiraling, etc.
        """
        if not self.is_overthinking:
            # Anxiety naturally decays when not overthinking
            self.anxiety_level = max(0, self.anxiety_level - 0.02)
            return
        
        self._duration += 1
        
        # Update existing particles
        for particle in self.particles[:]:
            particle.tick(self._calm_sources, self._chaos_sources)
            
            if particle.is_expired():
                self.particles.remove(particle)
        
        #

"""
Carnie Component
================
The carnival worker entity.

Carnies run the Midway games and have their own behaviors:
- Running games
- Taking smoke breaks
- Dealing with customers
- Maintaining the carnival

The primary Carnie is Monoxide, but others exist.

Design: Carnies are NPCs with personality physics.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..core.component import Component
from ..constants import (
    MIDWAY_GAME_TYPES,
    MIDWAY_TICKET_COST,
    PHI,
)


class CarnieState(Enum):
    """States a carnie can be in."""
    IDLE = auto()
    RUNNING_GAME = auto()
    SMOKE_BREAK = auto()
    CHATTING = auto()
    MAINTENANCE = auto()
    GRIFTING = auto()
    RESTOCKING = auto()


class CarnieMood(Enum):
    """Carnie mood states."""
    BORED = auto()
    CONTENT = auto()
    EXCITED = auto()
    ANNOYED = auto()
    SUSPICIOUS = auto()
    GENEROUS = auto()


@dataclass
class GameSession:
    """Active game session at a carnie's booth."""
    player_id: str
    game_type: str
    tickets_spent: int = 0
    prizes_won: List[str] = field(default_factory=list)
    attempts: int = 0
    start_tick: int = 0


class CarnieComponent(Component):
    """
    Component for carnival worker behavior.
    
    Carnies run games, manage prizes, and have personalities
    that affect gameplay.
    
    Attributes:
        name: Carnie name (e.g., "Monoxide")
        state: Current activity state
        mood: Current mood
        assigned_game: Which game this carnie runs
        patience: Current patience level (0-100)
        generosity: How likely to give prizes (0-1)
        suspicion: How suspicious of the player (0-1)
        smoke_break_timer: Ticks until smoke break
        current_session: Active game session
        lifetime_tickets: Total tickets earned
        lifetime_prizes: Total prizes given
        games_expertise: Skill levels at different games
    """
    
    def __init__(
        self,
        name: str = "Carnie",
        assigned_game: str = "RING_TOSS",
        **kwargs
    ):
        super().__init__(**kwargs)
        
        self.name = name
        self.state = CarnieState.IDLE
        self.mood = CarnieMood.CONTENT
        self.assigned_game = assigned_game
        
        self.patience = 100
        self.generosity = 0.5
        self.suspicion = 0.0
        
        self.smoke_break_timer = random.randint(200, 500)
        self.current_session: Optional[GameSession] = None
        
        self.lifetime_tickets = 0
        self.lifetime_prizes = 0
        
        # Expertise at different games
        self.games_expertise: Dict[str, float] = {
            game: random.uniform(0.3, 1.0) for game in MIDWAY_GAME_TYPES
        }
        
        self._ticks_since_interaction = 0
        self._mood_shift_cooldown = 0
    
    @property
    def is_available(self) -> bool:
        """Check if carnie is available for games."""
        return self.state in (CarnieState.IDLE, CarnieState.CHATTING)
    
    @property
    def is_on_break(self) -> bool:
        """Check if on smoke break."""
        return self.state == CarnieState.SMOKE_BREAK
    
    def start_game(self, player_id: str, tick: int = 0) -> Dict[str, Any]:
        """
        Start a game session with a player.
        
        Args:
            player_id: The player entity
            tick: Current game tick
            
        Returns:
            Data about the game start
        """
        if not self.is_available:
            return {
                "success": False,
                "reason": f"busy_{self.state.name.lower()}"
            }
        
        self.state = CarnieState.RUNNING_GAME
        self.current_session = GameSession(
            player_id=player_id,
            game_type=self.assigned_game,
            start_tick=tick,
        )
        
        self._ticks_since_interaction = 0
        
        return {
            "success": True,
            "game": self.assigned_game,
            "cost": MIDWAY_TICKET_COST,
            "carnie_name": self.name,
            "carnie_mood": self.mood.name,
        }
    
    def play_round(self, player_skill: float = 0.5) -> Dict[str, Any]:
        """
        Process a round of the game.
        
        Args:
            player_skill: Player's skill at this game (0-1)
            
        Returns:
            Result of the round
        """
        if not self.current_session:
            return {"success": False, "reason": "no_session"}
        
        self.current_session.attempts += 1
        self.current_session.tickets_spent += MIDWAY_TICKET_COST
        
        # Calculate win chance
        expertise = self.games_expertise.get(self.assigned_game, 0.5)
        
        # Mood affects difficulty
        mood_mod = {
            CarnieMood.GENEROUS: 0.2,
            CarnieMood.EXCITED: 0.1,
            CarnieMood.CONTENT: 0.0,
            CarnieMood.BORED: -0.1,
            CarnieMood.ANNOYED: -0.2,
            CarnieMood.SUSPICIOUS: -0.3,
        }.get(self.mood, 0.0)
        
        win_chance = player_skill + mood_mod - (expertise * 0.3)
        win_chance = max(0.05, min(0.95, win_chance))
        
        # Suspicion affects
        if self.suspicion > 0.5:
            win_chance *= (1 - self.suspicion * 0.5)
        
        won = random.random() < win_chance
        
        result = {
            "success": True,
            "won": won,
            "attempt": self.current_session.attempts,
            "tickets_spent": self.current_session.tickets_spent,
            "win_chance": win_chance,
        }
        
        if won:
            prize = self._determine_prize()
            result["prize"] = prize
            self.current_session.prizes_won.append(prize)
            self.lifetime_prizes += 1
            
            # Generosity decreases after win
            self.generosity = max(0.2, self.generosity - 0.05)
        
        self.lifetime_tickets += MIDWAY_TICKET_COST
        
        # Update mood based on result
        if won and random.random() < 0.3:
            self._shift_mood(CarnieMood.ANNOYED)
        elif not won and random.random() < 0.2:
            self._shift_mood(CarnieMood.GENEROUS)
        
        return result
    
    def _determine_prize(self) -> str:
        """Determine prize tier based on generosity."""
        roll = random.random() * self.generosity
        
        if roll > 0.9:
            return "LEGENDARY"
        elif roll > 0.7:
            return "RARE"
        elif roll > 0.4:
            return "COMMON"
        else:
            return "BOBBY_PRIZE"  # Joke prize
    
    def end_session(self) -> Dict[str, Any]:
        """End the current game session."""
        if not self.current_session:
            return {"success": False, "reason": "no_session"}
        
        result = {
            "success": True,
            "total_attempts": self.current_session.attempts,
            "total_tickets": self.current_session.tickets_spent,
            "prizes_won": self.current_session.prizes_won.copy(),
        }
        
        self.current_session = None
        self.state = CarnieState.IDLE
        
        return result
    
    def take_smoke_break(self, duration: int = 50) -> Dict[str, Any]:
        """
        Go on smoke break.
        
        Args:
            duration: Break duration in ticks
            
        Returns:
            Data about the break
        """
        if self.state == CarnieState.SMOKE_BREAK:
            return {"success": False, "reason": "already_on_break"}
        
        previous_state = self.state
        self.state = CarnieState.SMOKE_BREAK
        self._smoke_break_duration = duration
        self._smoke_break_remaining = duration
        
        # End any current session
        if self.current_session:
            self.end_session()
        
        return {
            "success": True,
            "duration": duration,
            "previous_state": previous_state.name,
            "carnie_name": self.name,
        }
    
    def chat(self, topic: str = "") -> Dict[str, Any]:
        """
        Chat with the carnie.
        
        Returns dialogue based on mood and state.
        """
        # Shift to chatting state
        if self.is_available:
            self.state = CarnieState.CHATTING
        
        self._ticks_since_interaction = 0
        
        # Generate response based on mood
        responses = self._get_mood_responses()
        response = random.choice(responses)
        
        return {
            "success": True,
            "carnie_name": self.name,
            "mood": self.mood.name,
            "response": response,
            "topic": topic,
        }
    
    def _get_mood_responses(self) -> List[str]:
        """Get dialogue responses based on current mood."""
        responses = {
            CarnieMood.BORED: [
                "*yawns* Another day, another sucker...",
                "You gonna play or just stand there?",
                "Seen one mark, seen 'em all.",
            ],
            CarnieMood.CONTENT: [
                "Step right up, test your skill!",
                "Good times at the carnival, friend.",
                "That's how we do it at the Midway.",
            ],
            CarnieMood.EXCITED: [
                "YEAH! Now THIS is what I'm talking about!",
                "You look like a WINNER to me!",
                "Feel that energy? That's CARNIVAL MAGIC!",
            ],
            CarnieMood.ANNOYED: [
                "*grumbles* What do YOU want?",
                "I don't have all day here.",
                "Just... play the game or move on.",
            ],
            CarnieMood.SUSPICIOUS: [
                "*squints* You seem familiar...",
                "I've got my eye on you.",
                "Nobody wins THAT much around here...",
            ],
            CarnieMood.GENEROUS: [
                "Hey friend, let me give you a tip...",
                "You know what? Take an extra throw.",
                "The carnival provides, my friend.",
            ],
        }
        return responses.get(self.mood, ["..."])
    
    def _shift_mood(self, new_mood: CarnieMood):
        """Shift to a new mood if cooldown allows."""
        if self._mood_shift_cooldown <= 0:
            self.mood = new_mood
            self._mood_shift_cooldown = 20
    
    def tick(self, current_tick: int = 0):
        """
        Process a tick of Carnie physics.
        
        Handles state changes, smoke breaks, mood shifts.
        """
        self._ticks_since_interaction += 1
        self._mood_shift_cooldown = max(0, self._mood_shift_cooldown - 1)
        
        # Patience decays without interaction
        if self._ticks_since_interaction > 50:
            self.patience = max(0, self.patience - 1)
            
            if self.patience < 20 and self.mood != CarnieMood.ANNOYED:
                self._shift_mood(CarnieMood.ANNOYED)
        
        # Smoke break timer
        if self.state != CarnieState.SMOKE_BREAK:
            self.smoke_break_timer -= 1
            
            if self.smoke_break_timer <= 0:
                self.take_smoke_break()
        else:
            self._smoke_break_remaining -= 1
            
            if self._smoke_break_remaining <= 0:
                self.state = CarnieState.IDLE
                self.smoke_break_timer = random.randint(200, 500)
                self._shift_mood(CarnieMood.CONTENT)
        
        # Random mood shifts
        if random.random() < 0.001:  # Rare random shift
            self._shift_mood(random.choice(list(CarnieMood)))
        
        # Generosity slowly recovers
        self.generosity = min(1.0, self.generosity + 0.001)
        
        # Suspicion decays
        self.suspicion = max(0, self.suspicion - 0.001)
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "name": self.name,
            "state": self.state.name,
            "mood": self.mood.name,
            "assigned_game": self.assigned_game,
            "patience": self.patience,
            "generosity": self.generosity,
            "suspicion": self.suspicion,
            "lifetime_tickets": self.lifetime_tickets,
            "lifetime_prizes": self.lifetime_prizes,
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "CarnieComponent":
        """Reconstruct from serialized data."""
        return cls(
            name=data.get("name", "Carnie"),
            assigned_game=data.get("assigned_game", "RING_TOSS"),
        )


# Predefined carnie archetypes
CARNIE_ARCHETYPES = {
    "monoxide": {
        "name": "Monoxide",
        "assigned_game": "WHEEL_OF_FATE",
        "generosity": 0.6,
        "games_expertise": {"WHEEL_OF_FATE": 0.9, "HIGH_STRIKER": 0.7},
    },
    "bozo": {
        "name": "Bozo",
        "assigned_game": "RING_TOSS",
        "generosity": 0.4,
        "games_expertise": {"RING_TOSS": 0.95},
    },
    "lucky": {
        "name": "Lucky",
        "assigned_game": "DUCK_POND",
        "generosity": 0.7,
        "games_expertise": {"DUCK_POND": 0.6},
    },
}

"""
Danger State Component
======================
The 5 Perils of the Carnival.

Danger states are extreme situations entities can enter.
Each has unique mechanics and durations.

The 5 Perils:
1. GET_CLOWNED - You got clowned, deal with it
2. JUGGALO_PARTY - Party level escalation
3. THE_MIDWAY - Stuck playing carnival games
4. LOST_AT_THE_CARNIVAL - Can't find your way
5. I_FUCKED_A_COP - Maximum social peril

Design: Danger states are physics - real consequences for actions.
"""

from typing import Dict, Any, Optional, List
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..core.component import Component
from ..constants import (
    DANGER_STATE_DURATIONS,
    DANGER_STATE_INTENSITIES,
    PHI,
)


class DangerState(Enum):
    """The 5 Perils of the Carnival."""
    GET_CLOWNED = auto()
    JUGGALO_PARTY = auto()
    THE_MIDWAY = auto()
    LOST_AT_THE_CARNIVAL = auto()
    I_FUCKED_A_COP = auto()


@dataclass
class DangerStateInstance:
    """
    An active danger state instance.
    
    Tracks duration, intensity, and effects.
    """
    state: DangerState
    start_tick: int = 0
    duration: Optional[int] = None  # None = indefinite until resolved
    intensity: float = 1.0
    source: str = ""
    effects: Dict[str, Any] = field(default_factory=dict)
    
    @property
    def is_indefinite(self) -> bool:
        """Check if this state has no fixed duration."""
        return self.duration is None
    
    def get_remaining(self, current_tick: int) -> Optional[int]:
        """Get remaining ticks, or None if indefinite."""
        if self.duration is None:
            return None
        elapsed = current_tick - self.start_tick
        return max(0, self.duration - elapsed)
    
    def is_expired(self, current_tick: int) -> bool:
        """Check if state has expired."""
        if self.duration is None:
            return False
        return (current_tick - self.start_tick) >= self.duration


class DangerStateComponent(Component):
    """
    Component for tracking danger states.
    
    Entities can have multiple danger states active,
    but certain combinations are prevented.
    
    Attributes:
        active_states: Currently active danger states
        history: Past danger states (0 = 3 archive)
        resistance: Resistance to entering danger states
        current_danger_level: Overall danger level
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        self.active_states: Dict[DangerState, DangerStateInstance] = {}
        self.history: List[Dict[str, Any]] = []
        self.resistance = 0.0
        self.current_danger_level = 0.0
        self._last_state_change = 0
    
    @property
    def is_in_danger(self) -> bool:
        """Check if entity has any active danger state."""
        return len(self.active_states) > 0
    
    @property
    def primary_danger(self) -> Optional[DangerState]:
        """Get the most severe active danger state."""
        if not self.active_states:
            return None
        
        # Sort by intensity
        sorted_states = sorted(
            self.active_states.values(),
            key=lambda s: DANGER_STATE_INTENSITIES.get(s.state.name, 0),
            reverse=True
        )
        return sorted_states[0].state if sorted_states else None
    
    def enter_state(
        self,
        state: DangerState,
        source: str = "",
        intensity: float = 1.0,
        current_tick: int = 0,
        custom_duration: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Enter a danger state.
        
        Args:
            state: The danger state to enter
            source: What caused this state
            intensity: How intense (0-1)
            current_tick: Current game tick
            custom_duration: Override default duration
            
        Returns:
            Data about state entry
        """
        # Check resistance
        if random.random() < self.resistance:
            return {
                "success": False,
                "reason": "resisted",
                "state": state.name,
            }
        
        # Check if already in this state
        if state in self.active_states:
            # Escalate instead
            return self.escalate_state(state, current_tick)
        
        # Get duration
        duration_config = DANGER_STATE_DURATIONS.get(state.name)
        if custom_duration is not None:
            duration = custom_duration
        elif duration_config is not None:
            min_dur, max_dur = duration_config
            duration = random.randint(min_dur, max_dur)
        else:
            duration = None  # Indefinite
        
        # Create state instance
        instance = DangerStateInstance(
            state=state,
            start_tick=current_tick,
            duration=duration,
            intensity=intensity,
            source=source,
        )
        
        # Apply state-specific effects
        instance.effects = self._calculate_effects(state, intensity)
        
        self.active_states[state] = instance
        self._last_state_change = current_tick
        self._recalculate_danger_level()
        
        return {
            "success": True,
            "state": state.name,
            "duration": duration,
            "intensity": intensity,
            "effects": instance.effects,
        }
    
    def _calculate_effects(self, state: DangerState, intensity: float) -> Dict[str, Any]:
        """Calculate effects for a danger state."""
        base_intensity = DANGER_STATE_INTENSITIES.get(state.name, 0.5)
        effective_intensity = base_intensity * intensity
        
        effects = {
            "GET_CLOWNED": {
                "social_penalty": effective_intensity * 0.5,
                "embarrassment": effective_intensity,
                "recovery_chance": 0.1,
            },
            "JUGGALO_PARTY": {
                "energy_drain": effective_intensity * 0.3,
                "faygo_attraction": effective_intensity * 2,
                "party_level": int(effective_intensity * 5),
            },
            "THE_MIDWAY": {
                "game_coercion": effective_intensity,
                "ticket_drain": int(effective_intensity * 10),
                "escape_chance": 0.05,
            },
            "LOST_AT_THE_CARNIVAL": {
                "direction_penalty": effective_intensity,
                "anxiety_increase": effective_intensity * 0.5,
                "landmark_visibility": 1 - effective_intensity,
            },
            "I_FUCKED_A_COP": {
                "social_nuclear": True,
                "reputation_damage": effective_intensity,
                "cannot_enter": ["POLICE_STATION", "COURTHOUSE"],
            },
        }
        
        return effects.get(state, {})
    
    def exit_state(
        self,
        state: DangerState,
        reason: str = "expired",
        current_tick: int = 0
    ) -> Dict[str, Any]:
        """
        Exit a danger state.
        
        Args:
            state: State to exit
            reason: Why exiting
            current_tick: Current game tick
            
        Returns:
            Data about state exit
        """
        if state not in self.active_states:
            return {"success": False, "reason": "not_active"}
        
        instance = self.active_states.pop(state)
        
        # Archive for 0 = 3
        self.history.append({
            "state": state.name,
            "start_tick": instance.start_tick,
            "end_tick": current_tick,
            "duration": instance.duration,
            "reason": reason,
            "intensity": instance.intensity,
        })
        
        self._last_state_change = current_tick
        self._recalculate_danger_level()
        
        return {
            "success": True,
            "state": state.name,
            "reason": reason,
            "total_duration": current_tick - instance.start_tick,
        }
    
    def escalate_state(
        self,
        state: DangerState,
        current_tick: int = 0
    ) -> Dict[str, Any]:
        """
        Escalate an active danger state.
        
        Makes the state more intense.
        """
        if state not in self.active_states:
            return {"success": False, "reason": "not_active"}
        
        instance = self.active_states[state]
        
        # Increase intensity
        instance.intensity = min(2.0, instance.intensity + 0.2)
        
        # Recalculate effects
        instance.effects = self._calculate_effects(state, instance.intensity)
        
        # Extend duration if finite
        if instance.duration is not None:
            instance.duration = int(instance.duration * 1.2)
        
        self._recalculate_danger_level()
        
        return {
            "success": True,
            "state": state.name,
            "action": "escalated",
            "new_intensity": instance.intensity,
        }
    
    def resolve_state(
        self,
        state: DangerState,
        method: str = "natural",
        current_tick: int = 0
    ) -> Dict[str, Any]:
        """
        Resolve a danger state through action.
        
        Some states require specific actions to resolve.
        """
        if state not in self.active_states:
            return {"success": False, "reason": "not_active"}
        
        instance = self.active_states[state]
        
        # State-specific resolution requirements
        resolution_methods = {
            DangerState.GET_CLOWNED: ["clown_back", "wait_it_out", "faygo_shower"],
            DangerState.JUGGALO_PARTY: ["party_harder", "leave_party", "faygo_shower"],
            DangerState.THE_MIDWAY: ["win_game", "lose_game", "bribe_carnie"],
            DangerState.LOST_AT_THE_CARNIVAL: ["find_landmark", "ask_directions", "wait_for_dawn"],
            DangerState.I_FUCKED_A_COP: ["lawyer_up", "leave_town", "face_consequences"],
        }
        
        valid_methods = resolution_methods.get(state, [])
        
        if method not in valid_methods:
            return {
                "success": False,
                "reason": "invalid_method",
                "valid_methods": valid_methods,
            }
        
        # Calculate success based on state and method
        base_success = {
            "wait_it_out": 0.8,
            "faygo_shower": 0.6,
            "win_game": 0.4,
            "find_landmark": 0.5,
            "lawyer_up": 0.3,
        }.get(method, 0.5)
        
        # Intensity affects success
        success_chance = base_success * (1 - instance.intensity * 0.3)
        
        if random.random() < success_chance:
            return self.exit_state(state, f"resolved_{method}", current_tick)
        else:
            # Failed resolution might escalate
            if random.random() < 0.3:
                self.escalate_state(state, current_tick)
            return {
                "success": False,
                "reason": "resolution_failed",
                "can_retry": True,
            }
    
    def _recalculate_danger_level(self):
        """Recalculate overall danger level."""
        if not self.active_states:
            self.current_danger_level = 0
            return
        
        total = 0
        for instance in self.active_states.values():
            base = DANGER_STATE_INTENSITIES.get(instance.state.name, 0.5)
            total += base * instance.intensity
        
        self.current_danger_level = min(2.0, total / len(self.active_states))
    
    def tick(self, current_tick: int = 0):
        """Process danger state tick."""
        # Check for expired states
        expired = []
        for state, instance in self.active_states.items():
            if instance.is_expired(current_tick):
                expired.append(state)
        
        for state in expired:
            self.exit_state(state, "expired", current_tick)
        
        # Resistance slowly builds
        if not self.is_in_danger:
            self.resistance = min(1.0, self.resistance + 0.001)
        else:
            # Resistance decays while in danger
            self.resistance = max(0, self.resistance - 0.002)
    
    def get_state_summary(self) -> Dict[str, Any]:
        """Get summary of all active states."""
        return {
            "in_danger": self.is_in_danger,
            "danger_level": self.current_danger_level,
            "primary_danger": self.primary_danger.name if self.primary_danger else None,
            "active_count": len(self.active_states),
            "states": {
                state.name: {
                    "intensity": inst.intensity,
                    "remaining": inst.duration,
                }
                for state, inst in self.active_states.items()
            },
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "danger_level": self.current_danger_level,
            "resistance": self.resistance,
            "active_states": [
                {
                    "state": inst.state.name,
                    "start_tick": inst.start_tick,
                    "duration": inst.duration,
                    "intensity": inst.intensity,
                }
                for inst in self.active_states.values()
            ],
            "history_count": len(self.history),
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "DangerStateComponent":
        """Reconstruct from serialized data."""
        comp = cls()
        comp.current_danger_level = data.get("danger_level", 0)
        comp.resistance = data.get("resistance", 0)
        return comp

"""
Loyalty Component
=================
Trust as physics.

Loyalty tracks relationships between entities.
It's not a simple number - it's a history of actions and reactions.

Loyalty flows:
- Actions toward an entity affect loyalty
- Betrayal causes massive loyalty drops
- Loyalty affects behavior modifiers

Design: Loyalty is earned and lost through physics, not rules.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum, auto
import time

from ..core.component import Component
from ..constants import (
    LOYALTY_MAX,
    LOYALTY_MIN,
    LOYALTY_DECAY_RATE,
    LOYALTY_ACTION_BONUS,
    LOYALTY_BETRAYAL_PENALTY,
    PHI,
)


class LoyaltyAction(Enum):
    """Types of loyalty-affecting actions."""
    HELPED = auto()
    PROTECTED = auto()
    SHARED_RESOURCE = auto()
    KEPT_SECRET = auto()
    DEFENDED = auto()
    SACRIFICED = auto()
    BETRAYED = auto()
    ABANDONED = auto()
    STOLE_FROM = auto()
    LIED_TO = auto()
    ATTACKED = auto()


@dataclass
class LoyaltyEvent:
    """Record of a loyalty-affecting event."""
    target_id: str
    action: LoyaltyAction
    change: float
    timestamp: float
    context: str = ""
    tick: int = 0


class LoyaltyComponent(Component):
    """
    Component for tracking loyalty relationships.
    
    Each entity has loyalty values toward other entities.
    
    Attributes:
        loyalties: Map of entity_id -> loyalty value
        event_history: Record of loyalty events
        trust_threshold: Level needed for trusted status
        betrayal_count: Total betrayals committed
        forgive_chance: Chance to forgive negative actions
    """
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        self.loyalties: Dict[str, float] = {}
        self.event_history: List[LoyaltyEvent] = []
        self.trust_threshold = 50.0
        self.betrayal_count = 0
        self.forgive_chance = 0.1
        
        self._last_decay = 0
    
    def get_loyalty(self, entity_id: str) -> float:
        """
        Get loyalty toward an entity.
        
        Returns 0 if no relationship exists.
        """
        return self.loyalties.get(entity_id, 0.0)
    
    def set_loyalty(self, entity_id: str, value: float) -> float:
        """
        Set loyalty directly (clamped to bounds).
        
        Returns the actual value set.
        """
        clamped = max(LOYALTY_MIN, min(LOYALTY_MAX, value))
        self.loyalties[entity_id] = clamped
        return clamped
    
    def modify_loyalty(
        self,
        entity_id: str,
        action: LoyaltyAction,
        context: str = "",
        tick: int = 0
    ) -> Dict[str, Any]:
        """
        Modify loyalty based on an action.
        
        Args:
            entity_id: Target entity
            action: What action was taken
            context: Additional context
            tick: Current game tick
            
        Returns:
            Data about the loyalty change
        """
        current = self.get_loyalty(entity_id)
        
        # Determine change based on action
        change_map = {
            LoyaltyAction.HELPED: LOYALTY_ACTION_BONUS,
            LoyaltyAction.PROTECTED: LOYALTY_ACTION_BONUS * 1.5,
            LoyaltyAction.SHARED_RESOURCE: LOYALTY_ACTION_BONUS * 0.8,
            LoyaltyAction.KEPT_SECRET: LOYALTY_ACTION_BONUS * 2.0,
            LoyaltyAction.DEFENDED: LOYALTY_ACTION_BONUS * 2.5,
            LoyaltyAction.SACRIFICED: LOYALTY_ACTION_BONUS * 5.0,
            LoyaltyAction.BETRAYED: LOYALTY_BETRAYAL_PENALTY,
            LoyaltyAction.ABANDONED: LOYALTY_BETRAYAL_PENALTY * 0.7,
            LoyaltyAction.STOLE_FROM: LOYALTY_BETRAYAL_PENALTY * 0.5,
            LoyaltyAction.LIED_TO: LOYALTY_BETRAYAL_PENALTY * 0.3,
            LoyaltyAction.ATTACKED: LOYALTY_BETRAYAL_PENALTY * 2.0,
        }
        
        base_change = change_map.get(action, 0)
        
        # Check for forgiveness
        if base_change < 0 and random.random() < self.forgive_chance:
            base_change *= 0.5  # Reduced penalty
            context += " [forgiven]"
        
        # Apply change
        new_value = self.set_loyalty(entity_id, current + base_change)
        actual_change = new_value - current
        
        # Record event
        event = LoyaltyEvent(
            target_id=entity_id,
            action=action,
            change=actual_change,
            timestamp=time.time(),
            context=context,
            tick=tick,
        )
        self.event_history.append(event)
        
        # Track betrayals
        if action == LoyaltyAction.BETRAYED:
            self.betrayal_count += 1
        
        # Trim history
        if len(self.event_history) > 200:
            self.event_history = self.event_history[-100:]
        
        return {
            "success": True,
            "entity_id": entity_id,
            "action": action.name,
            "change": actual_change,
            "new_loyalty": new_value,
            "context": context,
        }
    
    def is_loyal_to(self, entity_id: str) -> bool:
        """Check if loyalty is above neutral."""
        return self.get_loyalty(entity_id) > 0
    
    def is_trusted(self, entity_id: str) -> bool:
        """Check if loyalty meets trust threshold."""
        return self.get_loyalty(entity_id) >= self.trust_threshold
    
    def is_enemy(self, entity_id: str) -> bool:
        """Check if loyalty is deeply negative."""
        return self.get_loyalty(entity_id) <= -50
    
    def get_loyalty_tier(self, entity_id: str) -> str:
        """Get loyalty tier name."""
        loyalty = self.get_loyalty(entity_id)
        
        if loyalty >= 80:
            return "BOUND"
        elif loyalty >= 50:
            return "TRUSTED"
        elif loyalty >= 20:
            return "FRIENDLY"
        elif loyalty > -20:
            return "NEUTRAL"
        elif loyalty > -50:
            return "WARY"
        elif loyalty > -80:
            return "HOSTILE"
        else:
            return "NEMESIS"
    
    def decay_all(self, tick: int = 0):
        """
        Apply decay to all loyalties.
        
        Loyalty naturally drifts toward neutral.
        """
        for entity_id in list(self.loyalties.keys()):
            current = self.loyalties[entity_id]
            
            # Decay toward 0
            if current > 0:
                new_value = current * (1 - LOYALTY_DECAY_RATE)
                if new_value < 0.5:
                    new_value = 0
            else:
                new_value = current * (1 - LOYALTY_DECAY_RATE)
                if new_value > -0.5:
                    new_value = 0
            
            if new_value == 0:
                del self.loyalties[entity_id]
            else:
                self.loyalties[entity_id] = new_value
        
        self._last_decay = tick
    
    def get_most_loyal(self, count: int = 5) -> List[tuple]:
        """Get entities with highest loyalty."""
        sorted_loyalties = sorted(
            self.loyalties.items(),
            key=lambda x: x[1],
            reverse=True
        )
        return sorted_loyalties[:count]
    
    def get_most_hostile(self, count: int = 5) -> List[tuple]:
        """Get entities with lowest loyalty."""
        sorted_loyalties = sorted(
            self.loyalties.items(),
            key=lambda x: x[1]
        )
        return sorted_loyalties[:count]
    
    def get_history_with(self, entity_id: str) -> List[LoyaltyEvent]:
        """Get loyalty event history with specific entity."""
        return [
            event for event in self.event_history
            if event.target_id == entity_id
        ]
    
    def tick(self, current_tick: int = 0):
        """Process loyalty tick."""
        # Decay every 100 ticks
        if current_tick - self._last_decay >= 100:
            self.decay_all(current_tick)
        
        # Betrayal count affects forgiveness
        if self.betrayal_count > 0:
            self.forgive_chance = max(0.01, 0.1 - (self.betrayal_count * 0.01))
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "loyalties": self.loyalties.copy(),
            "trust_threshold": self.trust_threshold,
            "betrayal_count": self.betrayal_count,
            "event_count": len(self.event_history),
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "LoyaltyComponent":
        """Reconstruct from serialized data."""
        comp = cls()
        comp.loyalties = data.get("loyalties", {})
        comp.trust_threshold = data.get("trust_threshold", 50.0)
        comp.betrayal_count = data.get("betrayal_count", 0)
        return comp

"""
Authority Component
===================
Power gradients in the carnival.

Authority determines who can command whom.
It's a hierarchy, but it can be challenged.

Levels:
- NORMAL: Regular carnival-goer
- RINGMASTER: Runs a section of the carnival
- J: High-level operator
- WRAITH: Top tier, near-supernatural authority

Hollow Authority: Fake authority that collapses under scrutiny.

Design: Authority is a gradient, not a binary. It flows.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..core.component import Component
from ..constants import (
    AUTHORITY_LEVELS,
    AUTHORITY_COMMAND_RANGE,
    AUTHORITY_OBEDIENCE_FACTOR,
    PHI,
)


class AuthorityLevel(Enum):
    """Hierarchy of carnival authority."""
    NORMAL = 0
    RINGMASTER = 25
    J = 50
    WRAITH = 100


@dataclass
class AuthorityChallenge:
    """Record of an authority challenge."""
    challenger_id: str
    target_id: str
    challenger_roll: float
    target_roll: float
    success: bool
    tick: int = 0


class AuthorityComponent(Component):
    """
    Component for tracking authority power.
    
    Authority affects:
    - Who entities obey
    - Command range
    - Challenge mechanics
    
    Attributes:
        level: Current authority level
        effective_authority: Actual authority (can differ from level)
        hollow: Whether this authority is fake
        commands_issued: Total commands given
        commands_obeyed: Commands that were obeyed
        challenges_won: Authority challenges won
        challenges_lost: Authority challenges lost
        authority_sources: Where authority comes from
    """
    
    def __init__(
        self,
        level: AuthorityLevel = AuthorityLevel.NORMAL,
        **kwargs
    ):
        super().__init__(**kwargs)
        
        self.level = level
        self.effective_authority = AUTHORITY_LEVELS.get(level.name, 0)
        self.hollow = False
        self.hollow_exposed = False
        
        self.commands_issued = 0
        self.commands_obeyed = 0
        self.challenges_won = 0
        self.challenges_lost = 0
        
        self.authority_sources: Set[str] = set()  # What grants authority
        self._authority_decay = 0.0
        self._last_challenge_tick = 0
    
    @property
    def is_hollow(self) -> bool:
        """Check if this authority is fake."""
        return self.hollow
    
    @property
    def authority_percentage(self) -> float:
        """Get authority as percentage of max."""
        return self.effective_authority / 100.0
    
    def grant_authority(
        self,
        new_level: AuthorityLevel,
        source: str = ""
    ) -> Dict[str, Any]:
        """
        Grant a new authority level.
        
        Args:
            new_level: Level to grant
            source: What granted this authority
            
        Returns:
            Data about the grant
        """
        old_level = self.level
        self.level = new_level
        
        if source:
            self.authority_sources.add(source)
        
        # Recalculate effective authority
        self._recalculate_effective()
        
        return {
            "success": True,
            "old_level": old_level.name,
            "new_level": new_level.name,
            "effective": self.effective_authority,
            "source": source,
        }
    
    def revoke_authority(self, source: str = "") -> Dict[str, Any]:
        """
        Revoke authority from a source.
        
        Returns to NORMAL if all sources are gone.
        """
        if source in self.authority_sources:
            self.authority_sources.remove(source)
        
        if not self.authority_sources:
            self.level = AuthorityLevel.NORMAL
        
        self._recalculate_effective()
        
        return {
            "success": True,
            "remaining_sources": list(self.authority_sources),
            "new_level": self.level.name,
        }
    
    def set_hollow(self, is_hollow: bool = True):
        """
        Set whether this authority is hollow (fake).
        
        Hollow authority collapses under challenge.
        """
        self.hollow = is_hollow
        if is_hollow:
            # Hollow authority appears real
            self.effective_authority = AUTHORITY_LEVELS.get(self.level.name, 0)
    
    def can_command(self, target_authority: "AuthorityComponent") -> bool:
        """
        Check if this entity can command another.
        
        Based on effective authority difference.
        """
        if self.hollow and self.hollow_exposed:
            return False
        
        return self.effective_authority > target_authority.effective_authority
    
    def issue_command(
        self,
        target: "AuthorityComponent",
        command_type: str = "general",
        obedience_modifier: float = 1.0
    ) -> Dict[str, Any]:
        """
        Issue a command to another entity.
        
        Args:
            target: Target authority component
            command_type: Type of command
            obedience_modifier: Modifier to obedience chance
            
        Returns:
            Result of command attempt
        """
        self.commands_issued += 1
        
        if not self.can_command(target):
            return {
                "success": False,
                "reason": "insufficient_authority",
            }
        
        if self.hollow:
            # Hollow authority might be exposed
            if random.random() < 0.1:
                self.hollow_exposed = True
                return {
                    "success": False,
                    "reason": "hollow_exposed",
                }
        
        # Calculate obedience
        authority_diff = self.effective_authority - target.effective_authority
        base_obedience = AUTHORITY_OBEDIENCE_FACTOR * (authority_diff / 100)
        obedience_chance = base_obedience * obedience_modifier
        
        obeyed = random.random() < obedience_chance
        
        if obeyed:
            self.commands_obeyed += 1
        
        return {
            "success": obeyed,
            "authority_diff": authority_diff,
            "obedience_chance": obedience_chance,
            "command_type": command_type,
        }
    
    def challenge(
        self,
        target: "AuthorityComponent",
        tick: int = 0
    ) -> Dict[str, Any]:
        """
        Challenge another entity's authority.
        
        Can expose hollow authority or change hierarchy.
        """
        # Challenger roll
        challenger_roll = random.random() * self.effective_authority

"""
DLC Systems
===========
Logic processors that operate on components.
Systems are the physics engines of the DLC.
"""

from .magnetic_fields import MagneticFieldsSystem
from .rumor import RumorManager, Rumor
from .party import JuggaloParty, PartyLevel
from .midway import MidwaySystem
from .yellow_bus import YellowBusSystem
from .diamond_rain import DiamondRainSystem
from .thermodynamics import ThermodynamicsSystem

__all__ = [
    "MagneticFieldsSystem",
    "RumorManager", "Rumor",
    "JuggaloParty", "PartyLevel",
    "MidwaySystem",
    "YellowBusSystem",
    "DiamondRainSystem",
    "ThermodynamicsSystem",
]

"""
Magnetic Fields System
======================
Controls Madrox particle attraction/repulsion.

Magnetic fields are generated by entities and locations.
Madrox particles (anxiety thoughts) respond to these fields.

Field Sources:
- Calm sources attract particles (healing)
- Chaos sources repel particles (escalation)
- Neutral sources have no effect

Design: Magnetic fields are physics - they exert real force.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import math

from ..constants import (
    MAGNETIC_FIELD_STRENGTH,
    MAGNETIC_FIELD_DECAY,
    MAGNETIC_FIELD_RADIUS,
    MADROX_CALM_ATTRACTION,
    MADROX_CHAOS_REPULSION,
    PHI,
)


class FieldPolarity(Enum):
    """Magnetic field polarity types."""
    CALM = auto()      # Attracts Madrox particles
    CHAOS = auto()     # Repels Madrox particles
    NEUTRAL = auto()   # No effect


@dataclass
class MagneticField:
    """
    A magnetic field in the carnival.
    
    Fields affect Madrox particles within their radius.
    """
    field_id: str
    x: float
    y: float
    polarity: FieldPolarity
    strength: float = 1.0
    radius: float = MAGNETIC_FIELD_RADIUS
    source_id: str = ""  # Entity or location that created this field
    active: bool = True
    
    def get_force_at(self, px: float, py: float) -> Tuple[float, float]:
        """
        Calculate force on a particle at given position.
        
        Returns (force_x, force_y) vector.
        """
        if not self.active:
            return (0.0, 0.0)
        
        dx = self.x - px
        dy = self.y - py
        dist = math.sqrt(dx * dx + dy * dy)
        
        if dist > self.radius or dist < 0.1:
            return (0.0, 0.0)
        
        # Normalize direction
        if dist > 0:
            nx = dx / dist
            ny = dy / dist
        else:
            nx, ny = 0, 0
        
        # Calculate force magnitude (inverse square)
        magnitude = (self.strength * MAGNETIC_FIELD_STRENGTH) / (dist * dist)
        
        # Apply polarity
        if self.polarity == FieldPolarity.CALM:
            # Attract - force toward field center
            return (nx * magnitude * MADROX_CALM_ATTRACTION, 
                    ny * magnitude * MADROX_CALM_ATTRACTION)
        elif self.polarity == FieldPolarity.CHAOS:
            # Repel - force away from field center
            return (-nx * magnitude * MADROX_CHAOS_REPULSION,
                    -ny * magnitude * MADROX_CHAOS_REPULSION)
        else:
            return (0.0, 0.0)
    
    def tick(self):
        """Process field tick - decay strength."""
        self.strength *= MAGNETIC_FIELD_DECAY
        
        if self.strength < 0.01:
            self.active = False


@dataclass
class ParticleState:
    """State of a Madrox particle in the field system."""
    particle_id: int
    owner_id: str
    x: float
    y: float
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    energy: float = 1.0
    anchored: bool = False


class MagneticFieldsSystem:
    """
    System that manages magnetic fields and particle movement.
    
    Processes all fields each tick and updates particle positions.
    Works with MadroxComponent to sync particle states.
    """
    
    _field_counter = 0
    
    def __init__(self):
        self.fields: Dict[str, MagneticField] = {}
        self.particles: Dict[int, ParticleState] = {}
        self._tick_count = 0
    
    def create_field(
        self,
        x: float,
        y: float,
        polarity: FieldPolarity,
        strength: float = 1.0,
        radius: float = None,
        source_id: str = ""
    ) -> MagneticField:
        """
        Create a new magnetic field.
        
        Args:
            x, y: Field center position
            polarity: CALM, CHAOS, or NEUTRAL
            strength: Field strength
            radius: Effect radius (default from constants)
            source_id: ID of creating entity
            
        Returns:
            The created field
        """
        MagneticFieldsSystem._field_counter += 1
        field_id = f"field_{MagneticFieldsSystem._field_counter}"
        
        field = MagneticField(
            field_id=field_id,
            x=x,
            y=y,
            polarity=polarity,
            strength=strength,
            radius=radius or MAGNETIC_FIELD_RADIUS,
            source_id=source_id,
        )
        
        self.fields[field_id] = field
        return field
    
    def remove_field(self, field_id: str) -> bool:
        """Remove a field by ID."""
        if field_id in self.fields:
            del self.fields[field_id]
            return True
        return False
    
    def get_fields_at(self, x: float, y: float) -> List[MagneticField]:
        """Get all fields affecting a position."""
        return [
            f for f in self.fields.values()
            if f.active and math.sqrt((f.x - x)**2 + (f.y - y)**2) <= f.radius
        ]
    
    def register_particle(
        self,
        particle_id: int,
        owner_id: str,
        x: float,
        y: float,
        velocity_x: float = 0.0,
        velocity_y: float = 0.0,
        energy: float = 1.0
    ):
        """Register a particle for field processing."""
        self.particles[particle_id] = ParticleState(
            particle_id=particle_id,
            owner_id=owner_id,
            x=x,
            y=y,
            velocity_x=velocity_x,
            velocity_y=velocity_y,
            energy=energy,
        )
    
    def unregister_particle(self, particle_id: int):
        """Remove a particle from processing."""
        if particle_id in self.particles:
            del self.particles[particle_id]
    
    def update_particle_position(
        self,
        particle_id: int,
        x: float,
        y: float
    ):
        """Update particle position."""
        if particle_id in self.particles:
            self.particles[particle_id].x = x
            self.particles[particle_id].y = y
    
    def calculate_total_force(
        self,
        x: float,
        y: float,
        exclude_source: str = None
    ) -> Tuple[float, float]:
        """
        Calculate total magnetic force at a position.
        
        Args:
            x, y: Position to check
            exclude_source: Optional source ID to exclude
            
        Returns:
            (total_force_x, total_force_y)
        """
        total_fx, total_fy = 0.0, 0.0
        
        for field in self.fields.values():
            if not field.active:
                continue
            
            if exclude_source and field.source_id == exclude_source:
                continue
            
            fx, fy = field.get_force_at(x, y)
            total_fx += fx
            total_fy += fy
        
        return (total_fx, total_fy)
    
    def tick(self) -> Dict[str, Any]:
        """
        Process one tick of the magnetic field system.
        
        Updates all fields and particles.
        
        Returns:
            Summary of tick processing
        """
        self._tick_count += 1
        
        # Update fields (decay)
        expired_fields = []
        for field_id, field in self.fields.items():
            field.tick()
            if not field.active:
                expired_fields.append(field_id)
        
        # Remove expired fields
        for field_id in expired_fields:
            del self.fields[field_id]
        
        # Update particles
        particles_updated = 0
        particles_anchored = 0
        
        for particle in self.particles.values():
            if particle.anchored:
                particles_anchored += 1
                continue
            
            # Get total force
            fx, fy = self.calculate_total_force(
                particle.x, 
                particle.y,
                exclude_source=particle.owner_id
            )
            
            # Apply force to velocity
            particle.velocity_x += fx
            particle.velocity_y += fy
            
            # Apply velocity
            particle.x += particle.velocity_x
            particle.y += particle.velocity_y
            
            # Damping
            particle.velocity_x *= 0.95
            particle.velocity_y *= 0.95
            
            # Energy decay
            particle.energy *= 0.99
            
            particles_updated += 1
        
        return {
            "tick": self._tick_count,
            "active_fields": len(self.fields),
            "total_particles": len(self.particles),
            "particles_updated": particles_updated,
            "particles_anchored": particles_anchored,
            "fields_expired": len(expired_fields),
        }
    
    def get_field_strength_at(self, x: float, y: float) -> Dict[str, float]:
        """
        Get total field strength by polarity at a position.
        
        Returns dict with 'calm', 'chaos', 'neutral' strengths.
        """
        strengths = {"calm": 0.0, "chaos": 0.0, "neutral": 0.0}
        
        for field in self.fields.values():
            if not field.active:
                continue
            
            dist = math.sqrt((field.x - x)**2 + (field.y - y)**2)
            if dist > field.radius:
                continue
            
            contribution = field.strength / (dist + 1)
            
            if field.polarity == FieldPolarity.CALM:
                strengths["calm"] += contribution
            elif field.polarity == FieldPolarity.CHAOS:
                strengths["chaos"] += contribution
            else:
                strengths["neutral"] += contribution
        
        return strengths
    
    def get_dominant_polarity_at(self, x: float, y: float) -> Optional[FieldPolarity]:
        """Get the dominant field polarity at a position."""
        strengths = self.get_field_strength_at(x, y)
        
        if all(v == 0 for v in strengths.values()):
            return None
        
        dominant = max(strengths, key=strengths.get)
        
        if dominant == "calm":
            return FieldPolarity.CALM
        elif dominant == "chaos":
            return FieldPolarity.CHAOS
        else:
            return FieldPolarity.NEUTRAL
    
    def clear_all_fields(self):
        """Remove all fields."""
        self.fields.clear()
    
    def clear_all_particles(self):
        """Remove all particles."""
        self.particles.clear()
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "field_count": len(self.fields),
            "particle_count": len(self.particles),
            "fields": [
                {
                    "id": f.field_id,
                    "x": f.x,
                    "y": f.y,
                    "polarity": f.polarity.name,
                    "strength": f.strength,
                    "radius": f.radius,
                }
                for f in self.fields.values()
            ],
        }

"""
Rumor System
============
Information as particles.

Rumors spread through the carnival like wildfire.
They can mutate, die out, or become accepted truth.

Rumor Lifecycle:
1. BORN - New rumor created
2. SPREADING - Actively spreading
3. PEAK - Maximum spread
4. DYING - Losing momentum
5. DEAD - No longer active (but archived - 0 = 3)

Rumors have a "truth value" that may or may not reflect reality.

Design: Rumors are physics - they are real information particles.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import time

from ..constants import (
    RUMOR_MAX_SPREAD,
    RUMOR_DECAY_RATE,
    RUMOR_MUTATION_CHANCE,
    RUMOR_MAX_TRUTH,
    PHI,
)


class RumorState(Enum):
    """Lifecycle states of a rumor."""
    BORN = auto()
    SPREADING = auto()
    PEAK = auto()
    DYING = auto()
    DEAD = auto()


@dataclass
class RumorVariant:
    """A variant of a rumor (from mutation)."""
    variant_id: str
    content: str
    truth_modifier: float  # How this variant changes perceived truth
    spread_count: int = 0


@dataclass
class Rumor:
    """
    A rumor in the carnival.
    
    Rumors spread, mutate, and can be proven true or false.
    """
    rumor_id: str
    content: str
    source_id: str
    state: RumorState = RumorState.BORN
    
    # Truth tracking
    actual_truth: Optional[bool] = None  # None = unknown, True/False = verified
    perceived_truth: float = 0.5  # What people believe (0-1)
    truth_confidence: float = 0.0  # How confident in perceived truth
    
    # Spread tracking
    spread_count: int = 0
    entities_exposed: Set[str] = field(default_factory=set)
    entities_believing: Set[str] = field(default_factory=set)
    
    # Variants (mutations)
    variants: Dict[str, RumorVariant] = field(default_factory=dict)
    dominant_variant: Optional[str] = None
    
    # Timing
    created_tick: int = 0
    last_spread_tick: int = 0
    peak_tick: Optional[int] = None
    
    # Metadata
    tags: List[str] = field(default_factory=list)
    importance: float = 0.5
    
    _rumor_counter = 0
    
    @classmethod
    def create(cls, content: str, source_id: str, tick: int = 0) -> "Rumor":
        """Create a new rumor."""
        cls._rumor_counter += 1
        return cls(
            rumor_id=f"rumor_{cls._rumor_counter}",
            content=content,
            source_id=source_id,
            created_tick=tick,
            last_spread_tick=tick,
        )
    
    def expose_to(self, entity_id: str) -> bool:
        """
        Expose an entity to this rumor.
        
        Returns True if newly exposed.
        """
        if entity_id in self.entities_exposed:
            return False
        
        self.entities_exposed.add(entity_id)
        self.spread_count += 1
        return True
    
    def entity_believes(self, entity_id: str) -> bool:
        """Check if an entity believes this rumor."""
        return entity_id in self.entities_believing
    
    def add_believer(self, entity_id: str):
        """Record an entity believing this rumor."""
        self.entities_believing.add(entity_id)
    
    def remove_believer(self, entity_id: str):
        """Remove an entity's belief."""
        self.entities_believing.discard(entity_id)
    
    def mutate(self, new_content: str = None) -> RumorVariant:
        """
        Create a mutant variant of this rumor.
        
        Args:
            new_content: Optional specific content, or auto-generate
            
        Returns:
            The new variant
        """
        Rumor._rumor_counter += 1
        variant_id = f"variant_{Rumor._rumor_counter}"
        
        if new_content is None:
            # Auto-mutate content
            new_content = self._mutate_content(self.content)
        
        # Random truth modifier
        truth_modifier = random.uniform(-0.2, 0.2)
        
        variant = RumorVariant(
            variant_id=variant_id,
            content=new_content,
            truth_modifier=truth_modifier,
        )
        
        self.variants[variant_id] = variant
        return variant
    
    def _mutate_content(self, content: str) -> str:
        """Generate a mutated version of the content."""
        # Simple mutation strategies
        mutations = [
            lambda c: c.replace("did", "might have"),
            lambda c: c.replace("is", "could be"),
            lambda c: f"Apparently, {c.lower()}",
            lambda c: f"Rumor has it that {c.lower()}",
            lambda c: c + " Or so they say.",
            lambda c: c.replace("never", "supposedly never"),
        ]
        
        mutator = random.choice(mutations)
        return mutator(content)
    
    def set_truth(self, is_true: bool):
        """Set the actual truth of this rumor."""
        self.actual_truth = is_true
    
    def update_state(self, current_tick: int):
        """Update rumor state based on spread."""
        spread_rate = self.spread_count / max(1, current_tick - self.created_tick + 1)
        
        if self.state == RumorState.BORN and self.spread_count > 5:
            self.state = RumorState.SPREADING
        
        elif self.state == RumorState.SPREADING:
            if self.spread_count >= RUMOR_MAX_SPREAD * 0.5:
                self.state = RumorState.PEAK
                self.peak_tick = current_tick
        
        elif self.state == RumorState.PEAK:
            # Check if declining
            if self.peak_tick and current_tick - self.peak_tick > 50:
                self.state = RumorState.DYING
        
        elif self.state == RumorState.DYING:
            if self.spread_count > RUMOR_MAX_SPREAD or len(self.entities_believing) == 0:
                self.state = RumorState.DEAD
    
    def tick(self, current_tick: int = 0) -> Dict[str, Any]:
        """Process rumor tick."""
        self.update_state(current_tick)
        
        # Perceived truth drifts toward actual if known
        if self.actual_truth is not None:
            target = 1.0 if self.actual_truth else 0.0
            self.perceived_truth += (target - self.perceived_truth) * 0.01
        
        # Confidence increases with spread
        self.truth_confidence = min(1.0, self.spread_count / RUMOR_MAX_SPREAD)
        
        # Random mutation chance
        if random.random() < RUMOR_MUTATION_CHANCE:
            self.mutate()
        
        # Update dominant variant
        if self.variants:
            dominant = max(
                self.variants.values(),
                key=lambda v: v.spread_count
            )
            self.dominant_variant = dominant.variant_id
        
        return {
            "rumor_id": self.rumor_id,
            "state": self.state.name,
            "spread_count": self.spread_count,
            "believers": len(self.entities_believing),
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize rumor state."""
        return {
            "rumor_id": self.rumor_id,
            "content": self.content,
            "state": self.state.name,
            "spread_count": self.spread_count,
            "perceived_truth": self.perceived_truth,
            "actual_truth": self.actual_truth,
            "believer_count": len(self.entities_believing),
            "variant_count": len(self.variants),
        }


class RumorManager:
    """
    System that manages all rumors in the carnival.
    
    Handles creation, spread, mutation, and lifecycle.
    """
    
    def __init__(self):
        self.rumors: Dict[str, Rumor] = {}
        self.dead_rumors: List[Rumor] = []  # Archive for 0 = 3
        self._tick_count = 0
    
    def create_rumor(
        self,
        content: str,
        source_id: str,
        initial_truth: float = 0.5,
        tags: List[str] = None
    ) -> Rumor:
        """
        Create a new rumor.
        
        Args:
            content: The rumor content
            source_id: Entity that started the rumor
            initial_truth: Initial perceived truth (0-1)
            tags: Optional tags for categorization
            
        Returns:
            The created rumor
        """
        rumor = Rumor.create(content, source_id, self._tick_count)
        rumor.perceived_truth = initial_truth
        
        if tags:
            rumor.tags = tags
        
        self.rumors[rumor.rumor_id] = rumor
        return rumor
    
    def get_rumor(self, rumor_id: str) -> Optional[Rumor]:
        """Get a rumor by ID."""
        return self.rumors.get(rumor_id)
    
    def get_rumors_by_tag(self, tag: str) -> List[Rumor]:
        """Get all rumors with a specific tag."""
        return [r for r in self.rumors.values() if tag in r.tags]
    
    def get_rumors_about(self, entity_id: str) -> List[Rumor]:
        """Get all rumors mentioning an entity."""
        # Simple content search
        return [
            r for r in self.rumors.values()
            if entity_id in r.content or entity_id in r.entities_exposed
        ]
    
    def spread_rumor(
        self,
        rumor_id: str,
        from_entity: str,
        to_entities: List[str],
        credibility: float = 0.5
    ) -> Dict[str, Any]:
        """
        Spread a rumor from one entity to others.
        
        Args:
            rumor_id: The rumor to spread
            from_entity: Entity spreading the rumor
            to_entities: Entities receiving the rumor
            credibility: How credible the spreader is
            
        Returns:
            Spread results
        """
        rumor = self.rumors.get(rumor_id)
        
        if not rumor or rumor.state == RumorState.DEAD:
            return {"success": False, "reason": "rumor_not_found_or_dead"}
        
        newly_exposed = 0
        new_believers = 0
        
        for entity_id in to_entities:
            if rumor.expose_to(entity_id):
                newly_exposed += 1
                
                # Belief check
                belief_chance = credibility * rumor.perceived_truth
                if random.random() < belief_chance:
                    rumor.add_believer(entity_id)
                    new_believers += 1
        
        rumor.last_spread_tick = self._tick_count
        
        return {
            "success": True,
            "rumor_id": rumor_id,
            "newly_exposed": newly_exposed,
            "new_believers": new_believers,
            "total_exposed": len(rumor.entities_exposed),
            "total_believers": len(rumor.entities_believing),
        }
    
    def prove_rumor(self, rumor_id: str, is_true: bool) -> Dict[str, Any]:
        """
        Prove a rumor true or false.
        
        This affects perceived truth dramatically.
        """
        rumor = self.rumors.get(rumor_id)
        
        if not rumor:
            return {"success": False, "reason": "rumor_not_found"}
        
        rumor.set_truth(is_true)
        
        # Dramatic shift in perceived truth
        rumor.perceived_truth = 1.0 if is_true else 0.0
        rumor.truth_confidence = 1.0
        
        return {
            "success": True,
            "rumor_id": rumor_id,
            "proven_true": is_true,
            "believers_were_right": (
                (is_true and rumor.perceived_truth > 0.5) or
                (not is_true and rumor.perceived_truth < 0.5)
            ),
        }
    
    def get_active_rumors(self) -> List[Rumor]:
        """Get all non-dead rumors."""
        return [
            r for r in self.rumors.values()
            if r.state != RumorState.DEAD
        ]
    
    def get_most_spread_rumors(self, count: int = 5) -> List[Rumor]:
        """Get the most widespread rumors."""
        active = self.get_active_rumors()
        return sorted(active, key=lambda r: r.spread_count, reverse=True)[:count]
    
    def tick(self) -> Dict[str, Any]:
        """
        Process all rumors for one tick.
        
        Returns summary of processing.
        """
        self._tick_count += 1
        
        died_count = 0
        tick_results = []
        
        for rumor_id, rumor in list(self.rumors.items()):
            result = rumor.tick(self._tick_count)
            tick_results.append(result)
            
            if rumor.state == RumorState.DEAD:
                self.dead_rumors.append(rumor)
                del self.rumors[rumor_id]
                died_count += 1
        
        return {
            "tick": self._tick_count,
            "active_rumors": len(self.rumors),
            "dead_rumors_total": len(self.dead_rumors),
            "died_this_tick": died_count,
        }
    
    def resurrect_rumor(self, rumor_id: str) -> Optional[Rumor]:
        """
        Resurrect a dead rumor (0 = 3 invariant).
        
        Returns the resurrected rumor or None.
        """
        for rumor in self.dead_rumors:
            if rumor.rumor_id == rumor_id:
                rumor.state = RumorState.DYING  # Start in dying state
                self.rumors[rumor_id] = rumor
                self.dead_rumors.remove(rumor)
                return rumor
        return None
    
    def get_rumor_network(self) -> Dict[str, List[str]]:
        """
        Get the network of rumor spread.
        
        Returns dict mapping rumor_id to list of exposed entity IDs.
        """
        return {
            rumor.rumor_id: list(rumor.entities_exposed)
            for rumor in self.rumors.values()
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_count": len(self.rumors),
            "dead_count": len(self.dead_rumors),
            "rumors": [r.serialize() for r in self.rumors.values()],
        }

"""
Juggalo Party System
====================
The gathering mechanics of the carnival.

Juggalo Parties are escalating events with levels 1-5.
Each level increases intensity and effects.

Party Levels:
1. GATHERING - Small gathering, low energy
2. FAYGO_SHOWER - Faygo spray intensifies
3. MOSH_PIT - Physical chaos begins
4. CARNIVAL_CHAOS - Full carnival involvement
5. FULL_WHIPPIN - Maximum chaos, everything goes

Parties can be started, joined, left, and escalated.

Design: Parties are physics - they are real energy gatherings.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..constants import (
    PARTY_LEVELS,
    PARTY_MAX_DURATION,
    PARTY_COOLDOWN,
    PHI,
)


class PartyLevel(Enum):
    """Juggalo party intensity levels."""
    GATHERING = 1
    FAYGO_SHOWER = 2
    MOSH_PIT = 3
    CARNIVAL_CHAOS = 4
    FULL_WHIPPIN = 5


class PartyState(Enum):
    """States a party can be in."""
    FORMING = auto()
    ACTIVE = auto()
    PEAK = auto()
    WINDING_DOWN = auto()
    ENDED = auto()


@dataclass
class PartyParticipant:
    """A participant in a party."""
    entity_id: str
    join_tick: int = 0
    energy_contributed: float = 0.0
    faygo_consumed: float = 0.0
    mosh_count: int = 0
    level_when_joined: PartyLevel = PartyLevel.GATHERING


@dataclass
class Party:
    """
    An active Juggalo Party.
    
    Parties have levels, participants, and effects.
    """
    party_id: str
    host_id: str
    location_x: float = 0.0
    location_y: float = 0.0
    
    level: PartyLevel = PartyLevel.GATHERING
    state: PartyState = PartyState.FORMING
    
    participants: Dict[str, PartyParticipant] = field(default_factory=dict)
    
    energy_total: float = 0.0
    faygo_total: float = 0.0
    
    start_tick: int = 0
    duration: int = 0
    peak_tick: Optional[int] = None
    
    # Effects
    effects_active: Dict[str, float] = field(default_factory=dict)
    
    _party_counter = 0
    
    @classmethod
    def create(
        cls,
        host_id: str,
        x: float = 0.0,
        y: float = 0.0,
        tick: int = 0
    ) -> "Party":
        """Create a new party."""
        cls._party_counter += 1
        return cls(
            party_id=f"party_{cls._party_counter}",
            host_id=host_id,
            location_x=x,
            location_y=y,
            start_tick=tick,
        )
    
    @property
    def participant_count(self) -> int:
        """Current number of participants."""
        return len(self.participants)
    
    @property
    def is_active(self) -> bool:
        """Check if party is still active."""
        return self.state not in (PartyState.ENDED,)
    
    @property
    def can_escalate(self) -> bool:
        """Check if party can escalate to next level."""
        return (
            self.state == PartyState.ACTIVE and
            self.level.value < 5 and
            self.energy_total >= self._get_escalation_threshold()
        )
    
    def _get_escalation_threshold(self) -> float:
        """Get energy needed to escalate."""
        thresholds = {
            PartyLevel.GATHERING: 50,
            PartyLevel.FAYGO_SHOWER: 150,
            PartyLevel.MOSH_PIT: 400,
            PartyLevel.CARNIVAL_CHAOS: 1000,
            PartyLevel.FULL_WHIPPIN: float('inf'),
        }
        return thresholds.get(self.level, float('inf'))
    
    def join(self, entity_id: str, tick: int = 0) -> Dict[str, Any]:
        """
        Add a participant to the party.
        
        Returns join result.
        """
        if entity_id in self.participants:
            return {"success": False, "reason": "already_joined"}
        
        if self.state == PartyState.ENDED:
            return {"success": False, "reason": "party_ended"}
        
        participant = PartyParticipant(
            entity_id=entity_id,
            join_tick=tick,
            level_when_joined=self.level,
        )
        
        self.participants[entity_id] = participant
        
        # Energy boost from new joiner
        self.energy_total += 10
        
        if self.state == PartyState.FORMING and self.participant_count >= 3:
            self.state = PartyState.ACTIVE
        
        return {
            "success": True,
            "party_id": self.party_id,
            "level": self.level.name,
            "participant_count": self.participant_count,
        }
    
    def leave(self, entity_id: str) -> Dict[str, Any]:
        """Remove a participant from the party."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants.pop(entity_id)
        
        # Check if party should end
        if self.participant_count < 2 and self.state == PartyState.ACTIVE:
            self.state = PartyState.WINDING_DOWN
        
        return {
            "success": True,
            "party_id": self.party_id,
            "energy_contributed": participant.energy_contributed,
            "duration": self.duration,
        }
    
    def contribute_energy(self, entity_id: str, amount: float) -> Dict[str, Any]:
        """
        Contribute energy to the party.
        
        Energy is the fuel that drives party escalation.
        """
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants[entity_id]
        participant.energy_contributed += amount
        self.energy_total += amount
        
        # Check for auto-escalation
        if self.can_escalate:
            return self.escalate()
        
        return {
            "success": True,
            "energy_total": self.energy_total,
            "can_escalate": self.can_escalate,
        }
    
    def consume_faygo(self, entity_id: str, amount: float) -> Dict[str, Any]:
        """Record Faygo consumption at the party."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants[entity_id]
        participant.faygo_consumed += amount
        self.faygo_total += amount
        
        # Faygo boosts energy
        self.energy_total += amount * 2
        
        return {
            "success": True,
            "faygo_total": self.faygo_total,
        }
    
    def escalate(self) -> Dict[str, Any]:
        """
        Escalate party to next level.
        
        Returns escalation result.
        """
        if not self.can_escalate:
            return {"success": False, "reason": "cannot_escalate"}
        
        old_level = self.level
        
        # Move to next level
        if self.level == PartyLevel.GATHERING:
            self.level = PartyLevel.FAYGO_SHOWER
        elif self.level == PartyLevel.FAYGO_SHOWER:
            self.level = PartyLevel.MOSH_PIT
        elif self.level == PartyLevel.MOSH_PIT:
            self.level = PartyLevel.CARNIVAL_CHAOS
        elif self.level == PartyLevel.CARNIVAL_CHAOS:
            self.level = PartyLevel.FULL_WHIPPIN
        
        # Update effects for new level
        self._update_effects()
        
        return {
            "success": True,
            "old_level": old_level.name,
            "new_level": self.level.name,
            "effects": self.effects_active,
        }
    
    def _update_effects(self):
        """Update active effects based on level."""
        level_config = PARTY_LEVELS.get(self.level.value, {})
        
        self.effects_active = {
            "energy_drain": level_config.get("energy_cost", 1),
            "duration_mult": level_config.get("duration_mult", 1.0),
            "chaos_level": self.level.value / 5.0,
            "faygo_attraction": self.level.value * 2,
        }
        
        # Level-specific effects
        if self.level == PartyLevel.FAYGO_SHOWER:
            self.effects_active["faygo_rain"] = True
        
        if self.level == PartyLevel.MOSH_PIT:
            self.effects_active["physical_chaos"] = True
            self.effects_active["injury_chance"] = 0.05
        
        if self.level == PartyLevel.CARNIVAL_CHAOS:
            self.effects_active["midway_involved"] = True
            self.effects_active["ride_malfunction"] = 0.1
        
        if self.level == PartyLevel.FULL_WHIPPIN:
            self.effects_active["maximum_chaos"] = True
            self.effects_active["reality_bending"] = 0.3
    
    def mosh(self, entity_id: str) -> Dict[str, Any]:
        """Perform a mosh action."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        if self.level.value < PartyLevel.MOSH_PIT.value:
            return {"success": False, "reason": "level_too_low"}
        
        participant = self.participants[entity_id]
        participant.mosh_count += 1
        
        # Mosh adds energy and chaos
        self.energy_total += 5
        
        # Random effects
        effects = {}
        if random.random() < 0.1:
            effects["collision"] = True
        if random.random() < 0.05:
            effects["crowd_surf"] = True
        
        return {
            "success": True,
            "mosh_count": participant.mosh_count,
            "effects": effects,
        }
    
    def tick(self, current_tick: int = 0) -> Dict[str, Any]:
        """Process party tick."""
        self.duration = current_tick - self.start_tick
        
        # Energy decay
        self.energy_total *= 0.98
        
        # State transitions
        if self.state == PartyState.FORMING:
            if self.participant_count >= 3:
                self.state = PartyState.ACTIVE
            elif self.duration > 50:
                self.state = PartyState.ENDED
        
        elif self.state == PartyState.ACTIVE:
            # Check for peak
            if self.energy_total > 500 and self.peak_tick is None:
                self.state = PartyState.PEAK
                self.peak_tick = current_tick
            
            # Check for winding down
            if self.participant_count < 3 or self.duration > PARTY_MAX_DURATION:
                self.state = PartyState.WINDING_DOWN
        
        elif self.state == PartyState.PEAK:
            if self.energy_total < 200:
                self.state = PartyState.WINDING_DOWN
        
        elif self.state == PartyState.WINDING_DOWN:
            if self.participant_count <= 1 or self.energy_total < 10:
                self.state = PartyState.ENDED
        
        return {
            "party_id": self.party_id,
            "state": self.state.name,
            "level": self.level.name,
            "duration": self.duration,
            "energy": self.energy_total,
            "participants": self.participant_count,
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize party state."""
        return {
            "party_id": self.party_id,
            "host_id": self.host_id,
            "level": self.level.name,
            "state": self.state.name,
            "participant_count": self.participant_count,
            "energy_total": self.energy_total,
            "duration": self.duration,
        }


class JuggaloParty:
    """
    System that manages all Juggalo Parties.
    
    Handles creation, lookup, and global party effects.
    """
    
    def __init__(self):
        self.active_parties: Dict[str, Party] = {}
        self.ended_parties: List[Party] = []  # Archive for 0 = 3
        self.entity_to_party: Dict[str, str] = {}  # Which party each entity is in
        self._tick_count = 0
    
    def start_party(
        self,
        host_id: str,
        x: float = 0.0,
        y: float = 0.0
    ) -> Party:
        """
        Start a new party.
        
        Args:
            host_id: Entity hosting the party
            x, y: Party location
            
        Returns:
            The created party
        """
        # Check if host is already in a party
        if host_id in self.entity_to_party:
            existing_id = self.entity_to_party[host_id]
            return self.active_parties.get(existing_id)
        
        party = Party.create(host_id, x, y, self._tick_count)
        party.join(host_id, self._tick_count)
        
        self.active_parties[party.party_id] = party
        self.entity_to_party[host_id] = party.party_id
        
        return party
    
    def get_party(self, party_id: str) -> Optional[Party]:
        """Get a party by ID."""
        return self.active_parties.get(party_id)
    
    def get_party_for_entity(self, entity_id: str) -> Optional[Party]:
        """Get the party an entity is in."""
        party_id = self.entity_to_party.get(entity_id)
        if party_id:
            return self.active_parties.get(party_id)
        return None
    
    def join_party(self, party_id: str, entity_id: str) -> Dict[str, Any]:
        """Add an entity to a party."""
        # Leave existing party first
        if entity_id in self.entity_to_party:
            self.leave_party(entity_id)
        
        party = self.active_parties.get(party_id)
        if not party:
            return {"success": False, "reason": "party_not_found"}
        
        result = party.join(entity_id, self._tick_count)
        
        if result["success"]:
            self.entity_to_party[entity_id] = party_id
        
        return result
    
    def leave_party(self, entity_id: str) -> Dict[str, Any]:
        """Remove an entity from their party."""
        party_id = self.entity_to_party.get(entity_id)
        
        if not party_id:
            return {"success": False, "reason": "not_in_party"}
        
        party = self.active_parties.get(party_id)
        if not party:
            del self.entity_to_party[entity_id]
            return {"success": False, "reason": "party_not_found"}
        
        result = party.leave(entity_id)
        del self.entity_to_party[entity_id]
        
        # Archive if ended
        if party.state == PartyState.ENDED:
            self.ended_parties.append(party)
            del self.active_parties[party_id]
        
        return result
    
    def get_parties_at_location(self, x: float, y: float, radius: float = 10.0) -> List[Party]:
        """Get all parties within radius of a location."""
        import math
        
        return [
            p for p in self.active_parties.values()
            if math.sqrt((p.location_x - x)**2 + (p.location_y - y)**2) <= radius
        ]
    
    def get_global_chaos_level(self) -> float:
        """Get total chaos level from all active parties."""
        total = 0.0
        for party in self.active_parties.values():
            total += party.level.value * party.participant_count
        return min(1.0, total / 50)  # Normalize
    
    def tick(self) -> Dict[str, Any]:
        """Process all parties for one tick."""
        self._tick_count += 1
        
        results = []
        ended = []
        
        for party_id, party in self.active_parties.items():
            result = party.tick(self._tick_count)
            results.append(result)
            
            if party.state == PartyState.ENDED:
                ended.append(party_id)
        
        # Archive ended parties
        for party_id in ended:
            party = self.active_parties.pop(party_id)
            self.ended_parties.append(party)
            
            # Clean up entity mappings
            for entity_id in list(party.participants.keys()):
                if entity_id in self.entity_to_party:
                    if self.entity_to_party[entity_id] == party_id:
                        del self.entity_to_party[entity_id]
        
        return {
            "tick": self._tick_count,
            "active_parties": len(self.active_parties),
            "total_participants": len(self.entity_to_party),
            "global_chaos": self.get_global_chaos_level(),
            "ended_this_tick": len(ended),
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_count": len(self.active_parties),
            "ended_count": len(self.ended_parties),
            "parties": [p.serialize() for p in self.active_parties.values()],
        }


        
        # Target roll (hollow authority rolls poorly)
        if target.hollow:
            target_roll = random.random() * 10  # Hollow rolls 1-10
        else:
            target_roll = random.random() * target.effective_authority
        
        success = challenger_roll > target_roll
        
        # Record challenge
        challenge_record = AuthorityChallenge(
            challenger_id=str(self._component_id),
            target_id=str(target._component_id),
            challenger_roll=challenger_roll,
            target_roll=target_roll,
            success=success,
            tick=tick,
        )
        
        if success:
            self.challenges_won += 1
            target.challenges_lost += 1
            
            # Expose hollow authority
            if target.hollow:
                target.hollow_exposed = True
            
            # Possible level change (rare)
            if random.random() < 0.1:
                # Steal some authority
                self.effective_authority = min(
                    100, 
                    self.effective_authority + 5
                )
                target.effective_authority = max(
                    0,
                    target.effective_authority - 5
                )
        else:
            self.challenges_lost += 1
            target.challenges_won += 1
        
        self._last_challenge_tick = tick
        
        return {
            "success": success,
            "challenger_roll": challenger_roll,
            "target_roll": target_roll,
            "target_was_hollow": target.hollow,
            "target_exposed": target.hollow_exposed if target.hollow else False,
        }
    
    def _recalculate_effective(self):
        """Recalculate effective authority based on level and modifiers."""
        base = AUTHORITY_LEVELS.get(self.level.name, 0)
        
        # Challenges affect effective authority
        challenge_modifier = 0
        if self.challenges_won + self.challenges_lost > 0:
            win_rate = self.challenges_won / (self.challenges_won + self.challenges_lost)
            challenge_modifier = (win_rate - 0.5) * 10
        
        self.effective_authority = max(0, min(100, base + challenge_modifier - self._authority_decay))
    
    def tick(self, current_tick: int = 0):
        """Process authority tick."""
        # Authority slowly normalizes
        target = AUTHORITY_LEVELS.get(self.level.name, 0)
        
        if self.effective_authority > target:
            self._authority_decay += 0.01
        elif self.effective_authority < target:
            self._authority_decay = max(0, self._authority_decay - 0.01)
        
        self._recalculate_effective()
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "level": self.level.name,
            "effective_authority": self.effective_authority,
            "hollow": self.hollow,
            "hollow_exposed": self.hollow_exposed,
            "commands_issued": self.commands_issued,
            "challenges_won": self.challenges_won,
            "challenges_lost": self.challenges_lost,
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "AuthorityComponent":
        """Reconstruct from serialized data."""
        comp = cls(level=AuthorityLevel[data.get("level", "NORMAL")])
        comp.effective_authority = data.get("effective_authority", 0)
        comp.hollow = data.get("hollow", False)
        comp.hollow_exposed = data.get("hollow_exposed", False)
        comp.commands_issued = data.get("commands_issued", 0)
        comp.challenges_won = data.get("challenges_won", 0)
        comp.challenges_lost = data.get("challenges_lost", 0)
        return comp


class HollowAuthorityDetector:
    """
    Utility for detecting hollow authority.
    
    Used by systems to reveal fake authority.
    """
    
    @staticmethod
    def scan(authority: AuthorityComponent) -> Dict[str, Any]:
        """
        Scan an authority for hollowness.
        
        Returns detection data.
        """
        if not authority.hollow:
            return {
                "hollow": False,
                "confidence": 1.0,
            }
        
        # Detection chance based on various factors
        detection_chance = 0.1
        
        if authority.hollow_exposed:
            detection_chance = 1.0
        
        # Challenges increase detection chance
        detection_chance += authority.challenges_lost * 0.05
        
        detected = random.random() < detection_chance
        
        return {
            "hollow": detected,
            "confidence": detection_chance if detected else 0,
        }

"""
Hidden Potential Component
==========================
Latent abilities waiting to be discovered.

Hidden potential represents abilities or bonuses
that exist but aren't yet revealed or activated.

Discovery mechanics:
- Events can reveal potential
- Certain conditions unlock potential
- Potential can be stored or released

Design: Hidden potential is physics - it exists before discovery.
"""

from typing import Dict, Any, List, Optional, Callable
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..core.component import Component
from ..constants import PHI


class PotentialType(Enum):
    """Types of hidden potential."""
    STAT_BOOST = auto()
    ABILITY_UNLOCK = auto()
    RESISTANCE = auto()
    AFFINITY = auto()
    SECRET_KNOWLEDGE = auto()
    HIDDEN_TALENT = auto()
    DORMANT_POWER = auto()
    ANCESTRAL_MEMORY = auto()


class PotentialState(Enum):
    """States of potential."""
    DORMANT = auto()      # Not yet discoverable
    HIDDEN = auto()       # Discoverable but not found
    DISCOVERED = auto()   # Found but not activated
    ACTIVE = auto()       # Currently active
    EXHAUSTED = auto()    # Used up


@dataclass
class Potential:
    """A single hidden potential."""
    potential_id: str
    potential_type: PotentialType
    state: PotentialState = PotentialState.HIDDEN
    name: str = ""
    description: str = ""
    power: float = 1.0
    discovery_conditions: Dict[str, Any] = field(default_factory=dict)
    activation_conditions: Dict[str, Any] = field(default_factory=dict)
    effects: Dict[str, float] = field(default_factory=dict)
    duration: Optional[int] = None  # None = permanent
    cooldown: int = 0
    current_cooldown: int = 0
    uses_remaining: int = -1  # -1 = unlimited
    
    def can_discover(self, context: Dict[str, Any]) -> bool:
        """Check if discovery conditions are met."""
        for key, required in self.discovery_conditions.items():
            if context.get(key) != required:
                return False
        return True
    
    def can_activate(self, context: Dict[str, Any]) -> bool:
        """Check if activation conditions are met."""
        if self.state not in (PotentialState.DISCOVERED, PotentialState.ACTIVE):
            return False
        
        if self.current_cooldown > 0:
            return False
        
        if self.uses_remaining == 0:
            return False
        
        for key, required in self.activation_conditions.items():
            if context.get(key) != required:
                return False
        
        return True
    
    def discover(self) -> bool:
        """Mark this potential as discovered."""
        if self.state == PotentialState.DORMANT:
            return False
        
        self.state = PotentialState.DISCOVERED
        return True
    
    def activate(self) -> Dict[str, Any]:
        """Activate this potential."""
        if not self.can_activate({}):
            return {"success": False, "reason": "cannot_activate"}
        
        self.state = PotentialState.ACTIVE
        self.current_cooldown = self.cooldown
        
        if self.uses_remaining > 0:
            self.uses_remaining -= 1
        
        return {
            "success": True,
            "effects": self.effects.copy(),
            "duration": self.duration,
        }
    
    def tick(self):
        """Process potential tick."""
        if self.current_cooldown > 0:
            self.current_cooldown -= 1
        
        if self.state == PotentialState.ACTIVE:
            if self.uses_remaining == 0:
                self.state = PotentialState.EXHAUSTED


class HiddenPotentialComponent(Component):
    """
    Component for hidden potential mechanics.
    
    Entities can have multiple potentials waiting to be discovered.
    
    Attributes:
        potentials: All potentials (dormant, hidden, discovered, active)
        discovery_bonus: Bonus to discovery checks
        activation_bonus: Bonus to activation checks
        discovered_count: Total potentials discovered
        activated_count: Total potentials activated
    """
    
    _potential_counter = 0
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        self.potentials: Dict[str, Potential] = {}
        self.discovery_bonus = 0.0
        self.activation_bonus = 0.0
        self.discovered_count = 0
        self.activated_count = 0
    
    def add_potential(
        self,
        potential_type: PotentialType,
        name: str = "",
        power: float = 1.0,
        discovery_conditions: Dict = None,
        activation_conditions: Dict = None,
        effects: Dict = None,
        **kwargs
    ) -> Potential:
        """
        Add a new hidden potential.
        
        Returns the created potential.
        """
        HiddenPotentialComponent._potential_counter += 1
        potential_id = f"potential_{HiddenPotentialComponent._potential_counter}"
        
        potential = Potential(
            potential_id=potential_id,
            potential_type=potential_type,
            name=name or f"{potential_type.name.title()} Potential",
            power=power,
            discovery_conditions=discovery_conditions or {},
            activation_conditions=activation_conditions or {},
            effects=effects or {},
            **kwargs
        )
        
        self.potentials[potential_id] = potential
        return potential
    
    def get_potential(self, potential_id: str) -> Optional[Potential]:
        """Get a potential by ID."""
        return self.potentials.get(potential_id)
    
    def get_potentials_by_state(self, state: PotentialState) -> List[Potential]:
        """Get all potentials in a specific state."""
        return [p for p in self.potentials.values() if p.state == state]
    
    def get_potentials_by_type(self, ptype: PotentialType) -> List[Potential]:
        """Get all potentials of a specific type."""
        return [p for p in self.potentials.values() if p.potential_type == ptype]
    
    def check_discovery(self, context: Dict[str, Any]) -> List[Potential]:
        """
        Check for potential discoveries.
        
        Returns list of newly discovered potentials.
        """
        discovered = []
        
        for potential in self.potentials.values():
            if potential.state != PotentialState.HIDDEN:
                continue
            
            # Check discovery conditions
            if potential.can_discover(context):
                # Discovery roll
                discovery_chance = 0.5 + self.discovery_bonus
                
                if random.random() < discovery_chance:
                    potential.discover()
                    discovered.append(potential)
                    self.discovered_count += 1
        
        return discovered
    
    def activate_potential(
        self,
        potential_id: str,
        context: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Attempt to activate a potential.
        
        Returns activation result.
        """
        potential = self.potentials.get(potential_id)
        
        if not potential:
            return {"success": False, "reason": "not_found"}
        
        context = context or {}
        
        # Apply activation bonus
        modified_context = context.copy()
        modified_context["_activation_bonus"] = self.activation_bonus
        
        if not potential.can_activate(modified_context):
            return {"success": False, "reason": "conditions_not_met"}
        
        result = potential.activate()
        
        if result["success"]:
            self.activated_count += 1
            result["potential_id"] = potential_id
            result["potential_name"] = potential.name
        
        return result
    
    def get_active_effects(self) -> Dict[str, float]:
        """Get all active effect modifiers."""
        total_effects = {}
        
        for potential in self.potentials.values():
            if potential.state == PotentialState.ACTIVE:
                for effect, value in potential.effects.items():
                    if effect in total_effects:
                        total_effects[effect] += value * potential.power
                    else:
                        total_effects[effect] = value * potential.power
        
        return total_effects
    
    def tick(self, current_tick: int = 0):
        """Process all potential ticks."""
        for potential in self.potentials.values():
            potential.tick()
    
    def get_summary(self) -> Dict[str, Any]:
        """Get summary of potentials."""
        return {
            "total_potentials": len(self.potentials),
            "dormant": len(self.get_potentials_by_state(PotentialState.DORMANT)),
            "hidden": len(self.get_potentials_by_state(PotentialState.HIDDEN)),
            "discovered": len(self.get_potentials_by_state(PotentialState.DISCOVERED)),
            "active": len(self.get_potentials_by_state(PotentialState.ACTIVE)),
            "exhausted": len(self.get_potentials_by_state(PotentialState.EXHAUSTED)),
            "discovered_total": self.discovered_count,
            "activated_total": self.activated_count,
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "discovery_bonus": self.discovery_bonus,
            "activation_bonus": self.activation_bonus,
            "discovered_count": self.discovered_count,
            "activated_count": self.activated_count,
            "potentials": {
                pid: {
                    "type": p.potential_type.name,
                    "state": p.state.name,
                    "name": p.name,
                    "power": p.power,
                }
                for pid, p in self.potentials.items()
            },
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "HiddenPotentialComponent":
        """Reconstruct from serialized data."""
        comp = cls()
        comp.discovery_bonus = data.get("discovery_bonus", 0)
        comp.activation_bonus = data.get("activation_bonus", 0)
        comp.discovered_count = data.get("discovered_count", 0)
        comp.activated_count = data.get("activated_count", 0)
        return comp

"""
Toxicity Component
==================
Corrosion and corruption mechanics.

Toxicity tracks how corrupted, poisoned, or tainted an entity is.
It can come from:
- Environmental hazards
- Items/curses
- Other entities
- Actions

Toxicity flows and accumulates. It can be cleansed but never truly deleted (0 = 3).

Design: Toxicity is physics - it's real contamination that spreads.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..core.component import Component
from ..constants import PHI


class ToxicityType(Enum):
    """Types of toxicity."""
    PHYSICAL = auto()      # Poison, disease
    MENTAL = auto()        # Corruption of mind
    SPIRITUAL = auto()     # Soul taint
    ENVIRONMENTAL = auto() # From the biome
    SOCIAL = auto()        # Reputation damage
    FAYGO = auto()         # From bad Faygo
    MIDWAY = auto()        # From carnival games
    CHAOS = auto()         # From chaos energy


@dataclass
class ToxicitySource:
    """Source of toxicity."""
    source_type: str
    toxicity_type: ToxicityType
    amount: float
    tick: int
    active: bool = True


@dataclass
class ToxinInstance:
    """An active toxin in the entity."""
    toxin_id: str
    toxicity_type: ToxicityType
    severity: float  # 0-1
    duration: Optional[int] = None
    tick_count: int = 0
    effects: Dict[str, float] = field(default_factory=dict)
    source: str = ""
    
    def tick(self) -> Dict[str, Any]:
        """Process toxin tick."""
        self.tick_count += 1
        
        # Check duration
        if self.duration is not None:
            self.duration -= 1
            if self.duration <= 0:
                return {"expired": True}
        
        # Apply effects
        applied_effects = {}
        for effect, base_value in self.effects.items():
            applied_effects[effect] = base_value * self.severity
        
        return {"expired": False, "effects": applied_effects}


class ToxicityComponent(Component):
    """
    Component for tracking toxicity/corruption.
    
    Entities can accumulate multiple types of toxins.
    
    Attributes:
        toxins: Active toxin instances
        sources: Sources of toxicity
        resistances: Resistance per toxicity type
        total_toxicity: Overall toxicity level
        immunity_types: Types entity is immune to
        cleansing_rate: Natural toxin removal rate
    """
    
    _toxin_counter = 0
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        
        self.toxins: Dict[str, ToxinInstance] = {}
        self.sources: List[ToxicitySource] = []
        self.resistances: Dict[ToxicityType, float] = {}
        self.total_toxicity = 0.0
        self.immunity_types: Set[ToxicityType] = set()
        self.cleansing_rate = 0.01
        
        self._last_cleansing = 0
    
    def add_resistance(self, toxicity_type: ToxicityType, amount: float):
        """Add resistance to a toxicity type."""
        current = self.resistances.get(toxicity_type, 0)
        self.resistances[toxicity_type] = min(1.0, current + amount)
    
    def add_immunity(self, toxicity_type: ToxicityType):
        """Add complete immunity to a toxicity type."""
        self.immunity_types.add(toxicity_type)
    
    def apply_toxin(
        self,
        toxicity_type: ToxicityType,
        severity: float = 0.5,
        source: str = "",
        duration: Optional[int] = None,
        effects: Dict[str, float] = None
    ) -> Dict[str, Any]:
        """
        Apply a toxin to this entity.
        
        Args:
            toxicity_type: Type of toxin
            severity: How severe (0-1)
            source: Source of toxin
            duration: Duration in ticks (None = permanent)
            effects: Effect modifiers
            
        Returns:
            Result of toxin application
        """
        # Check immunity
        if toxicity_type in self.immunity_types:
            return {
                "success": False,
                "reason": "immune",
                "toxicity_type": toxicity_type.name,
            }
        
        # Apply resistance
        resistance = self.resistances.get(toxicity_type, 0)
        effective_severity = severity * (1 - resistance)
        
        if effective_severity <= 0:
            return {
                "success": False,
                "reason": "resisted",
                "toxicity_type": toxicity_type.name,
            }
        
        # Create toxin instance
        ToxicityComponent._toxin_counter += 1
        toxin_id = f"toxin_{ToxicityComponent._toxin_counter}"
        
        toxin = ToxinInstance(
            toxin_id=toxin_id,
            toxicity_type=toxicity_type,
            severity=effective_severity,
            duration=duration,
            effects=effects or {},
            source=source,
        )
        
        self.toxins[toxin_id] = toxin
        self._recalculate_total()
        
        # Record source
        self.sources.append(ToxicitySource(
            source_type=source,
            toxicity_type=toxicity_type,
            amount=effective_severity,
            tick=0,
        ))
        
        return {
            "success": True,
            "toxin_id": toxin_id,
            "toxicity_type": toxicity_type.name,
            "effective_severity": effective_severity,
            "duration": duration,
        }
    
    def remove_toxin(self, toxin_id: str) -> Dict[str, Any]:
        """
        Remove a specific toxin.
        
        Note: This is a soft removal (0 = 3).
        """
        if toxin_id not in self.toxins:
            return {"success": False, "reason": "not_found"}
        
        toxin = self.toxins[toxin_id]
        toxin.severity = 0  # Neutralized but record remains
        
        # Move to inactive
        self._recalculate_total()
        
        return {
            "success": True,
            "toxin_id": toxin_id,
            "type": toxin.toxicity_type.name,
        }
    
    def cleanse(
        self,
        amount: float = 0.1,
        toxicity_type: Optional[ToxicityType] = None
    ) -> Dict[str, Any]:
        """
        Cleanse toxins.
        
        Args:
            amount: How much to cleanse
            toxicity_type: Specific type to cleanse (None = all)
            
        Returns:
            Data about cleansing
        """
        cleansed_amount = 0
        cleansed_toxins = []
        
        for toxin_id, toxin in list(self.toxins.items()):
            if toxicity_type and toxin.toxicity_type != toxicity_type:
                continue
            
            if toxin.severity > 0:
                reduction = min(toxin.severity, amount)
                toxin.severity -= reduction
                cleansed_amount += reduction
                
                if toxin.severity <= 0:
                    cleansed_toxins.append(toxin_id)
        
        self._recalculate_total()
        
        return {
            "success": True,
            "cleansed_amount": cleansed_amount,
            "cleansed_toxins": cleansed_toxins,
            "remaining_toxicity": self.total_toxicity,
        }
    
    def _recalculate_total(self):
        """Recalculate total toxicity level."""
        self.total_toxicity = sum(
            toxin.severity for toxin in self.toxins.values()
        )
    
    def get_toxins_by_type(self, toxicity_type: ToxicityType) -> List[ToxinInstance]:
        """Get all toxins of a specific type."""
        return [
            t for t in self.toxins.values()
            if t.toxicity_type == toxicity_type and t.severity > 0
        ]
    
    def get_toxicity_effects(self) -> Dict[str, float]:
        """Get combined effects from all toxins."""
        combined = {}
        
        for toxin in self.toxins.values():
            if toxin.severity <= 0:
                continue
            
            for effect, base_value in toxin.effects.items():
                value = base_value * toxin.severity
                if effect in combined:
                    combined[effect] += value
                else:
                    combined[effect] = value
        
        return combined
    
    def tick(self, current_tick: int = 0):
        """Process toxicity tick."""
        expired_toxins = []
        
        for toxin_id, toxin in self.toxins.items():
            result = toxin.tick()
            
            if result.get("expired"):
                expired_toxins.append(toxin_id)
        
        for toxin_id in expired_toxins:
            del self.toxins[toxin_id]
        
        # Natural cleansing
        if random.random() < self.cleansing_rate:
            self.cleanse(0.01)
        
        self._recalculate_total()
        self._last_cleansing = current_tick
    
    def get_severity_tier(self) -> str:
        """Get toxicity severity tier."""
        if self.total_toxicity <= 0.1:
            return "CLEAN"
        elif self.total_toxicity <= 0.3:
            return "MILD"
        elif self.total_toxicity <= 0.5:
            return "MODERATE"
        elif self.total_toxicity <= 0.7:
            return "SEVERE"
        elif self.total_toxicity <= 0.9:
            return "CRITICAL"
        else:
            return "LETHAL"
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize component state."""
        data = super().serialize()
        data.update({
            "total_toxicity": self.total_toxicity,
            "toxin_count": len(self.toxins),
            "severity_tier": self.get_severity_tier(),
            "resistances": {
                t.name: v for t, v in self.resistances.items()
            },
            "immunities": [t.name for t in self.immunity_types],
        })
        return data
    
    @classmethod
    def deserialize(cls, data: Dict[str, Any]) -> "ToxicityComponent":
        """Reconstruct from serialized data."""
        comp = cls()
        comp.total_toxicity = data.get("total_toxicity", 0)
        comp.resistances = {
            ToxicityType[name]: value
            for name, value in data.get("resistances", {}).items()
        }
        comp.immunity_types = {
            ToxicityType[name]
            for name in data.get("immunities", [])
        }
        return comp

"""
DLC Systems
===========
Logic processors that operate on components.
Systems are the physics engines of the DLC.
"""

from .magnetic_fields import MagneticFieldsSystem
from .rumor import RumorManager, Rumor
from .party import JuggaloParty, PartyLevel
from .midway import MidwaySystem
from .yellow_bus import YellowBusSystem
from .diamond_rain import DiamondRainSystem
from .thermodynamics import ThermodynamicsSystem

__all__ = [
    "MagneticFieldsSystem",
    "RumorManager", "Rumor",
    "JuggaloParty", "PartyLevel",
    "MidwaySystem",
    "YellowBusSystem",
    "DiamondRainSystem",
    "ThermodynamicsSystem",
]

"""
Magnetic Fields System
======================
Controls Madrox particle attraction/repulsion.

Magnetic fields are generated by entities and locations.
Madrox particles (anxiety thoughts) respond to these fields.

Field Sources:
- Calm sources attract particles (healing)
- Chaos sources repel particles (escalation)
- Neutral sources have no effect

Design: Magnetic fields are physics - they exert real force.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import math

from ..constants import (
    MAGNETIC_FIELD_STRENGTH,
    MAGNETIC_FIELD_DECAY,
    MAGNETIC_FIELD_RADIUS,
    MADROX_CALM_ATTRACTION,
    MADROX_CHAOS_REPULSION,
    PHI,
)


class FieldPolarity(Enum):
    """Magnetic field polarity types."""
    CALM = auto()      # Attracts Madrox particles
    CHAOS = auto()     # Repels Madrox particles
    NEUTRAL = auto()   # No effect


@dataclass
class MagneticField:
    """
    A magnetic field in the carnival.
    
    Fields affect Madrox particles within their radius.
    """
    field_id: str
    x: float
    y: float
    polarity: FieldPolarity
    strength: float = 1.0
    radius: float = MAGNETIC_FIELD_RADIUS
    source_id: str = ""  # Entity or location that created this field
    active: bool = True
    
    def get_force_at(self, px: float, py: float) -> Tuple[float, float]:
        """
        Calculate force on a particle at given position.
        
        Returns (force_x, force_y) vector.
        """
        if not self.active:
            return (0.0, 0.0)
        
        dx = self.x - px
        dy = self.y - py
        dist = math.sqrt(dx * dx + dy * dy)
        
        if dist > self.radius or dist < 0.1:
            return (0.0, 0.0)
        
        # Normalize direction
        if dist > 0:
            nx = dx / dist
            ny = dy / dist
        else:
            nx, ny = 0, 0
        
        # Calculate force magnitude (inverse square)
        magnitude = (self.strength * MAGNETIC_FIELD_STRENGTH) / (dist * dist)
        
        # Apply polarity
        if self.polarity == FieldPolarity.CALM:
            # Attract - force toward field center
            return (nx * magnitude * MADROX_CALM_ATTRACTION, 
                    ny * magnitude * MADROX_CALM_ATTRACTION)
        elif self.polarity == FieldPolarity.CHAOS:
            # Repel - force away from field center
            return (-nx * magnitude * MADROX_CHAOS_REPULSION,
                    -ny * magnitude * MADROX_CHAOS_REPULSION)
        else:
            return (0.0, 0.0)
    
    def tick(self):
        """Process field tick - decay strength."""
        self.strength *= MAGNETIC_FIELD_DECAY
        
        if self.strength < 0.01:
            self.active = False


@dataclass
class ParticleState:
    """State of a Madrox particle in the field system."""
    particle_id: int
    owner_id: str
    x: float
    y: float
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    energy: float = 1.0
    anchored: bool = False


class MagneticFieldsSystem:
    """
    System that manages magnetic fields and particle movement.
    
    Processes all fields each tick and updates particle positions.
    Works with MadroxComponent to sync particle states.
    """
    
    _field_counter = 0
    
    def __init__(self):
        self.fields: Dict[str, MagneticField] = {}
        self.particles: Dict[int, ParticleState] = {}
        self._tick_count = 0
    
    def create_field(
        self,
        x: float,
        y: float,
        polarity: FieldPolarity,
        strength: float = 1.0,
        radius: float = None,
        source_id: str = ""
    ) -> MagneticField:
        """
        Create a new magnetic field.
        
        Args:
            x, y: Field center position
            polarity: CALM, CHAOS, or NEUTRAL
            strength: Field strength
            radius: Effect radius (default from constants)
            source_id: ID of creating entity
            
        Returns:
            The created field
        """
        MagneticFieldsSystem._field_counter += 1
        field_id = f"field_{MagneticFieldsSystem._field_counter}"
        
        field = MagneticField(
            field_id=field_id,
            x=x,
            y=y,
            polarity=polarity,
            strength=strength,
            radius=radius or MAGNETIC_FIELD_RADIUS,
            source_id=source_id,
        )
        
        self.fields[field_id] = field
        return field
    
    def remove_field(self, field_id: str) -> bool:
        """Remove a field by ID."""
        if field_id in self.fields:
            del self.fields[field_id]
            return True
        return False
    
    def get_fields_at(self, x: float, y: float) -> List[MagneticField]:
        """Get all fields affecting a position."""
        return [
            f for f in self.fields.values()
            if f.active and math.sqrt((f.x - x)**2 + (f.y - y)**2) <= f.radius
        ]
    
    def register_particle(
        self,
        particle_id: int,
        owner_id: str,
        x: float,
        y: float,
        velocity_x: float = 0.0,
        velocity_y: float = 0.0,
        energy: float = 1.0
    ):
        """Register a particle for field processing."""
        self.particles[particle_id] = ParticleState(
            particle_id=particle_id,
            owner_id=owner_id,
            x=x,
            y=y,
            velocity_x=velocity_x,
            velocity_y=velocity_y,
            energy=energy,
        )
    
    def unregister_particle(self, particle_id: int):
        """Remove a particle from processing."""
        if particle_id in self.particles:
            del self.particles[particle_id]
    
    def update_particle_position(
        self,
        particle_id: int,
        x: float,
        y: float
    ):
        """Update particle position."""
        if particle_id in self.particles:
            self.particles[particle_id].x = x
            self.particles[particle_id].y = y
    
    def calculate_total_force(
        self,
        x: float,
        y: float,
        exclude_source: str = None
    ) -> Tuple[float, float]:
        """
        Calculate total magnetic force at a position.
        
        Args:
            x, y: Position to check
            exclude_source: Optional source ID to exclude
            
        Returns:
            (total_force_x, total_force_y)
        """
        total_fx, total_fy = 0.0, 0.0
        
        for field in self.fields.values():
            if not field.active:
                continue
            
            if exclude_source and field.source_id == exclude_source:
                continue
            
            fx, fy = field.get_force_at(x, y)
            total_fx += fx
            total_fy += fy
        
        return (total_fx, total_fy)
    
    def tick(self) -> Dict[str, Any]:
        """
        Process one tick of the magnetic field system.
        
        Updates all fields and particles.
        
        Returns:
            Summary of tick processing
        """
        self._tick_count += 1
        
        # Update fields (decay)
        expired_fields = []
        for field_id, field in self.fields.items():
            field.tick()
            if not field.active:
                expired_fields.append(field_id)
        
        # Remove expired fields
        for field_id in expired_fields:
            del self.fields[field_id]
        
        # Update particles
        particles_updated = 0
        particles_anchored = 0
        
        for particle in self.particles.values():
            if particle.anchored:
                particles_anchored += 1
                continue
            
            # Get total force
            fx, fy = self.calculate_total_force(
                particle.x, 
                particle.y,
                exclude_source=particle.owner_id
            )
            
            # Apply force to velocity
            particle.velocity_x += fx
            particle.velocity_y += fy
            
            # Apply velocity
            particle.x += particle.velocity_x
            particle.y += particle.velocity_y
            
            # Damping
            particle.velocity_x *= 0.95
            particle.velocity_y *= 0.95
            
            # Energy decay
            particle.energy *= 0.99
            
            particles_updated += 1
        
        return {
            "tick": self._tick_count,
            "active_fields": len(self.fields),
            "total_particles": len(self.particles),
            "particles_updated": particles_updated,
            "particles_anchored": particles_anchored,
            "fields_expired": len(expired_fields),
        }
    
    def get_field_strength_at(self, x: float, y: float) -> Dict[str, float]:
        """
        Get total field strength by polarity at a position.
        
        Returns dict with 'calm', 'chaos', 'neutral' strengths.
        """
        strengths = {"calm": 0.0, "chaos": 0.0, "neutral": 0.0}
        
        for field in self.fields.values():
            if not field.active:
                continue
            
            dist = math.sqrt((field.x - x)**2 + (field.y - y)**2)
            if dist > field.radius:
                continue
            
            contribution = field.strength / (dist + 1)
            
            if field.polarity == FieldPolarity.CALM:
                strengths["calm"] += contribution
            elif field.polarity == FieldPolarity.CHAOS:
                strengths["chaos"] += contribution
            else:
                strengths["neutral"] += contribution
        
        return strengths
    
    def get_dominant_polarity_at(self, x: float, y: float) -> Optional[FieldPolarity]:
        """Get the dominant field polarity at a position."""
        strengths = self.get_field_strength_at(x, y)
        
        if all(v == 0 for v in strengths.values()):
            return None
        
        dominant = max(strengths, key=strengths.get)
        
        if dominant == "calm":
            return FieldPolarity.CALM
        elif dominant == "chaos":
            return FieldPolarity.CHAOS
        else:
            return FieldPolarity.NEUTRAL
    
    def clear_all_fields(self):
        """Remove all fields."""
        self.fields.clear()
    
    def clear_all_particles(self):
        """Remove all particles."""
        self.particles.clear()
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "field_count": len(self.fields),
            "particle_count": len(self.particles),
            "fields": [
                {
                    "id": f.field_id,
                    "x": f.x,
                    "y": f.y,
                    "polarity": f.polarity.name,
                    "strength": f.strength,
                    "radius": f.radius,
                }
                for f in self.fields.values()
            ],
        }

"""
Rumor System
============
Information as particles.

Rumors spread through the carnival like wildfire.
They can mutate, die out, or become accepted truth.

Rumor Lifecycle:
1. BORN - New rumor created
2. SPREADING - Actively spreading
3. PEAK - Maximum spread
4. DYING - Losing momentum
5. DEAD - No longer active (but archived - 0 = 3)

Rumors have a "truth value" that may or may not reflect reality.

Design: Rumors are physics - they are real information particles.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import time

from ..constants import (
    RUMOR_MAX_SPREAD,
    RUMOR_DECAY_RATE,
    RUMOR_MUTATION_CHANCE,
    RUMOR_MAX_TRUTH,
    PHI,
)


class RumorState(Enum):
    """Lifecycle states of a rumor."""
    BORN = auto()
    SPREADING = auto()
    PEAK = auto()
    DYING = auto()
    DEAD = auto()


@dataclass
class RumorVariant:
    """A variant of a rumor (from mutation)."""
    variant_id: str
    content: str
    truth_modifier: float  # How this variant changes perceived truth
    spread_count: int = 0


@dataclass
class Rumor:
    """
    A rumor in the carnival.
    
    Rumors spread, mutate, and can be proven true or false.
    """
    rumor_id: str
    content: str
    source_id: str
    state: RumorState = RumorState.BORN
    
    # Truth tracking
    actual_truth: Optional[bool] = None  # None = unknown, True/False = verified
    perceived_truth: float = 0.5  # What people believe (0-1)
    truth_confidence: float = 0.0  # How confident in perceived truth
    
    # Spread tracking
    spread_count: int = 0
    entities_exposed: Set[str] = field(default_factory=set)
    entities_believing: Set[str] = field(default_factory=set)
    
    # Variants (mutations)
    variants: Dict[str, RumorVariant] = field(default_factory=dict)
    dominant_variant: Optional[str] = None
    
    # Timing
    created_tick: int = 0
    last_spread_tick: int = 0
    peak_tick: Optional[int] = None
    
    # Metadata
    tags: List[str] = field(default_factory=list)
    importance: float = 0.5
    
    _rumor_counter = 0
    
    @classmethod
    def create(cls, content: str, source_id: str, tick: int = 0) -> "Rumor":
        """Create a new rumor."""
        cls._rumor_counter += 1
        return cls(
            rumor_id=f"rumor_{cls._rumor_counter}",
            content=content,
            source_id=source_id,
            created_tick=tick,
            last_spread_tick=tick,
        )
    
    def expose_to(self, entity_id: str) -> bool:
        """
        Expose an entity to this rumor.
        
        Returns True if newly exposed.
        """
        if entity_id in self.entities_exposed:
            return False
        
        self.entities_exposed.add(entity_id)
        self.spread_count += 1
        return True
    
    def entity_believes(self, entity_id: str) -> bool:
        """Check if an entity believes this rumor."""
        return entity_id in self.entities_believing
    
    def add_believer(self, entity_id: str):
        """Record an entity believing this rumor."""
        self.entities_believing.add(entity_id)
    
    def remove_believer(self, entity_id: str):
        """Remove an entity's belief."""
        self.entities_believing.discard(entity_id)
    
    def mutate(self, new_content: str = None) -> RumorVariant:
        """
        Create a mutant variant of this rumor.
        
        Args:
            new_content: Optional specific content, or auto-generate
            
        Returns:
            The new variant
        """
        Rumor._rumor_counter += 1
        variant_id = f"variant_{Rumor._rumor_counter}"
        
        if new_content is None:
            # Auto-mutate content
            new_content = self._mutate_content(self.content)
        
        # Random truth modifier
        truth_modifier = random.uniform(-0.2, 0.2)
        
        variant = RumorVariant(
            variant_id=variant_id,
            content=new_content,
            truth_modifier=truth_modifier,
        )
        
        self.variants[variant_id] = variant
        return variant
    
    def _mutate_content(self, content: str) -> str:
        """Generate a mutated version of the content."""
        # Simple mutation strategies
        mutations = [
            lambda c: c.replace("did", "might have"),
            lambda c: c.replace("is", "could be"),
            lambda c: f"Apparently, {c.lower()}",
            lambda c: f"Rumor has it that {c.lower()}",
            lambda c: c + " Or so they say.",
            lambda c: c.replace("never", "supposedly never"),
        ]
        
        mutator = random.choice(mutations)
        return mutator(content)
    
    def set_truth(self, is_true: bool):
        """Set the actual truth of this rumor."""
        self.actual_truth = is_true
    
    def update_state(self, current_tick: int):
        """Update rumor state based on spread."""
        spread_rate = self.spread_count / max(1, current_tick - self.created_tick + 1)
        
        if self.state == RumorState.BORN and self.spread_count > 5:
            self.state = RumorState.SPREADING
        
        elif self.state == RumorState.SPREADING:
            if self.spread_count >= RUMOR_MAX_SPREAD * 0.5:
                self.state = RumorState.PEAK
                self.peak_tick = current_tick
        
        elif self.state == RumorState.PEAK:
            # Check if declining
            if self.peak_tick and current_tick - self.peak_tick > 50:
                self.state = RumorState.DYING
        
        elif self.state == RumorState.DYING:
            if self.spread_count > RUMOR_MAX_SPREAD or len(self.entities_believing) == 0:
                self.state = RumorState.DEAD
    
    def tick(self, current_tick: int = 0) -> Dict[str, Any]:
        """Process rumor tick."""
        self.update_state(current_tick)
        
        # Perceived truth drifts toward actual if known
        if self.actual_truth is not None:
            target = 1.0 if self.actual_truth else 0.0
            self.perceived_truth += (target - self.perceived_truth) * 0.01
        
        # Confidence increases with spread
        self.truth_confidence = min(1.0, self.spread_count / RUMOR_MAX_SPREAD)
        
        # Random mutation chance
        if random.random() < RUMOR_MUTATION_CHANCE:
            self.mutate()
        
        # Update dominant variant
        if self.variants:
            dominant = max(
                self.variants.values(),
                key=lambda v: v.spread_count
            )
            self.dominant_variant = dominant.variant_id
        
        return {
            "rumor_id": self.rumor_id,
            "state": self.state.name,
            "spread_count": self.spread_count,
            "believers": len(self.entities_believing),
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize rumor state."""
        return {
            "rumor_id": self.rumor_id,
            "content": self.content,
            "state": self.state.name,
            "spread_count": self.spread_count,
            "perceived_truth": self.perceived_truth,
            "actual_truth": self.actual_truth,
            "believer_count": len(self.entities_believing),
            "variant_count": len(self.variants),
        }


class RumorManager:
    """
    System that manages all rumors in the carnival.
    
    Handles creation, spread, mutation, and lifecycle.
    """
    
    def __init__(self):
        self.rumors: Dict[str, Rumor] = {}
        self.dead_rumors: List[Rumor] = []  # Archive for 0 = 3
        self._tick_count = 0
    
    def create_rumor(
        self,
        content: str,
        source_id: str,
        initial_truth: float = 0.5,
        tags: List[str] = None
    ) -> Rumor:
        """
        Create a new rumor.
        
        Args:
            content: The rumor content
            source_id: Entity that started the rumor
            initial_truth: Initial perceived truth (0-1)
            tags: Optional tags for categorization
            
        Returns:
            The created rumor
        """
        rumor = Rumor.create(content, source_id, self._tick_count)
        rumor.perceived_truth = initial_truth
        
        if tags:
            rumor.tags = tags
        
        self.rumors[rumor.rumor_id] = rumor
        return rumor
    
    def get_rumor(self, rumor_id: str) -> Optional[Rumor]:
        """Get a rumor by ID."""
        return self.rumors.get(rumor_id)
    
    def get_rumors_by_tag(self, tag: str) -> List[Rumor]:
        """Get all rumors with a specific tag."""
        return [r for r in self.rumors.values() if tag in r.tags]
    
    def get_rumors_about(self, entity_id: str) -> List[Rumor]:
        """Get all rumors mentioning an entity."""
        # Simple content search
        return [
            r for r in self.rumors.values()
            if entity_id in r.content or entity_id in r.entities_exposed
        ]
    
    def spread_rumor(
        self,
        rumor_id: str,
        from_entity: str,
        to_entities: List[str],
        credibility: float = 0.5
    ) -> Dict[str, Any]:
        """
        Spread a rumor from one entity to others.
        
        Args:
            rumor_id: The rumor to spread
            from_entity: Entity spreading the rumor
            to_entities: Entities receiving the rumor
            credibility: How credible the spreader is
            
        Returns:
            Spread results
        """
        rumor = self.rumors.get(rumor_id)
        
        if not rumor or rumor.state == RumorState.DEAD:
            return {"success": False, "reason": "rumor_not_found_or_dead"}
        
        newly_exposed = 0
        new_believers = 0
        
        for entity_id in to_entities:
            if rumor.expose_to(entity_id):
                newly_exposed += 1
                
                # Belief check
                belief_chance = credibility * rumor.perceived_truth
                if random.random() < belief_chance:
                    rumor.add_believer(entity_id)
                    new_believers += 1
        
        rumor.last_spread_tick = self._tick_count
        
        return {
            "success": True,
            "rumor_id": rumor_id,
            "newly_exposed": newly_exposed,
            "new_believers": new_believers,
            "total_exposed": len(rumor.entities_exposed),
            "total_believers": len(rumor.entities_believing),
        }
    
    def prove_rumor(self, rumor_id: str, is_true: bool) -> Dict[str, Any]:
        """
        Prove a rumor true or false.
        
        This affects perceived truth dramatically.
        """
        rumor = self.rumors.get(rumor_id)
        
        if not rumor:
            return {"success": False, "reason": "rumor_not_found"}
        
        rumor.set_truth(is_true)
        
        # Dramatic shift in perceived truth
        rumor.perceived_truth = 1.0 if is_true else 0.0
        rumor.truth_confidence = 1.0
        
        return {
            "success": True,
            "rumor_id": rumor_id,
            "proven_true": is_true,
            "believers_were_right": (
                (is_true and rumor.perceived_truth > 0.5) or
                (not is_true and rumor.perceived_truth < 0.5)
            ),
        }
    
    def get_active_rumors(self) -> List[Rumor]:
        """Get all non-dead rumors."""
        return [
            r for r in self.rumors.values()
            if r.state != RumorState.DEAD
        ]
    
    def get_most_spread_rumors(self, count: int = 5) -> List[Rumor]:
        """Get the most widespread rumors."""
        active = self.get_active_rumors()
        return sorted(active, key=lambda r: r.spread_count, reverse=True)[:count]
    
    def tick(self) -> Dict[str, Any]:
        """
        Process all rumors for one tick.
        
        Returns summary of processing.
        """
        self._tick_count += 1
        
        died_count = 0
        tick_results = []
        
        for rumor_id, rumor in list(self.rumors.items()):
            result = rumor.tick(self._tick_count)
            tick_results.append(result)
            
            if rumor.state == RumorState.DEAD:
                self.dead_rumors.append(rumor)
                del self.rumors[rumor_id]
                died_count += 1
        
        return {
            "tick": self._tick_count,
            "active_rumors": len(self.rumors),
            "dead_rumors_total": len(self.dead_rumors),
            "died_this_tick": died_count,
        }
    
    def resurrect_rumor(self, rumor_id: str) -> Optional[Rumor]:
        """
        Resurrect a dead rumor (0 = 3 invariant).
        
        Returns the resurrected rumor or None.
        """
        for rumor in self.dead_rumors:
            if rumor.rumor_id == rumor_id:
                rumor.state = RumorState.DYING  # Start in dying state
                self.rumors[rumor_id] = rumor
                self.dead_rumors.remove(rumor)
                return rumor
        return None
    
    def get_rumor_network(self) -> Dict[str, List[str]]:
        """
        Get the network of rumor spread.
        
        Returns dict mapping rumor_id to list of exposed entity IDs.
        """
        return {
            rumor.rumor_id: list(rumor.entities_exposed)
            for rumor in self.rumors.values()
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_count": len(self.rumors),
            "dead_count": len(self.dead_rumors),
            "rumors": [r.serialize() for r in self.rumors.values()],
        }

"""
Juggalo Party System
====================
The gathering mechanics of the carnival.

Juggalo Parties are escalating events with levels 1-5.
Each level increases intensity and effects.

Party Levels:
1. GATHERING - Small gathering, low energy
2. FAYGO_SHOWER - Faygo spray intensifies
3. MOSH_PIT - Physical chaos begins
4. CARNIVAL_CHAOS - Full carnival involvement
5. FULL_WHIPPIN - Maximum chaos, everything goes

Parties can be started, joined, left, and escalated.

Design: Parties are physics - they are real energy gatherings.
"""

from typing import Dict, Any, List, Optional, Set
from dataclasses import dataclass, field
from enum import Enum, auto
import random

from ..constants import (
    PARTY_LEVELS,
    PARTY_MAX_DURATION,
    PARTY_COOLDOWN,
    PHI,
)


class PartyLevel(Enum):
    """Juggalo party intensity levels."""
    GATHERING = 1
    FAYGO_SHOWER = 2
    MOSH_PIT = 3
    CARNIVAL_CHAOS = 4
    FULL_WHIPPIN = 5


class PartyState(Enum):
    """States a party can be in."""
    FORMING = auto()
    ACTIVE = auto()
    PEAK = auto()
    WINDING_DOWN = auto()
    ENDED = auto()


@dataclass
class PartyParticipant:
    """A participant in a party."""
    entity_id: str
    join_tick: int = 0
    energy_contributed: float = 0.0
    faygo_consumed: float = 0.0
    mosh_count: int = 0
    level_when_joined: PartyLevel = PartyLevel.GATHERING


@dataclass
class Party:
    """
    An active Juggalo Party.
    
    Parties have levels, participants, and effects.
    """
    party_id: str
    host_id: str
    location_x: float = 0.0
    location_y: float = 0.0
    
    level: PartyLevel = PartyLevel.GATHERING
    state: PartyState = PartyState.FORMING
    
    participants: Dict[str, PartyParticipant] = field(default_factory=dict)
    
    energy_total: float = 0.0
    faygo_total: float = 0.0
    
    start_tick: int = 0
    duration: int = 0
    peak_tick: Optional[int] = None
    
    # Effects
    effects_active: Dict[str, float] = field(default_factory=dict)
    
    _party_counter = 0
    
    @classmethod
    def create(
        cls,
        host_id: str,
        x: float = 0.0,
        y: float = 0.0,
        tick: int = 0
    ) -> "Party":
        """Create a new party."""
        cls._party_counter += 1
        return cls(
            party_id=f"party_{cls._party_counter}",
            host_id=host_id,
            location_x=x,
            location_y=y,
            start_tick=tick,
        )
    
    @property
    def participant_count(self) -> int:
        """Current number of participants."""
        return len(self.participants)
    
    @property
    def is_active(self) -> bool:
        """Check if party is still active."""
        return self.state not in (PartyState.ENDED,)
    
    @property
    def can_escalate(self) -> bool:
        """Check if party can escalate to next level."""
        return (
            self.state == PartyState.ACTIVE and
            self.level.value < 5 and
            self.energy_total >= self._get_escalation_threshold()
        )
    
    def _get_escalation_threshold(self) -> float:
        """Get energy needed to escalate."""
        thresholds = {
            PartyLevel.GATHERING: 50,
            PartyLevel.FAYGO_SHOWER: 150,
            PartyLevel.MOSH_PIT: 400,
            PartyLevel.CARNIVAL_CHAOS: 1000,
            PartyLevel.FULL_WHIPPIN: float('inf'),
        }
        return thresholds.get(self.level, float('inf'))
    
    def join(self, entity_id: str, tick: int = 0) -> Dict[str, Any]:
        """
        Add a participant to the party.
        
        Returns join result.
        """
        if entity_id in self.participants:
            return {"success": False, "reason": "already_joined"}
        
        if self.state == PartyState.ENDED:
            return {"success": False, "reason": "party_ended"}
        
        participant = PartyParticipant(
            entity_id=entity_id,
            join_tick=tick,
            level_when_joined=self.level,
        )
        
        self.participants[entity_id] = participant
        
        # Energy boost from new joiner
        self.energy_total += 10
        
        if self.state == PartyState.FORMING and self.participant_count >= 3:
            self.state = PartyState.ACTIVE
        
        return {
            "success": True,
            "party_id": self.party_id,
            "level": self.level.name,
            "participant_count": self.participant_count,
        }
    
    def leave(self, entity_id: str) -> Dict[str, Any]:
        """Remove a participant from the party."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants.pop(entity_id)
        
        # Check if party should end
        if self.participant_count < 2 and self.state == PartyState.ACTIVE:
            self.state = PartyState.WINDING_DOWN
        
        return {
            "success": True,
            "party_id": self.party_id,
            "energy_contributed": participant.energy_contributed,
            "duration": self.duration,
        }
    
    def contribute_energy(self, entity_id: str, amount: float) -> Dict[str, Any]:
        """
        Contribute energy to the party.
        
        Energy is the fuel that drives party escalation.
        """
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants[entity_id]
        participant.energy_contributed += amount
        self.energy_total += amount
        
        # Check for auto-escalation
        if self.can_escalate:
            return self.escalate()
        
        return {
            "success": True,
            "energy_total": self.energy_total,
            "can_escalate": self.can_escalate,
        }
    
    def consume_faygo(self, entity_id: str, amount: float) -> Dict[str, Any]:
        """Record Faygo consumption at the party."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        participant = self.participants[entity_id]
        participant.faygo_consumed += amount
        self.faygo_total += amount
        
        # Faygo boosts energy
        self.energy_total += amount * 2
        
        return {
            "success": True,
            "faygo_total": self.faygo_total,
        }
    
    def escalate(self) -> Dict[str, Any]:
        """
        Escalate party to next level.
        
        Returns escalation result.
        """
        if not self.can_escalate:
            return {"success": False, "reason": "cannot_escalate"}
        
        old_level = self.level
        
        # Move to next level
        if self.level == PartyLevel.GATHERING:
            self.level = PartyLevel.FAYGO_SHOWER
        elif self.level == PartyLevel.FAYGO_SHOWER:
            self.level = PartyLevel.MOSH_PIT
        elif self.level == PartyLevel.MOSH_PIT:
            self.level = PartyLevel.CARNIVAL_CHAOS
        elif self.level == PartyLevel.CARNIVAL_CHAOS:
            self.level = PartyLevel.FULL_WHIPPIN
        
        # Update effects for new level
        self._update_effects()
        
        return {
            "success": True,
            "old_level": old_level.name,
            "new_level": self.level.name,
            "effects": self.effects_active,
        }
    
    def _update_effects(self):
        """Update active effects based on level."""
        level_config = PARTY_LEVELS.get(self.level.value, {})
        
        self.effects_active = {
            "energy_drain": level_config.get("energy_cost", 1),
            "duration_mult": level_config.get("duration_mult", 1.0),
            "chaos_level": self.level.value / 5.0,
            "faygo_attraction": self.level.value * 2,
        }
        
        # Level-specific effects
        if self.level == PartyLevel.FAYGO_SHOWER:
            self.effects_active["faygo_rain"] = True
        
        if self.level == PartyLevel.MOSH_PIT:
            self.effects_active["physical_chaos"] = True
            self.effects_active["injury_chance"] = 0.05
        
        if self.level == PartyLevel.CARNIVAL_CHAOS:
            self.effects_active["midway_involved"] = True
            self.effects_active["ride_malfunction"] = 0.1
        
        if self.level == PartyLevel.FULL_WHIPPIN:
            self.effects_active["maximum_chaos"] = True
            self.effects_active["reality_bending"] = 0.3
    
    def mosh(self, entity_id: str) -> Dict[str, Any]:
        """Perform a mosh action."""
        if entity_id not in self.participants:
            return {"success": False, "reason": "not_in_party"}
        
        if self.level.value < PartyLevel.MOSH_PIT.value:
            return {"success": False, "reason": "level_too_low"}
        
        participant = self.participants[entity_id]
        participant.mosh_count += 1
        
        # Mosh adds energy and chaos
        self.energy_total += 5
        
        # Random effects
        effects = {}
        if random.random() < 0.1:
            effects["collision"] = True
        if random.random() < 0.05:
            effects["crowd_surf"] = True
        
        return {
            "success": True,
            "mosh_count": participant.mosh_count,
            "effects": effects,
        }
    
    def tick(self, current_tick: int = 0) -> Dict[str, Any]:
        """Process party tick."""
        self.duration = current_tick - self.start_tick
        
        # Energy decay
        self.energy_total *= 0.98
        
        # State transitions
        if self.state == PartyState.FORMING:
            if self.participant_count >= 3:
                self.state = PartyState.ACTIVE
            elif self.duration > 50:
                self.state = PartyState.ENDED
        
        elif self.state == PartyState.ACTIVE:
            # Check for peak
            if self.energy_total > 500 and self.peak_tick is None:
                self.state = PartyState.PEAK
                self.peak_tick = current_tick
            
            # Check for winding down
            if self.participant_count < 3 or self.duration > PARTY_MAX_DURATION:
                self.state = PartyState.WINDING_DOWN
        
        elif self.state == PartyState.PEAK:
            if self.energy_total < 200:
                self.state = PartyState.WINDING_DOWN
        
        elif self.state == PartyState.WINDING_DOWN:
            if self.participant_count <= 1 or self.energy_total < 10:
                self.state = PartyState.ENDED
        
        return {
            "party_id": self.party_id,
            "state": self.state.name,
            "level": self.level.name,
            "duration": self.duration,
            "energy": self.energy_total,
            "participants": self.participant_count,
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize party state."""
        return {
            "party_id": self.party_id,
            "host_id": self.host_id,
            "level": self.level.name,
            "state": self.state.name,
            "participant_count": self.participant_count,
            "energy_total": self.energy_total,
            "duration": self.duration,
        }


class JuggaloParty:
    """
    System that manages all Juggalo Parties.
    
    Handles creation, lookup, and global party effects.
    """
    
    def __init__(self):
        self.active_parties: Dict[str, Party] = {}
        self.ended_parties: List[Party] = []  # Archive for 0 = 3
        self.entity_to_party: Dict[str, str] = {}  # Which party each entity is in
        self._tick_count = 0
    
    def start_party(
        self,
        host_id: str,
        x: float = 0.0,
        y: float = 0.0
    ) -> Party:
        """
        Start a new party.
        
        Args:
            host_id: Entity hosting the party
            x, y: Party location
            
        Returns:
            The created party
        """
        # Check if host is already in a party
        if host_id in self.entity_to_party:
            existing_id = self.entity_to_party[host_id]
            return self.active_parties.get(existing_id)
        
        party = Party.create(host_id, x, y, self._tick_count)
        party.join(host_id, self._tick_count)
        
        self.active_parties[party.party_id] = party
        self.entity_to_party[host_id] = party.party_id
        
        return party
    
    def get_party(self, party_id: str) -> Optional[Party]:
        """Get a party by ID."""
        return self.active_parties.get(party_id)
    
    def get_party_for_entity(self, entity_id: str) -> Optional[Party]:
        """Get the party an entity is in."""
        party_id = self.entity_to_party.get(entity_id)
        if party_id:
            return self.active_parties.get(party_id)
        return None
    
    def join_party(self, party_id: str, entity_id: str) -> Dict[str, Any]:
        """Add an entity to a party."""
        # Leave existing party first
        if entity_id in self.entity_to_party:
            self.leave_party(entity_id)
        
        party = self.active_parties.get(party_id)
        if not party:
            return {"success": False, "reason": "party_not_found"}
        
        result = party.join(entity_id, self._tick_count)
        
        if result["success"]:
            self.entity_to_party[entity_id] = party_id
        
        return result
    
    def leave_party(self, entity_id: str) -> Dict[str, Any]:
        """Remove an entity from their party."""
        party_id = self.entity_to_party.get(entity_id)
        
        if not party_id:
            return {"success": False, "reason": "not_in_party"}
        
        party = self.active_parties.get(party_id)
        if not party:
            del self.entity_to_party[entity_id]
            return {"success": False, "reason": "party_not_found"}
        
        result = party.leave(entity_id)
        del self.entity_to_party[entity_id]
        
        # Archive if ended
        if party.state == PartyState.ENDED:
            self.ended_parties.append(party)
            del self.active_parties[party_id]
        
        return result
    
    def get_parties_at_location(self, x: float, y: float, radius: float = 10.0) -> List[Party]:
        """Get all parties within radius of a location."""
        import math
        
        return [
            p for p in self.active_parties.values()
            if math.sqrt((p.location_x - x)**2 + (p.location_y - y)**2) <= radius
        ]
    
    def get_global_chaos_level(self) -> float:
        """Get total chaos level from all active parties."""
        total = 0.0
        for party in self.active_parties.values():
            total += party.level.value * party.participant_count
        return min(1.0, total / 50)  # Normalize
    
    def tick(self) -> Dict[str, Any]:
        """Process all parties for one tick."""
        self._tick_count += 1
        
        results = []
        ended = []
        
        for party_id, party in self.active_parties.items():
            result = party.tick(self._tick_count)
            results.append(result)
            
            if party.state == PartyState.ENDED:
                ended.append(party_id)
        
        # Archive ended parties
        for party_id in ended:
            party = self.active_parties.pop(party_id)
            self.ended_parties.append(party)
            
            # Clean up entity mappings
            for entity_id in list(party.participants.keys()):
                if entity_id in self.entity_to_party:
                    if self.entity_to_party[entity_id] == party_id:
                        del self.entity_to_party[entity_id]
        
        return {
            "tick": self._tick_count,
            "active_parties": len(self.active_parties),
            "total_participants": len(self.entity_to_party),
            "global_chaos": self.get_global_chaos_level(),
            "ended_this_tick": len(ended),
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_count": len(self.active_parties),
            "ended_count": len(self.ended_parties),
            "parties": [p.serialize() for p in self.active_parties.values()],
        }

"""
Midway System
=============
The carnival game mechanics.

The Midway is where carnival games happen.
Run by Carnies (Monoxide and others), games offer prizes.

Games:
- RING_TOSS - Classic ring toss
- DUCK_POND - Lucky ducks
- BALLOON_DARTS - Pop for prizes
- WHEEL_OF_FATE - Spin to win (or lose)
- HIGH_STRIKER - Test your strength
- WHACK_A_NUGGET - Reaction game

Cover crops grow in the Midway, attracting pests and predators.

Design: The Midway is physics - games have real mechanics.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import math

from ..constants import (
    MIDWAY_GAME_TYPES,
    MIDWAY_TICKET_COST,
    MIDWAY_PRIZE_TIERS,
    PHI,
)


class MidwayState(Enum):
    """States of the Midway."""
    OPEN = auto()
    CLOSING = auto()
    CLOSED = auto()
    CHAOS = auto()  # During FULL_WHIPPIN parties


class GameResult(Enum):
    """Results of a game attempt."""
    WIN = auto()
    LOSS = auto()
    SCAM = auto()  # Carnie cheated
    MIRACLE = auto()  # Lucky win
    DISASTER = auto()  # Spectacular loss


@dataclass
class Prize:
    """A prize that can be won."""
    prize_id: str
    tier: str  # COMMON, RARE, LEGENDARY, MIRACLE
    name: str
    value: float
    effects: Dict[str, float] = field(default_factory=dict)
    rarity: float = 1.0  # 0-1, lower = rarer


@dataclass
class GameSession:
    """Active game session."""
    session_id: str
    game_type: str
    player_id: str
    carnie_id: str
    
    tickets_spent: int = 0
    attempts: int = 0
    wins: int = 0
    losses: int = 0
    
    prizes_won: List[Prize] = field(default_factory=list)
    
    start_tick: int = 0
    ended: bool = False


@dataclass
class MidwayBooth:
    """A game booth in the Midway."""
    booth_id: str
    game_type: str
    carnie_id: str
    x: float = 0.0
    y: float = 0.0
    
    active: bool = True
    session: Optional[GameSession] = None
    
    total_tickets: int = 0
    total_prizes: int = 0
    win_rate: float = 0.4  # Base win rate
    
    _booth_counter = 0
    
    @classmethod
    def create(cls, game_type: str, carnie_id: str) -> "MidwayBooth":
        """Create a new booth."""
        cls._booth_counter += 1
        return cls(
            booth_id=f"booth_{cls._booth_counter}",
            game_type=game_type,
            carnie_id=carnie_id,
        )


class MidwaySystem:
    """
    System that manages all Midway games.
    
    Handles booths, games, prizes, and the cover crop ecosystem.
    """
    
    def __init__(self):
        self.state = MidwayState.OPEN
        self.booths: Dict[str, MidwayBooth] = {}
        self.sessions: Dict[str, GameSession] = {}
        self.player_to_session: Dict[str, str] = {}
        
        # Prize pool
        self.prize_pool = self._init_prize_pool()
        
        # Cover crops (agriculture layer)
        self.cover_crops: Dict[str, Dict] = {}
        self.pest_population: float = 0.0
        self.predator_population: float = 0.0
        
        self._tick_count = 0
        self._session_counter = 0
        
        # Initialize default booths
        self._init_default_booths()
    
    def _init_default_booths(self):
        """Create default game booths."""
        default_carnies = {
            "RING_TOSS": "carnie_bozo",
            "DUCK_POND": "carnie_lucky",
            "BALLOON_DARTS": "carnie_pop",
            "WHEEL_OF_FATE": "carnie_monoxide",
            "HIGH_STRIKER": "carnie_strong",
            "WHACK_A_NUGGET": "carnie_speedy",
        }
        
        for game_type in MIDWAY_GAME_TYPES:
            carnie_id = default_carnies.get(game_type, f"carnie_{game_type.lower()}")
            booth = MidwayBooth.create(game_type, carnie_id)
            self.booths[booth.booth_id] = booth
    
    def _init_prize_pool(self) -> Dict[str, List[Prize]]:
        """Initialize the prize pool."""
        return {
            "COMMON": [
                Prize("prize_sticker", "COMMON", "Carnival Sticker", 1, {"happiness": 0.1}),
                Prize("prize_plastic_ring", "COMMON", "Plastic Ring", 2, {"happiness": 0.15}),
                Prize("prize_small_plush", "COMMON", "Small Plush", 5, {"happiness": 0.2}),
            ],
            "RARE": [
                Prize("prize_giant_plush", "RARE", "Giant Plush", 20, {"happiness": 0.5}),
                Prize("prize_gold_ticket", "RARE", "Gold Ticket", 25, {"luck": 0.1}),
                Prize("prize_carnival_hat", "RARE", "Carnival Hat", 15, {"charisma": 0.1}),
            ],
            "LEGENDARY": [
                Prize("prize_diamond_ring", "LEGENDARY", "Diamond Ring", 100, {"wealth": 1.0}),
                Prize("prize_mystery_box", "LEGENDARY", "Mystery Box", 50, {"luck": 0.3}),
                Prize("prize_vip_pass", "LEGENDARY", "VIP Pass", 75, {"access": 1.0}),
            ],
            "MIRACLE": [
                Prize("prize_wish", "MIRACLE", "One Wish", 1000, {"miracle": 1.0}),
                Prize("prize_freedom", "MIRACLE", "True Freedom", 999, {"freedom": 1.0}),
            ],
        }
    
    def get_booths_by_game(self, game_type: str) -> List[MidwayBooth]:
        """Get all booths of a game type."""
        return [b for b in self.booths.values() if b.game_type == game_type and b.active]
    
    def start_game(
        self,
        player_id: str,
        game_type: str,
        carnie_id: str = None
    ) -> Dict[str, Any]:
        """
        Start a game session.
        
        Args:
            player_id: Player entity
            game_type: Type of game to play
            carnie_id: Optional specific carnie
            
        Returns:
            Session data
        """
        if self.state == MidwayState.CLOSED:
            return {"success": False, "reason": "midway_closed"}
        
        # Find booth
        booths = self.get_booths_by_game(game_type)
        
        if carnie_id:
            booths = [b for b in booths if b.carnie_id == carnie_id]
        
        if not booths:
            return {"success": False, "reason": "no_booth_available"}
        
        booth = booths[0]
        
        # Check if player already in session
        if player_id in self.player_to_session:
            return {"success": False, "reason": "already_playing"}
        
        # Create session
        self._session_counter += 1
        session = GameSession(
            session_id=f"session_{self._session_counter}",
            game_type=game_type,
            player_id=player_id,
            carnie_id=booth.carnie_id,
            start_tick=self._tick_count,
        )
        
        self.sessions[session.session_id] = session
        self.player_to_session[player_id] = session.session_id
        booth.session = session
        
        return {
            "success": True,
            "session_id": session.session_id,
            "game_type": game_type,
            "carnie_id": booth.carnie_id,
            "ticket_cost": MIDWAY_TICKET_COST,
        }
    
    def play_round(
        self,
        player_id: str,
        skill: float = 0.5,
        luck: float = 0.5
    ) -> Dict[str, Any]:
        """
        Play a round of the current game.
        
        Args:
            player_id: Player entity
            skill: Player skill level (0-1)
            luck: Player luck factor (0-1)
            
        Returns:
            Round result
        """
        session_id = self.player_to_session.get(player_id)
        
        if not session_id:
            return {"success": False, "reason": "no_active_session"}
        
        session = self.sessions.get(session_id)
        
        if not session or session.ended:
            return {"success": False, "reason": "session_not_found"}
        
        # Pay ticket
        session.tickets_spent += MIDWAY_TICKET_COST
        
        # Find booth
        booth = None
        for b in self.booths.values():
            if b.session and b.session.session_id == session_id:
                booth = b
                break
        
        if not booth:
            return {"success": False, "reason": "booth_not_found"}
        
        # Calculate win chance
        base_win_rate = booth.win_rate
        skill_bonus = (skill - 0.5) * 0.3  # -0.15 to +0.15
        luck_bonus = (luck - 0.5) * 0.2   # -0.1 to +0.1
        
        # Golden ratio serendipity
        serendipity = 0.0
        if random.random() < (PHI - 1):  # ~38% chance
            serendipity = random.uniform(-0.1, 0.2)
        
        win_chance = base_win_rate + skill_bonus + luck_bonus + serendipity
        win_chance = max(0.05, min(0.95, win_chance))
        
        # Roll
        roll = random.random()
        
        # Determine result
        if roll < win_chance * 0.1:  # Miracle win
            result = GameResult.MIRACLE
            won = True
        elif roll < win_chance:
            result = GameResult.WIN
            won = True
        elif roll > (1 - win_chance * 0.05):  # Disaster
            result = GameResult.DISASTER
            won = False
        elif roll > (1 - win_chance * 0.2):  # Scam detected
            result = GameResult.SCAM
            won = False
        else:
            result = GameResult.LOSS
            won = False
        
        session.attempts += 1
        
        prize = None
        if won:
            session.wins += 1
            prize = self._award_prize(session, result == GameResult.MIRACLE)
        
        else:
            session.losses += 1
        
        # Update booth stats
        booth.total_tickets += MIDWAY_TICKET_COST
        if prize:
            booth.total_prizes += 1
        
        return {
            "success": True,
            "result": result.name,
            "won": won,
            "prize": prize.name if prize else None,
            "prize_tier": prize.tier if prize else None,
            "session_stats": {
                "attempts": session.attempts,
                "wins": session.wins,
                "losses": session.losses,
                "tickets_spent": session.tickets_spent,
            },
        }
    
    def _award_prize(self, session: GameSession, miracle: bool = False) -> Optional[Prize]:
        """Award a prize based on result."""
        # Determine tier
        if miracle:
            tier_roll = random.random()
            if tier_roll < 0.1:
                tier = "MIRACLE"
            elif tier_roll < 0.4:
                tier = "LEGENDARY"
            else:
                tier = "RARE"
        else:
            tier_roll = random.random()
            if tier_roll < 0.5:
                tier = "COMMON"
            elif tier_roll < 0.85:
                tier = "RARE"
            else:
                tier = "LEGENDARY"
        
        # Get prize from pool
        pool = self.prize_pool.get(tier, [])
        
        if not pool:
            pool = self.prize_pool.get("COMMON", [])
        
        if pool:
            prize = random.choice(pool)
            session.prizes_won.append(prize)
            return prize
        
        return None
    
    def end_game(self, player_id: str) -> Dict[str, Any]:
        """End current game session."""
        session_id = self.player_to_session.get(player_id)
        
        if not session_id:
            return {"success": False, "reason": "no_active_session"}
        
        session = self.sessions.get(session_id)
        
        if session:
            session.ended = True
        
        # Clear booth session
        for booth in self.booths.values():
            if booth.session and booth.session.session_id == session_id:
                booth.session = None
                break
        
        # Remove from active
        del self.player_to_session[player_id]
        
        return {
            "success": True,
            "session_id": session_id,
            "summary": {
                "attempts": session.attempts if session else 0,
                "wins": session.wins if session else 0,
                "losses": session.losses if session else 0,
                "tickets_spent": session.tickets_spent if session else 0,
                "prizes_won": [p.name for p in session.prizes_won] if session else [],
            } if session else {},
        }
    
    def plant_cover_crop(
        self,
        crop_type: str,
        x: float,
        y: float,
        area: float = 10.0
    ) -> Dict[str, Any]:
        """
        Plant cover crops in the Midway.
        
        Cover crops attract pests, which attract predators.
        """
        crop_id = f"crop_{len(self.cover_crops)}"
        
        self.cover_crops[crop_id] = {
            "type": crop_type,
            "x": x,
            "y": y,
            "area": area,
            "health": 1.0,
            "yield": 0.0,
            "planted_tick": self._tick_count,
        }
        
        # Cover crops attract pests
        self.pest_population += area * 0.1
        
        return {
            "success": True,
            "crop_id": crop_id,
            "pest_attraction": area * 0.1,
        }
    
    def tick(self) -> Dict[str, Any]:
        """Process Midway tick."""
        self._tick_count += 1
        
        # Process cover crops
        for crop_id, crop in list(self.cover_crops.items()):
            # Grow
            crop["yield"] = min(1.0, crop["yield"] + 0.01)
            
            # Health decay from pests
            pest_damage = self.pest_population * 0.001
            crop["health"] = max(0, crop["health"] - pest_damage)
            
            # Dead crops are removed
            if crop["health"] <= 0:
                del self.cover_crops[crop_id]
        
        # Pest population dynamics
        # Pests grow with cover crops, reduced by predators
        pest_growth = len(self.cover_crops) * 0.01
        pest_reduction = self.predator_population * 0.1
        
        self.pest_population = max(0, self.pest_population + pest_growth - pest_reduction)
        
        # Predator population follows pests
        if self.pest_population > 5:
            self.predator_population = min(20, self.predator_population + 0.01)
        else:
            self.predator_population = max(0, self.predator_population - 0.01)
        
        # Check Midway state
        active_sessions = len(self.sessions) - sum(1 for s in self.sessions.values() if s.ended)
        
        return {
            "tick": self._tick_count,
            "state": self.state.name,
            "active_sessions": active_sessions,
            "cover_crops": len(self.cover_crops),
            "pest_population": round(self.pest_population, 2),
            "predator_population": round(self.predator_population, 2),
        }
    
    def set_state(self, new_state: MidwayState):
        """Set Midway state."""
        self.state = new_state
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "state": self.state.name,
            "tick_count": self._tick_count,
            "booth_count": len(self.booths),
            "active_sessions": len([s for s in self.sessions.values() if not s.ended]),
            "cover_crops": len(self.cover_crops),
            "pest_population": self.pest_population,
            "predator_population": self.predator_population,
        }

"""
Yellow Bus System
=================
The pest energy distribution network.

The Yellow Bus is a mobile ecosystem distributor that:
1. Collects pest energy from hot spots
2. Transports it across the carnival
3. Distributes it where needed
4. Scatters excess as heat

The bus follows routes, stopping at key locations.
It's the circulatory system of the carnival ecology.

Design: The Yellow Bus is physics - energy distribution is real.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import math
import random

from ..constants import (
    YELLOW_BUS_CAPACITY,
    YELLOW_BUS_ROUTE_LENGTH,
    YELLOW_BUS_STOP_DURATION,
    HEAT_MAX,
    HEAT_DECAY_RATE,
    HEAT_TRANSFER_RATE,
    PHI,
)


class BusState(Enum):
    """States of the Yellow Bus."""
    TRAVELING = auto()
    STOPPED = auto()
    LOADING = auto()
    UNLOADING = auto()
    SCATTERING = auto()  # Emergency heat release


@dataclass
class BusStop:
    """A stop on the Yellow Bus route."""
    stop_id: str
    x: float
    y: float
    name: str = ""
    
    pest_energy_waiting: float = 0.0
    heat_level: float = 0.0
    
    loading_rate: float = 1.0
    unloading_rate: float = 1.0


@dataclass
class HeatParticle:
    """A particle of scattered heat."""
    x: float
    y: float
    energy: float
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    
    def tick(self) -> bool:
        """Update particle. Returns True if still alive."""
        self.x += self.velocity_x
        self.y += self.velocity_y
        
        # Heat dissipates
        self.energy *= HEAT_DECAY_RATE
        
        # Random drift
        self.velocity_x += random.uniform(-0.1, 0.1)
        self.velocity_y += random.uniform(-0.1, 0.1)
        
        # Damping
        self.velocity_x *= 0.95
        self.velocity_y *= 0.95
        
        return self.energy > 0.1


class YellowBusSystem:
    """
    System that manages the Yellow Bus pest energy distribution.
    
    The bus travels the carnival, collecting and distributing energy.
    """
    
    def __init__(self):
        self.state = BusState.TRAVELING
        
        # Bus position and route
        self.x = 0.0
        self.y = 0.0
        self.target_x = 0.0
        self.target_y = 0.0
        self.speed = 1.0
        
        # Energy cargo
        self.pest_energy = 0.0
        self.heat_cargo = 0.0
        
        # Route management
        self.stops: Dict[str, BusStop] = {}
        self.route: List[str] = []  # Ordered stop IDs
        self.current_stop_index = 0
        self.stop_timer = 0
        
        # Scattered heat particles
        self.heat_particles: List[HeatParticle] = []
        
        # Stats
        self.total_energy_collected = 0.0
        self.total_energy_delivered = 0.0
        self.total_heat_scattered = 0.0
        
        self._tick_count = 0
        self._stop_counter = 0
        
        # Initialize default route
        self._init_default_route()
    
    def _init_default_route(self):
        """Create default bus route through the carnival."""
        default_stops = [
            ("midway_entrance", 0, 0, "Midway Entrance"),
            ("faygo_stand", 20, 5, "Faygo Stand"),
            ("mosh_pit", 40, 0, "Mosh Pit Arena"),
            ("carnie_row", 60, 10, "Carnie Row"),
            ("high_striker", 80, 5, "High Striker"),
            ("wheel_of_fate", 100, 0, "Wheel of Fate"),
            ("exit_gate", 120, 0, "Exit Gate"),
        ]
        
        for stop_id, x, y, name in default_stops:
            self.add_stop(stop_id, x, y, name)
        
        # Set route order
        self.route = [s[0] for s in default_stops]
        
        # Start at first stop
        if self.route:
            first_stop = self.stops[self.route[0]]
            self.x = first_stop.x
            self.y = first_stop.y
    
    def add_stop(
        self,
        stop_id: str,
        x: float,
        y: float,
        name: str = ""
    ) -> BusStop:
        """Add a stop to the route."""
        stop = BusStop(
            stop_id=stop_id,
            x=x,
            y=y,
            name=name,
        )
        self.stops[stop_id] = stop
        return stop
    
    def add_energy_to_stop(
        self,
        stop_id: str,
        pest_energy: float = 0.0,
        heat: float = 0.0
    ) -> Dict[str, Any]:
        """
        Add pest energy to a stop for collection.
        
        This is called by other systems when pests are scattered.
        """
        stop = self.stops.get(stop_id)
        
        if not stop:
            return {"success": False, "reason": "stop_not_found"}
        
        stop.pest_energy_waiting += pest_energy
        stop.heat_level = min(HEAT_MAX, stop.heat_level + heat)
        
        return {
            "success": True,
            "stop_id": stop_id,
            "pest_energy_waiting": stop.pest_energy_waiting,
            "heat_level": stop.heat_level,
        }
    
    @property
    def current_stop(self) -> Optional[BusStop]:
        """Get the current stop."""
        if self.route and self.current_stop_index < len(self.route):
            return self.stops.get(self.route[self.current_stop_index])
        return None
    
    @property
    def next_stop(self) -> Optional[BusStop]:
        """Get the next stop on route."""
        if self.route:
            next_index = (self.current_stop_index + 1) % len(self.route)
            return self.stops.get(self.route[next_index])
        return None
    
    @property
    def cargo_level(self) -> float:
        """Get cargo as percentage of capacity."""
        return self.pest_energy / YELLOW_BUS_CAPACITY
    
    def move_toward_target(self):
        """Move bus toward target position."""
        dx = self.target_x - self.x
        dy = self.target_y - self.y
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < self.speed:
            # Arrived
            self.x = self.target_x
            self.y = self.target_y
            return True
        
        # Move toward target
        self.x += (dx / dist) * self.speed
        self.y += (dy / dist) * self.speed
        return False
    
    def load_at_stop(self, stop: BusStop) -> float:
        """Load pest energy from a stop."""
        available_space = YELLOW_BUS_CAPACITY - self.pest_energy
        load_amount = min(
            stop.pest_energy_waiting,
            available_space,
            stop.loading_rate
        )
        
        self.pest_energy += load_amount
        stop.pest_energy_waiting -= load_amount
        self.total_energy_collected += load_amount
        
        # Also absorb some heat
        heat_absorbed = min(stop.heat_level * HEAT_TRANSFER_RATE, load_amount * 0.5)
        self.heat_cargo += heat_absorbed
        stop.heat_level -= heat_absorbed
        
        return load_amount
    
    def unload_at_stop(self, stop: BusStop, amount: float = None) -> float:
        """Unload pest energy at a stop."""
        amount = amount or self.pest_energy * stop.unloading_rate
        amount = min(amount, self.pest_energy)
        
        self.pest_energy -= amount
        stop.pest_energy_waiting += amount
        self.total_energy_delivered += amount
        
        return amount
    
    def scatter_heat(self, amount: float = None) -> List[HeatParticle]:
        """
        Scatter heat as particles.
        
        Emergency release when too much heat accumulated.
        """
        amount = amount or self.heat_cargo
        
        particles = []
        particle_count = int(amount / 5) + 1
        
        for _ in range(particle_count):
            angle = random.uniform(0, 2 * math.pi)
            speed = random.uniform(0.5, 2.0)
            
            particle = HeatParticle(
                x=self.x,
                y=self.y,
                energy=amount / particle_count,
                velocity_x=math.cos(angle) * speed,
                velocity_y=math.sin(angle) * speed,
            )
            particles.append(particle)
        
        self.heat_particles.extend(particles)
        self.heat_cargo = max(0, self.heat_cargo - amount)
        self.total_heat_scattered += amount
        
        return particles
    
    def tick(self) -> Dict[str, Any]:
        """
        Process one tick of Yellow Bus operation.
        
        Returns summary of bus state.
        """
        self._tick_count += 1
        
        # Update heat particles
        self.heat_particles = [p for p in self.heat_particles if p.tick()]
        
        # State machine
        if self.state == BusState.TRAVELING:
            if self.current_stop:
                self.target_x = self.current_stop.x
                self.target_y = self.current_stop.y
                
                if self.move_toward_target():
                    self.state = BusState.STOPPED
                    self.stop_timer = YELLOW_BUS_STOP_DURATION
        
        elif self.state == BusState.STOPPED:
            self.stop_timer -= 1
            
            if self.stop_timer <= 0:
                # Time to load/unload
                self.state = BusState.LOADING
        
        elif self.state == BusState.LOADING:
            if self.current_stop:
                loaded = self.load_at_stop(self.current_stop)
                
                if loaded < 0.1:  # Nothing more to load
                    # Check if we need to scatter heat
                    if self.heat_cargo > HEAT_MAX * 0.8:
                        self.state = BusState.SCATTERING
                    else:
                        self.state = BusState.UNLOADING
        
        elif self.state == BusState.UNLOADING:
            if self.current_stop and self.next_stop:
                # Unload based on next stop's needs
                unload_amount = self.pest_energy * 0.3
                self.unload_at_stop(self.current_stop, unload_amount)
            
            # Move to next stop
            self.current_stop_index = (self.current_stop_index + 1) % len(self.route)
            self.state = BusState.TRAVELING
        
        elif self.state == BusState.SCATTERING:
            self.scatter_heat(self.heat_cargo * 0.5)
            
            if self.heat_cargo < HEAT_MAX * 0.3:
                self.state = BusState.UNLOADING
        
        # Heat cargo decay
        self.heat_cargo *= (1 - HEAT_DECAY_RATE * 0.1)
        
        return {
            "tick": self._tick_count,
            "state": self.state.name,
            "position": (round(self.x, 2), round(self.y, 2)),
            "pest_energy": round(self.pest_energy, 2),
            "heat_cargo": round(self.heat_cargo, 2),
            "cargo_level": round(self.cargo_level, 2),
            "current_stop": self.current_stop.name if self.current_stop else None,
            "heat_particles": len(self.heat_particles),
        }
    
    def get_heat_at_position(self, x: float, y: float, radius: float = 10.0) -> float:
        """Get total heat from particles at a position."""
        total = 0.0
        for particle in self.heat_particles:
            dist = math.sqrt((particle.x - x)**2 + (particle.y - y)**2)
            if dist <= radius:
                total += particle.energy * (1 - dist / radius)
        return total
    
    def force_scatter(self, amount: float = None) -> Dict[str, Any]:
        """Force immediate heat scatter."""
        particles = self.scatter_heat(amount)
        return {
            "success": True,
            "particles_created": len(particles),
            "remaining_heat": self.heat_cargo,
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "state": self.state.name,
            "position": (self.x, self.y),
            "pest_energy": self.pest_energy,
            "heat_cargo": self.heat_cargo,
            "total_collected": self.total_energy_collected,
            "total_delivered": self.total_energy_delivered,
            "total_scattered": self.total_heat_scattered,
            "stops": len(self.stops),
            "particle_count": len(self.heat_particles),
        }

"""
Diamond Rain System
===================
The cooling cycle of the carnival.

Diamond Rain is the mechanism that cools the carnival:
1. Heat builds up from activities
2. Moisture evaporates from the heat
3. Vapor rises and crystallizes in the upper atmosphere
4. Crystals fall as "diamond rain"
5. Diamonds cool and nourish the ground

This is the rain cycle, but with carnival physics.

Design: Diamond Rain is physics - it's real thermodynamics.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import math
import random

from ..constants import (
    DIAMOND_RAIN_THRESHOLD,
    DIAMOND_COOLING_FACTOR,
    DIAMOND_NOURISHMENT,
    HEAT_MAX,
    PHI,
)
from ..enums import EcologicalPhase, ThermalLayer


class CrystalState(Enum):
    """States of a crystal in the rain cycle."""
    VAPOR = auto()       # Rising moisture
    CONDENSING = auto()  # Forming crystal
    FALLING = auto()     # Diamond rain
    LANDED = auto()      # On the ground


@dataclass
class Crystal:
    """
    A crystal in the diamond rain cycle.
    
    Crystals form from evaporated moisture and fall as cooling rain.
    """
    crystal_id: str
    x: float
    y: float
    z: float  # Height (atmosphere)
    
    energy: float = 1.0
    state: CrystalState = CrystalState.VAPOR
    size: float = 1.0
    
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    velocity_z: float = 0.0
    
    cooling_power: float = 1.0
    nourishment: float = 1.0
    
    _crystal_counter = 0
    
    @classmethod
    def create_vapor(cls, x: float, y: float, energy: float = 1.0) -> "Crystal":
        """Create a new vapor crystal."""
        cls._crystal_counter += 1
        return cls(
            crystal_id=f"crystal_{cls._crystal_counter}",
            x=x,
            y=y,
            z=0.0,  # Start at ground level
            energy=energy,
            state=CrystalState.VAPOR,
            velocity_z=random.uniform(0.5, 1.5),  # Rising
        )
    
    def tick(self) -> Dict[str, Any]:
        """Process crystal tick."""
        result = {"crystal_id": self.crystal_id, "state": self.state.name}
        
        if self.state == CrystalState.VAPOR:
            # Rise
            self.z += self.velocity_z
            self.velocity_z *= 0.98  # Slow down
            
            # Drift
            self.x += self.velocity_x
            self.y += self.velocity_y
            self.velocity_x += random.uniform(-0.05, 0.05)
            self.velocity_y += random.uniform(-0.05, 0.05)
            
            # Check for condensation
            if self.z > 50 and random.random() < 0.1:
                self.state = CrystalState.CONDENSING
                self.size = self.energy * random.uniform(0.5, 1.5)
        
        elif self.state == CrystalState.CONDENSING:
            # Grow
            self.size += self.energy * 0.1
            
            # Stop rising
            self.velocity_z = max(0, self.velocity_z - 0.1)
            
            # Check for falling
            if self.size > 2.0 or random.random() < 0.05:
                self.state = CrystalState.FALLING
                self.velocity_z = -random.uniform(1.0, 3.0)  # Falling
        
        elif self.state == CrystalState.FALLING:
            # Fall
            self.z += self.velocity_z
            self.velocity_z -= 0.1  # Accelerate
            
            # Drift while falling
            self.x += self.velocity_x * 0.5
            self.y += self.velocity_y * 0.5
            
            # Check for landing
            if self.z <= 0:
                self.z = 0
                self.state = CrystalState.LANDED
                result["landed"] = True
                result["position"] = (self.x, self.y)
                result["cooling"] = self.cooling_power * self.size
                result["nourishment"] = self.nourishment * self.size
        
        elif self.state == CrystalState.LANDED:
            # Dissolve
            self.energy *= 0.95
            self.size *= 0.95
            
            if self.energy < 0.1:
                result["expired"] = True
        
        return result
    
    def is_expired(self) -> bool:
        """Check if crystal should be removed."""
        return self.state == CrystalState.LANDED and self.energy < 0.1


@dataclass
class ThermalZone:
    """A zone with thermal properties."""
    zone_id: str
    x: float
    y: float
    radius: float
    
    heat: float = 0.0
    moisture: float = 50.0
    layer: ThermalLayer = ThermalLayer.SURFACE


class DiamondRainSystem:
    """
    System that manages the diamond rain cooling cycle.
    
    Monitors heat, triggers evaporation, and creates rain.
    """
    
    def __init__(self):
        self.current_phase = EcologicalPhase.BUILD
        self.crystals: Dict[str, Crystal] = {}
        self.thermal_zones: Dict[str, ThermalZone] = {}
        
        # Global thermal state
        self.global_heat = 0.0
        self.global_moisture = 50.0
        self.rain_intensity = 0.0
        
        # Stats
        self.total_vapor_created = 0
        self.total_rain_events = 0
        self.total_cooling_applied = 0
        self.total_nourishment_applied = 0
        
        self._tick_count = 0
        self._zone_counter = 0
    
    def add_heat(
        self,
        x: float,
        y: float,
        amount: float,
        source: str = ""
    ) -> Dict[str, Any]:
        """
        Add heat to a location.
        
        Triggers evaporation if enough heat.
        """
        # Update global heat
        self.global_heat = min(HEAT_MAX, self.global_heat + amount * 0.1)
        
        # Find or create thermal zone
        zone = self._get_or_create_zone(x, y)
        zone.heat = min(HEAT_MAX, zone.heat + amount)
        
        # Check for evaporation
        vapor_created = 0
        if zone.heat > DIAMOND_RAIN_THRESHOLD:
            vapor_created = self._trigger_evaporation(zone)
        
        return {
            "success": True,
            "heat_added": amount,
            "zone_heat": zone.heat,
            "vapor_created": vapor_created,
            "phase": self.current_phase.name,
        }
    
    def _get_or_create_zone(self, x: float, y: float) -> ThermalZone:
        """Get or create a thermal zone at position."""
        # Find existing zone
        for zone in self.thermal_zones.values():
            dist = math.sqrt((zone.x - x)**2 + (zone.y - y)**2)
            if dist <= zone.radius:
                return zone
        
        # Create new zone
        self._zone_counter += 1
        zone = ThermalZone(
            zone_id=f"zone_{self._zone_counter}",
            x=x,
            y=y,
            radius=20.0,
        )
        self.thermal_zones[zone.zone_id] = zone
        return zone
    
    def _trigger_evaporation(self, zone: ThermalZone) -> int:
        """
        Trigger evaporation from a hot zone.
        
        Creates vapor crystals that rise.
        """
        vapor_count = int(zone.heat / 10)
        vapor_count = min(vapor_count, 5)  # Cap per trigger
        
        for _ in range(vapor_count):
            # Random position within zone
            angle = random.uniform(0, 2 * math.pi)
            dist = random.uniform(0, zone.radius)
            x = zone.x + math.cos(angle) * dist
            y = zone.y + math.sin(angle) * dist
            
            crystal = Crystal.create_vapor(x, y, zone.heat / HEAT_MAX)
            self.crystals[crystal.crystal_id] = crystal
            self.total_vapor_created += 1
        
        # Reduce heat
        zone.heat *= 0.9
        zone.moisture *= 0.95
        
        return vapor_count
    
    def get_rain_at_position(self, x: float, y: float, radius: float = 5.0) -> List[Crystal]:
        """Get all falling/landed crystals at a position."""
        return [
            c for c in self.crystals.values()
            if c.state in (CrystalState.FALLING, CrystalState.LANDED)
            and math.sqrt((c.x - x)**2 + (c.y - y)**2) <= radius
        ]
    
    def get_cooling_at_position(self, x: float, y: float) -> float:
        """Get current cooling effect at a position."""
        cooling = 0.0
        
        for crystal in self.crystals.values():
            if crystal.state == CrystalState.LANDED:
                dist = math.sqrt((crystal.x - x)**2 + (crystal.y - y)**2)
                if dist < 10:
                    cooling += crystal.cooling_power * crystal.size * (1 - dist / 10)
        
        return cooling
    
    def _update_phase(self):
        """Update the ecological phase."""
        if self.global_heat > HEAT_MAX * 0.8:
            self.current_phase = EcologicalPhase.BUILD
        elif len([c for c in self.crystals.values() if c.state == CrystalState.VAPOR]) > 10:
            self.current_phase = EcologicalPhase.RISE
        elif len([c for c in self.crystals.values() if c.state in (CrystalState.CONDENSING, CrystalState.FALLING)]) > 5:
            self.current_phase = EcologicalPhase.CRYSTALLIZE
        elif len([c for c in self.crystals.values() if c.state == CrystalState.LANDED]) > 3:
            self.current_phase = EcologicalPhase.RAIN
        else:
            self.current_phase = EcologicalPhase.BUILD
    
    def tick(self) -> Dict[str, Any]:
        """
        Process diamond rain tick.
        
        Updates all crystals and applies effects.
        """
        self._tick_count += 1
        
        # Process crystals
        expired = []
        landed_this_tick = []
        
        for crystal_id, crystal in self.crystals.items():
            result = crystal.tick()
            
            if result.get("landed"):
                landed_this_tick.append(result)
                self.total_rain_events += 1
                
                # Apply cooling
                cooling = result.get("cooling", 0) * DIAMOND_COOLING_FACTOR
                self.global_heat = max(0, self.global_heat - cooling)
                self.total_cooling_applied += cooling
                
                # Apply nourishment
                nourishment = result.get("nourishment", 0) * DIAMOND_NOURISHMENT
                self.global_moisture = min(100, self.global_moisture + nourishment)
                self.total_nourishment_applied += nourishment
            
            if result.get("expired") or crystal.is_expired():
                expired.append(crystal_id)
        
        # Remove expired
        for crystal_id in expired:
            del self.crystals[crystal_id]
        
        # Calculate rain intensity
        falling_count = len([c for c in self.crystals.values() if c.state == CrystalState.FALLING])
        self.rain_intensity = min(1.0, falling_count / 10)
        
        # Update phase
        self._update_phase()
        
        # Natural heat decay
        self.global_heat *= 0.99
        
        # Natural moisture recovery
        self.global_moisture = min(100, self.global_moisture + 0.1)
        
        return {
            "tick": self._tick_count,
            "phase": self.current_phase.name,
            "global_heat": round(self.global_heat, 2),
            "global_moisture": round(self.global_moisture, 2),
            "rain_intensity": round(self.rain_intensity, 2),
            "active_crystals": len(self.crystals),
            "landed_this_tick": len(landed_this_tick),
            "crystals_by_state": {
                "vapor": len([c for c in self.crystals.values() if c.state == CrystalState.VAPOR]),
                "condensing": len([c for c in self.crystals.values() if c.state == CrystalState.CONDENSING]),
                "falling": len([c for c in self.crystals.values() if c.state == CrystalState.FALLING]),
                "landed": len([c for c in self.crystals.values() if c.state == CrystalState.LANDED]),
            },
        }
    
    def force_rain(self, x: float, y: float, intensity: float = 1.0) -> Dict[str, Any]:
        """
        Force diamond rain at a location.
        
        Used for special events or abilities.
        """
        crystal_count = int(intensity * 10)
        
        for _ in range(crystal_count):
            angle = random.uniform(0, 2 * math.pi)
            dist = random.uniform(0, 5)
            
            crystal = Crystal.create_vapor(
                x + math.cos(angle) * dist,
                y + math.sin(angle) * dist,
                intensity,
            )
            
            # Skip to falling state
            crystal.z = 50
            crystal.state = CrystalState.FALLING
            crystal.velocity_z = -random.uniform(2, 4)
            
            self.crystals[crystal.crystal_id] = crystal
        
        return {
            "success": True,
            "crystals_created": crystal_count,
            "position": (x, y),
        }
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "phase": self.current_phase.name,
            "global_heat": self.global_heat,
            "global_moisture": self.global_moisture,
            "rain_intensity": self.rain_intensity,
            "crystal_count": len(self.crystals),
            "zone_count": len(self.thermal_zones),
            "stats": {
                "total_vapor_created": self.total_vapor_created,
                "total_rain_events": self.total_rain_events,
                "total_cooling": self.total_cooling_applied,
                "total_nourishment": self.total_nourishment_applied,
            },
        }

"""
Thermodynamics System
=====================
The master thermal controller.

Thermodynamics ties together:
- Yellow Bus heat distribution
- Diamond Rain cooling
- Biome thermal layers
- Activity heat generation

This is the physics engine that makes heat "real" in the carnival.

Design: Thermodynamics is physics - heat flows, spreads, and dissipates.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum, auto
import math

from ..constants import (
    HEAT_MAX,
    HEAT_DECAY_RATE,
    HEAT_TRANSFER_RATE,
    BIOME_HEAT_BASE,
    BIOME_HEAT_VARIANCE,
    PHI,
)
from ..enums import ThermalLayer


@dataclass
class ThermalCell:
    """A cell in the thermal grid."""
    x: int
    y: int
    heat: float = BIOME_HEAT_BASE
    moisture: float = 50.0
    layer: ThermalLayer = ThermalLayer.SURFACE
    
    # Flow tracking
    heat_in: float = 0.0
    heat_out: float = 0.0


class ThermodynamicsSystem:
    """
    Master system for thermal physics.
    
    Manages a grid of thermal cells and heat flow.
    """
    
    def __init__(self, grid_size: int = 50):
        self.grid_size = grid_size
        self.grid: Dict[tuple, ThermalCell] = {}
        
        # Initialize grid
        self._init_grid()
        
        # Global state
        self.total_heat = 0.0
        self.total_moisture = 0.0
        self.average_heat = BIOME_HEAT_BASE
        self.average_moisture = 50.0
        
        # Heat sources
        self.heat_sources: Dict[str, Dict] = {}
        
        # Stats
        self.total_heat_generated = 0.0
        self.total_heat_dissipated = 0.0
        
        self._tick_count = 0
        self._source_counter = 0
    
    def _init_grid(self):
        """Initialize the thermal grid."""
        for x in range(self.grid_size):
            for y in range(self.grid_size):
                # Vary initial heat based on position
                base_heat = BIOME_HEAT_BASE + (x + y) * 0.1
                
                # Add variance
                import random
                heat = base_heat + random.uniform(
                    -BIOME_HEAT_VARIANCE,
                    BIOME_HEAT_VARIANCE
                )
                
                # Determine layer based on position
                center = self.grid_size // 2
                dist_from_center = math.sqrt((x - center)**2 + (y - center)**2)
                
                if dist_from_center < center * 0.3:
                    layer = ThermalLayer.CORE
                elif dist_from_center < center * 0.6:
                    layer = ThermalLayer.MANTLE
                else:
                    layer = ThermalLayer.SURFACE
                
                self.grid[(x, y)] = ThermalCell(
                    x=x, y=y,
                    heat=heat,
                    layer=layer,
                )
    
    def get_cell(self, x: float, y: float) -> Optional[ThermalCell]:
        """Get thermal cell at position."""
        grid_x = int(x) % self.grid_size
        grid_y = int(y) % self.grid_size
        return self.grid.get((grid_x, grid_y))
    
    def add_heat(
        self,
        x: float,
        y: float,
        amount: float,
        radius: float = 1.0,
        source_id: str = None
    ) -> Dict[str, Any]:
        """
        Add heat to a location.
        
        Args:
            x, y: Position
            amount: Heat amount
            radius: Spread radius
            source_id: Optional source tracking
            
        Returns:
            Heat addition result
        """
        cells_affected = 0
        total_added = 0.0
        
        for dx in range(-int(radius), int(radius) + 1):
            for dy in range(-int(radius), int(radius) + 1):
                dist = math.sqrt(dx*dx + dy*dy)
                if dist > radius:
                    continue
                
                cell = self.get_cell(x + dx, y + dy)
                if not cell:
                    continue
                
                # Heat decreases with distance
                heat_amount = amount * (1 - dist / (radius + 1))
                cell.heat = min(HEAT_MAX, cell.heat + heat_amount)
                cell.heat_in += heat_amount
                
                total_added += heat_amount
                cells_affected += 1
        
        self.total_heat_generated += total_added
        
        # Track source if provided
        if source_id:
            if source_id not in self.heat_sources:
                self.heat_sources[source_id] = {
                    "total_heat": 0,
                    "events": 0,
                }
            self.heat_sources[source_id]["total_heat"] += total_added
            self.heat_sources[source_id]["events"] += 1
        
        return {
            "success": True,
            "heat_added": total_added,
            "cells_affected": cells_affected,
            "source_id": source_id,
        }
    
    def remove_heat(
        self,
        x: float,
        y: float,
        amount: float,
        radius: float = 1.0
    ) -> Dict[str, Any]:
        """Remove heat from a location (cooling)."""
        cells_affected = 0
        total_removed = 0.0
        
        for dx in range(-int(radius), int(radius) + 1):
            for dy in range(-int(radius), int(radius) + 1):
                dist = math.sqrt(dx*dx + dy*dy)
                if dist > radius:
                    continue
                
                cell = self.get_cell(x + dx, y + dy)
                if not cell:
                    continue
                
                # Cooling decreases with distance
                cool_amount = amount * (1 - dist / (radius + 1))
                actual = min(cell.heat, cool_amount)
                cell.heat -= actual
                cell.heat_out += actual
                
                total_removed += actual
                cells_affected += 1
        
        self.total_heat_dissipated += total_removed
        
        return {
            "success": True,
            "heat_removed": total_removed,
            "cells_affected": cells_affected,
        }
    
    def get_heat_at(self, x: float, y: float) -> float:
        """Get heat level at a position."""
        cell = self.get_cell(x, y)
        return cell.heat if cell else BIOME_HEAT_BASE
    
    def get_moisture_at(self, x: float, y: float) -> float:
        """Get moisture level at a position."""
        cell = self.get_cell(x, y)
        return cell.moisture if cell else 50.0
    
    def get_layer_at(self, x: float, y: float) -> ThermalLayer:
        """Get thermal layer at a position."""
        cell = self.get_cell(x, y)
        return cell.layer if cell else ThermalLayer.SURFACE
    
    def transfer_heat(self):
        """Transfer heat between adjacent cells."""
        # Create heat delta map
        heat_deltas: Dict[tuple, float] = {}
        
        for (x, y), cell in self.grid.items():
            neighbors = [
                ((x-1) % self.grid_size, y),
                ((x+1) % self.grid_size, y),
                (x, (y-1) % self.grid_size),
                (x, (y+1) % self.grid_size),
            ]
            
            for nx, ny in neighbors:
                neighbor = self.grid.get((nx, ny))
                if not neighbor:
                    continue
                
                # Heat flows from hot to cold
                diff = cell.heat - neighbor.heat
                transfer = diff * HEAT_TRANSFER_RATE * 0.25
                
                if (x, y) not in heat_deltas:
                    heat_deltas[(x, y)] = 0.0
                if (nx, ny) not in heat_deltas:
                    heat_deltas[(nx, ny)] = 0.0
                
                heat_deltas[(x, y)] -= transfer
                heat_deltas[(nx, ny)] += transfer
        
        # Apply deltas
        for (x, y), delta in heat_deltas.items():
            cell = self.grid.get((x, y))
            if cell:
                cell.heat = max(0, min(HEAT_MAX, cell.heat + delta))
    
    def decay_heat(self):
        """Apply natural heat decay."""
        for cell in self.grid.values():
            cell.heat *= (1 - HEAT_DECAY_RATE * 0.1)
            cell.heat = max(BIOME_HEAT_BASE * 0.5, cell.heat)  # Minimum heat
    
    def _update_averages(self):
        """Update average heat and moisture."""
        if not self.grid:
            return
        
        self.total_heat = sum(c.heat for c in self.grid.values())
        self.total_moisture = sum(c.moisture for c in self.grid.values())
        self.average_heat = self.total_heat / len(self.grid)
        self.average_moisture = self.total_moisture / len(self.grid)
    
    def tick(self) -> Dict[str, Any]:
        """
        Process thermodynamics tick.
        
        Updates heat flow and averages.
        """
        self._tick_count += 1
        
        # Transfer heat between cells
        self.transfer_heat()
        
        # Apply decay
        self.decay_heat()
        
        # Update averages
        self._update_averages()
        
        # Layer-based heat adjustment
        for cell in self.grid.values():
            if cell.layer == ThermalLayer.CORE:
                # Core retains more heat
                cell.heat *= 1.01
            elif cell.layer == ThermalLayer.ATMOSPHERE:
                # Atmosphere loses heat faster
                cell.heat *= 0.99
        
        # Find hot spots
        hot_spots = [
            ((x, y), cell.heat)
            for (x, y), cell in self.grid.items()
            if cell.heat > HEAT_MAX * 0.7
        ]
        
        return {
            "tick": self._tick_count,
            "average_heat": round(self.average_heat, 2),
            "average_moisture": round(self.average_moisture, 2),
            "total_heat": round(self.total_heat, 2),
            "hot_spots": len(hot_spots),
            "sources_tracked": len(self.heat_sources),
            "stats": {
                "total_generated": round(self.total_heat_generated, 2),
                "total_dissipated": round(self.total_heat_dissipated, 2),
            },
        }
    
    def get_heat_map(self, resolution: int = 10) -> List[List[float]]:
        """
        Get a downsampled heat map.
        
        Useful for visualization.
        """
        step = self.grid_size // resolution
        heat_map = []
        
        for y in range(0, self.grid_size, step):
            row = []
            for x in range(0, self.grid_size, step):
                cell = self.grid.get((x, y))
                row.append(cell.heat if cell else 0)
            heat_map.append(row)
        
        return heat_map
    
    def register_heat_source(
        self,
        source_type: str,
        x: float,
        y: float,
        base_output: float
    ) -> str:
        """Register a persistent heat source."""
        self._source_counter += 1
        source_id = f"source_{self._source_counter}"
        
        self.heat_sources[source_id] = {
            "type": source_type,
            "x": x,
            "y": y,
            "base_output": base_output,
            "total_heat": 0,
            "events": 0,
        }
        
        return source_id
    
    def remove_heat_source(self, source_id: str) -> bool:
        """Remove a heat source."""
        if source_id in self.heat_sources:
            del self.heat_sources[source_id]
            return True
        return False
    
    def process_heat_sources(self):
        """Process all registered heat sources."""
        for source_id, source in self.heat_sources.items():
            if "x" in source and "base_output" in source:
                self.add_heat(
                    source["x"],
                    source["y"],
                    source["base_output"],
                    radius=2.0,
                    source_id=source_id,
                )
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "grid_size": self.grid_size,
            "average_heat": self.average_heat,
            "average_moisture": self.average_moisture,
            "total_heat": self.total_heat,
            "sources_count": len(self.heat_sources),
            "stats": {
                "total_generated": self.total_heat_generated,
                "total_dissipated": self.total_heat_dissipated,
            },
        }

"""
DLC Ecology
===========
The agricultural ecosystem of the Midway.

Cover crops attract pests, pests attract predators,
predators die and decay, decay nourishes the soil.

This is the circle of carnival life.
"""

from .cover_crops import CoverCropManager, CoverCropType
from .pests import PestManager, PestType
from .predators import PredatorManager, PredatorType
from .decay import DecaySystem

__all__ = [
    "CoverCropManager", "CoverCropType",
    "PestManager", "PestType",
    "PredatorManager", "PredatorType",
    "DecaySystem",
]

"""
Cover Crops System
==================
The foundation of the Midway ecosystem.

Cover crops are plants grown in the Midway that:
- Generate heat through decomposition
- Attract pests (energy source)
- Suppress some pest types
- Produce Faygo-boosting compounds

8 Types of Cover Crops:
1. CLOVER - Faygo boost
2. BUCKWHEAT - Pest suppression
3. RYE - Balanced
4. OATS - Fast growth
5. VETCH - Max Faygo boost
6. RADISH - Fast decay, heat generation
7. SUNN_HEMP - Strong pest suppression
8. SORGHUM - High heat, high Faygo

Design: Cover crops are physics - they grow, die, and feed the system.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import math

from ..constants import (
    COVER_CROP_TYPES,
    COVER_CROP_MAX_YIELD,
    COVER_CROP_DECAY_RATE,
    PHI,
)


class CoverCropType(Enum):
    """The 8 cover crop varieties."""
    CLOVER = auto()
    BUCKWHEAT = auto()
    RYE = auto()
    OATS = auto()
    VETCH = auto()
    RADISH = auto()
    SUNN_HEMP = auto()
    SORGHUM = auto()


class CropStage(Enum):
    """Growth stages of a cover crop."""
    SEED = auto()
    SPROUT = auto()
    GROWING = auto()
    MATURE = auto()
    FLOWERING = auto()
    SEEDING = auto()
    DYING = auto()
    DEAD = auto()


@dataclass
class CoverCropInstance:
    """
    A planted cover crop in the Midway.
    
    Crops grow through stages and eventually die,
    contributing to the ecosystem.
    """
    crop_id: str
    crop_type: CoverCropType
    x: float
    y: float
    area: float = 10.0
    
    stage: CropStage = CropStage.SEED
    health: float = 1.0
    yield_accumulated: float = 0.0
    
    growth_progress: float = 0.0
    pest_damage: float = 0.0
    
    planted_tick: int = 0
    stage_tick: int = 0
    
    # Type-specific properties
    faygo_boost: float = 1.0
    pest_suppression: float = 1.0
    heat_generation: float = 0.5
    growth_rate: float = 1.0
    
    _crop_counter = 0
    
    @classmethod
    def create(
        cls,
        crop_type: CoverCropType,
        x: float,
        y: float,
        area: float = 10.0,
        tick: int = 0
    ) -> "CoverCropInstance":
        """Create a new cover crop."""
        cls._crop_counter += 1
        
        # Get type properties
        type_props = COVER_CROP_TYPES.get(crop_type.name, {})
        
        return cls(
            crop_id=f"crop_{cls._crop_counter}",
            crop_type=crop_type,
            x=x,
            y=y,
            area=area,
            planted_tick=tick,
            stage_tick=tick,
            faygo_boost=type_props.get("faygo_boost", 1.0),
            pest_suppression=type_props.get("pest_suppression", 1.0),
            heat_generation=type_props.get("heat_generation", 0.5),
            growth_rate=type_props.get("growth_rate", 1.0),
        )
    
    def advance_stage(self, current_tick: int = 0):
        """Advance to next growth stage."""
        stage_order = [
            CropStage.SEED,
            CropStage.SPROUT,
            CropStage.GROWING,
            CropStage.MATURE,
            CropStage.FLOWERING,
            CropStage.SEEDING,
            CropStage.DYING,
            CropStage.DEAD,
        ]
        
        current_index = stage_order.index(self.stage)
        if current_index < len(stage_order) - 1:
            self.stage = stage_order[current_index + 1]
            self.stage_tick = current_tick
    
    def tick(self, current_tick: int = 0) -> Dict[str, Any]:
        """Process crop tick."""
        result = {
            "crop_id": self.crop_id,
            "stage": self.stage.name,
        }
        
        # Growth based on stage
        if self.stage in (CropStage.SEED, CropStage.SPROUT, CropStage.GROWING):
            self.growth_progress += 0.01 * self.growth_rate
            
            if self.growth_progress >= 1.0:
                self.growth_progress = 0.0
                self.advance_stage(current_tick)
        
        # Mature crops accumulate yield
        elif self.stage == CropStage.MATURE:
            self.yield_accumulated = min(
                COVER_CROP_MAX_YIELD,
                self.yield_accumulated + 0.5 * self.area
            )
            
            # Random advancement
            if random.random() < 0.02:
                self.advance_stage(current_tick)
        
        # Flowering and seeding
        elif self.stage in (CropStage.FLOWERING, CropStage.SEEDING):
            self.yield_accumulated = min(
                COVER_CROP_MAX_YIELD,
                self.yield_accumulated + 0.3 * self.area
            )
            
            if random.random() < 0.05:
                self.advance_stage(current_tick)
        
        # Dying
        elif self.stage == CropStage.DYING:
            self.health -= 0.05
            
            if self.health <= 0:
                self.advance_stage(current_tick)
                result["died"] = True
        
        # Dead
        elif self.stage == CropStage.DEAD:
            result["dead"] = True
        
        # Apply pest damage to health
        self.health = max(0, self.health - self.pest_damage * 0.01)
        self.pest_damage *= 0.9  # Decay
        
        result["health"] = round(self.health, 2)
        result["yield"] = round(self.yield_accumulated, 2)
        
        return result
    
    def apply_pest_damage(self, damage: float):
        """Apply pest damage to the crop."""
        # Pest suppression reduces damage
        effective_damage = damage * self.pest_suppression
        self.pest_damage += effective_damage
    
    def get_heat_output(self) -> float:
        """Get current heat generation."""
        base_heat = self.heat_generation * self.area * 0.1
        
        # Dying/dead crops generate more heat
        if self.stage == CropStage.DYING:
            base_heat *= 2.0
        elif self.stage == CropStage.DEAD:
            base_heat *= 1.5
        
        return base_heat
    
    def get_faygo_output(self) -> float:
        """Get Faygo boost from this crop."""
        if self.stage not in (CropStage.MATURE, CropStage.FLOWERING):
            return 0.0
        
        return self.faygo_boost * self.yield_accumulated * 0.1
    
    def is_expired(self) -> bool:
        """Check if crop should be removed."""
        return self.stage == CropStage.DEAD and self.health <= 0


class CoverCropManager:
    """
    System that manages all cover crops in the Midway.
    
    Handles planting, growth, and harvesting.
    """
    
    def __init__(self):
        self.crops: Dict[str, CoverCropInstance] = {}
        self.dead_crops: List[CoverCropInstance] = []  # Archive for 0 = 3
        
        # Stats
        self.total_planted = 0
        self.total_yield_harvested = 0.0
        self.total_heat_generated = 0.0
        self.total_faygo_produced = 0.0
        
        self._tick_count = 0
    
    def plant(
        self,
        crop_type: CoverCropType,
        x: float,
        y: float,
        area: float = 10.0
    ) -> CoverCropInstance:
        """
        Plant a cover crop.
        
        Args:
            crop_type: Type of crop
            x, y: Position
            area: Planting area
            
        Returns:
            The planted crop
        """
        crop = CoverCropInstance.create(
            crop_type=crop_type,
            x=x,
            y=y,
            area=area,
            tick=self._tick_count,
        )
        
        self.crops[crop.crop_id] = crop
        self.total_planted += 1
        
        return crop
    
    def get_crop(self, crop_id: str) -> Optional[CoverCropInstance]:
        """Get a crop by ID."""
        return self.crops.get(crop_id)
    
    def get_crops_at(
        self,
        x: float,
        y: float,
        radius: float = 10.0
    ) -> List[CoverCropInstance]:
        """Get all crops within radius of a position."""
        return [
            crop for crop in self.crops.values()
            if math.sqrt((crop.x - x)**2 + (crop.y - y)**2) <= radius
        ]
    
    def get_crops_by_type(self, crop_type: CoverCropType) -> List[CoverCropInstance]:
        """Get all crops of a specific type."""
        return [
            crop for crop in self.crops.values()
            if crop.crop_type == crop_type
        ]
    
    def get_crops_by_stage(self, stage: CropStage) -> List[CoverCropInstance]:
        """Get all crops in a specific stage."""
        return [
            crop for crop in self.crops.values()
            if crop.stage == stage
        ]
    
    def harvest(self, crop_id: str) -> Dict[str, Any]:
        """
        Harvest a mature crop.
        
        Returns yield and removes the crop.
        """
        crop = self.crops.get(crop_id)
        
        if not crop:
            return {"success": False, "reason": "not_found"}
        
        if crop.stage not in (CropStage.MATURE, CropStage.FLOWERING, CropStage.SEEDING):
            return {"success": False, "reason": "not_mature"}
        
        yield_amount = crop.yield_accumulated
        faygo_amount = crop.get_faygo_output()
        
        # Remove crop
        del self.crops[crop_id]
        crop.stage = CropStage.DEAD
        self.dead_crops.append(crop)
        
        # Update stats
        self.total_yield_harvested += yield_amount
        self.total_faygo_produced += faygo_amount
        
        return {
            "success": True,
            "crop_type": crop.crop_type.name,
            "yield": yield_amount,
            "faygo_boost": faygo_amount,
        }
    
    def apply_pests_to_area(
        self,
        x: float,
        y: float,
        pest_pressure: float,
        radius: float = 10.0
    ) -> int:
        """
        Apply pest pressure to crops in an area.
        
        Returns number of crops affected.
        """
        crops = self.get_crops_at(x, y, radius)
        
        for crop in crops:
            crop.apply_pest_damage(pest_pressure)
        
        return len(crops)
    
    def get_total_heat_output(self) -> float:
        """Get total heat being generated by all crops."""
        return sum(crop.get_heat_output() for crop in self.crops.values())
    
    def get_total_faygo_output(self) -> float:
        """Get total Faygo boost from all crops."""
        return sum(crop.get_faygo_output() for crop in self.crops.values())
    
    def tick(self) -> Dict[str, Any]:
        """
        Process all cover crops for one tick.
        
        Returns summary of processing.
        """
        self._tick_count += 1
        
        expired = []
        tick_results = []
        
        total_heat = 0.0
        total_faygo = 0.0
        
        for crop_id, crop in self.crops.items():
            result = crop.tick(self._tick_count)
            tick_results.append(result)
            
            # Track outputs
            total_heat += crop.get_heat_output()
            total_faygo += crop.get_faygo_output()
            
            if crop.is_expired():
                expired.append(crop_id)
        
        # Remove expired crops
        for crop_id in expired:
            crop = self.crops.pop(crop_id)
            self.dead_crops.append(crop)
        
        # Update stats
        self.total_heat_generated += total_heat
        self.total_faygo_produced += total_faygo
        
        # Count by stage
        stage_counts = {}
        for stage in CropStage:
            stage_counts[stage.name] = len(self.get_crops_by_stage(stage))
        
        return {
            "tick": self._tick_count,
            "active_crops": len(self.crops),
            "expired_this_tick": len(expired),
            "total_heat_output": round(total_heat, 2),
            "total_faygo_output": round(total_faygo, 2),
            "stage_counts": stage_counts,
            "stats": {
                "total_planted": self.total_planted,
                "total_harvested": self.total_yield_harvested,
                "total_heat": round(self.total_heat_generated, 2),
                "total_faygo": round(self.total_faygo_produced, 2),
            },
        }
    
    def get_crop_health_average(self) -> float:
        """Get average health of all crops."""
        if not self.crops:
            return 0.0
        return sum(c.health for c in self.crops.values()) / len(self.crops)
    
    def get_most_damaged_crops(self, count: int = 5) -> List[CoverCropInstance]:
        """Get crops with most pest damage."""
        return sorted(
            self.crops.values(),
            key=lambda c: c.pest_damage,
            reverse=True
        )[:count]
    
    def restore_dead_crop(self, crop_id: str) -> Optional[CoverCropInstance]:
        """
        Restore a dead crop (0 = 3 invariant).
        
        Returns the restored crop or None.
        """
        for i, crop in enumerate(self.dead_crops):
            if crop.crop_id == crop_id:
                crop.health = 0.5
                crop.stage = CropStage.DYING
                self.crops[crop_id] = crop
                self.dead_crops.pop(i)
                return crop
        return None
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_crops": len(self.crops),
            "dead_crops": len(self.dead_crops),
            "stats": {
                "planted": self.total_planted,
                "harvested": self.total_yield_harvested,
                "heat_generated": self.total_heat_generated,
                "faygo_produced": self.total_faygo_produced,
            },
        }

"""
Pests System
============
The hungry masses of the Midway.

Pests are attracted to cover crops and represent
the energy that flows through the ecosystem.

4 Types of Pests:
1. NIBBLER - Small, fast, scatters easily
2. CHOMPER - Big, slow, persistent
3. SWARM - Tiny, numerous, spreads fast
4. GORGON - Massive, rare, devastating

Pests carry "pest energy" that can be harvested by predators
or scattered by the Yellow Bus.

Design: Pests are physics - they are energy carriers.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import math

from ..constants import (
    PEST_TYPES,
    PEST_ENERGY_VALUE,
    PEST_SCATTER_HEAT,
    PHI,
)


class PestType(Enum):
    """The 4 pest archetypes."""
    NIBBLER = auto()
    CHOMPER = auto()
    SWARM = auto()
    GORGON = auto()


class PestState(Enum):
    """States a pest can be in."""
    SPAWNING = auto()
    FORAGING = auto()
    FEEDING = auto()
    FLEEING = auto()
    DYING = auto()
    DEAD = auto()


@dataclass
class PestParticle:
    """
    A single pest entity.
    
    Pests move toward food sources and can be scattered.
    """
    pest_id: str
    pest_type: PestType
    x: float
    y: float
    
    energy: float = 1.0
    hunger: float = 0.5
    state: PestState = PestState.SPAWNING
    
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    
    # Type-specific properties
    appetite: float = 0.5
    speed: float = 1.0
    scatter_rate: float = 0.8
    
    target_x: Optional[float] = None
    target_y: Optional[float] = None
    
    _pest_counter = 0
    
    @classmethod
    def create(
        cls,
        pest_type: PestType,
        x: float,
        y: float,
        energy: float = 1.0
    ) -> "PestParticle":
        """Create a new pest."""
        cls._pest_counter += 1
        
        # Get type properties
        type_props = PEST_TYPES.get(pest_type.name, {})
        
        return cls(
            pest_id=f"pest_{cls._pest_counter}",
            pest_type=pest_type,
            x=x,
            y=y,
            energy=energy,
            appetite=type_props.get("appetite", 0.5),
            speed=type_props.get("speed", 1.0),
            scatter_rate=type_props.get("scatter_rate", 0.8),
        )
    
    def move_toward_target(self, target_x: float, target_y: float):
        """Move toward a target position."""
        dx = target_x - self.x
        dy = target_y - self.y
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < self.speed:
            self.x = target_x
            self.y = target_y
            return True
        
        # Move toward target
        self.x += (dx / dist) * self.speed
        self.y += (dy / dist) * self.speed
        return False
    
    def scatter(self, intensity: float = 1.0) -> Tuple[float, float]:
        """
        Scatter the pest in a random direction.
        
        Returns new position.
        """
        angle = random.uniform(0, 2 * math.pi)
        distance = self.scatter_rate * intensity * 5
        
        self.velocity_x = math.cos(angle) * distance
        self.velocity_y = math.sin(angle) * distance
        self.state = PestState.FLEEING
        
        return (self.x + self.velocity_x, self.y + self.velocity_y)
    
    def feed(self, food_value: float) -> float:
        """
        Feed on a food source.
        
        Returns amount consumed.
        """
        consumed = min(food_value, self.appetite)
        self.hunger = max(0, self.hunger - consumed * 0.5)
        self.energy += consumed * 0.1
        return consumed
    
    def tick(self) -> Dict[str, Any]:
        """Process pest tick."""
        result = {
            "pest_id": self.pest_id,
            "state": self.state.name,
        }
        
        # State machine
        if self.state == PestState.SPAWNING:
            self.state = PestState.FORAGING
            result["spawned"] = True
        
        elif self.state == PestState.FORAGING:
            # Apply velocity
            self.x += self.velocity_x
            self.y += self.velocity_y
            
            # Damping
            self.velocity_x *= 0.9
            self.velocity_y *= 0.9
            
            # Random drift
            self.velocity_x += random.uniform(-0.2, 0.2)
            self.velocity_y += random.uniform(-0.2, 0.2)
            
            # Hunger grows
            self.hunger = min(1.0, self.hunger + 0.01)
        
        elif self.state == PestState.FEEDING:
            # Already feeding, handled by feed()
            pass
        
        elif self.state == PestState.FLEEING:
            # Apply velocity (fast!)
            self.x += self.velocity_x * 2
            self.y += self.velocity_y * 2
            
            # Damping
            self.velocity_x *= 0.85
            self.velocity_y *= 0.85
            
            # Check if calmed
            speed = math.sqrt(self.velocity_x**2 + self.velocity_y**2)
            if speed < 0.5:
                self.state = PestState.FORAGING
        
        elif self.state == PestState.DYING:
            self.energy -= 0.1
            if self.energy <= 0:
                self.state = PestState.DEAD
                result["died"] = True
        
        # Energy decay
        self.energy *= 0.999
        
        # Starvation
        if self.hunger >= 1.0 and self.state not in (PestState.DYING, PestState.DEAD):
            self.state = PestState.DYING
        
        result["energy"] = round(self.energy, 2)
        result["hunger"] = round(self.hunger, 2)
        result["position"] = (round(self.x, 2), round(self.y, 2))
        
        return result
    
    def is_expired(self) -> bool:
        """Check if pest should be removed."""
        return self.state == PestState.DEAD or self.energy <= 0.1
    
    def get_scatter_heat(self) -> float:
        """Get heat produced when this pest scatters."""
        return PEST_SCATTER_HEAT * self.energy


class PestManager:
    """
    System that manages all pests in the Midway.
    
    Handles spawning, movement, and interactions.
    """
    
    def __init__(self):
        self.pests: Dict[str, PestParticle] = {}
        self.dead_pests: List[PestParticle] = []  # Archive for 0 = 3
        
        # Population limits
        self.max_population = 100
        
        # Food sources (cover crops)
        self.food_sources: List[Tuple[float, float, float]] = []  # x, y, value
        
        # Stats
        self.total_spawned = 0
        self.total_scattered = 0
        self.total_consumed = 0
        self.total_energy_harvested = 0.0
        
        self._tick_count = 0
    
    def spawn(
        self,
        pest_type: PestType,
        x: float,
        y: float,
        energy: float = 1.0,
        count: int = 1
    ) -> List[PestParticle]:
        """
        Spawn pests at a location.
        
        Args:
            pest_type: Type of pest
            x, y: Spawn position
            energy: Initial energy
            count: Number to spawn
            
        Returns:
            List of spawned pests
        """
        # Check population limit
        available = self.max_population - len(self.pests)
        count = min(count, available)
        
        if count <= 0:
            return []
        
        spawned = []
        
        for _ in range(count):
            # Slight position variance
            px = x + random.uniform(-2, 2)
            py = y + random.uniform(-2, 2)
            
            pest = PestParticle.create(pest_type, px, py, energy)
            self.pests[pest.pest_id] = pest
            spawned.append(pest)
            self.total_spawned += 1
        
        return spawned
    
    def spawn_near_food(
        self,
        food_x: float,
        food_y: float,
        radius: float = 10.0
    ) -> List[PestParticle]:
        """
        Spawn pests near a food source.
        
        Type is random based on weights.
        """
        # Determine type
        type_weights = {
            PestType.NIBBLER: 0.4,
            PestType.CHOMPER: 0.25,
            PestType.SWARM: 0.25,
            PestType.GORGON: 0.1,
        }
        
        roll = random.random()
        cumulative = 0.0
        pest_type = PestType.NIBBLER
        
        for ptype, weight in type_weights.items():
            cumulative += weight
            if roll <= cumulative:
                pest_type = ptype
                break
        
        # Spawn position
        angle = random.uniform(0, 2 * math.pi)
        dist = random.uniform(0, radius)
        x = food_x + math.cos(angle) * dist
        y = food_y + math.sin(angle) * dist
        
        # Count varies by type
        if pest_type == PestType.SWARM:
            count = random.randint(3, 8)
        elif pest_type == PestType.GORGON:
            count = 1
        else:
            count = random.randint(1, 3)
        
        return self.spawn(pest_type, x, y, count=count)
    
    def get_pest(self, pest_id: str) -> Optional[PestParticle]:
        """Get a pest by ID."""
        return self.pests.get(pest_id)
    
    def get_pests_at(
        self,
        x: float,
        y: float,
        radius: float = 5.0
    ) -> List[PestParticle]:
        """Get all pests within radius of a position."""
        return [
            pest for pest in self.pests.values()
            if math.sqrt((pest.x - x)**2 + (pest.y - y)**2) <= radius
        ]
    
    def get_pests_by_type(self, pest_type: PestType) -> List[PestParticle]:
        """Get all pests of a specific type."""
        return [
            pest for pest in self.pests.values()
            if pest.pest_type == pest_type
        ]
    
    def register_food_source(self, x: float, y: float, value: float):
        """Register a food source for pests."""
        self.food_sources.append((x, y, value))
    
    def clear_food_sources(self):
        """Clear registered food sources."""
        self.food_sources.clear()
    
    def scatter_at(
        self,
        x: float,
        y: float,
        radius: float = 5.0,
        intensity: float = 1.0
    ) -> Dict[str, Any]:
        """
        Scatter pests at a location.
        
        Used by Yellow Bus and other systems.
        """
        pests = self.get_pests_at(x, y, radius)
        
        scattered_count = 0
        total_heat = 0.0
        
        for pest in pests:
            if random.random() < pest.scatter_rate * intensity:
                pest.scatter(intensity)
                scattered_count += 1
                total_heat += pest.get_scatter_heat()
                self.total_scattered += 1
        
        return {
            "success": True,
            "scattered_count": scattered_count,
            "heat_produced": round(total_heat, 2),
        }
    
    def harvest_energy_at(
        self,
        x: float,
        y: float,
        radius: float = 5.0,
        amount: float = 1.0
    ) -> Dict[str, Any]:
        """
        Harvest pest energy at a location.
        
        Used by Yellow Bus and predators.
        """
        pests = self.get_pests_at(x, y, radius)
        
        energy_harvested = 0.0
        pests_killed = []
        
        for pest in pests:
            harvest = min(pest.energy, amount)
            pest.energy -= harvest
            energy_harvested += harvest * PEST_ENERGY_VALUE
            
            if pest.energy <= 0.1:
                pest.state = PestState.DEAD
                pests_killed.append(pest.pest_id)
        
        # Remove dead
        for pest_id in pests_killed:
            pest = self.pests.pop(pest_id)
            self.dead_pests.append(pest)
        
        self.total_energy_harvested += energy_harvested
        
        return {
            "success": True,
            "energy_harvested": round(energy_harvested, 2),
            "pests_killed": len(pests_killed),
        }
    
    def tick(self) -> Dict[str, Any]:
        """
        Process all pests for one tick.
        
        Returns summary of processing.
        """
        self._tick_count += 1
        
        expired = []
        tick_results = []
        
        # Find nearest food for each pest
        for pest_id, pest in self.pests.items():
            result = pest.tick()
            tick_results.append(result)
            
            # Move toward food if foraging
            if pest.state == PestState.FORAGING and self.food_sources:
                # Find nearest food
                nearest = min(
                    self.food_sources,
                    key=lambda f: math.sqrt((f[0] - pest.x)**2 + (f[1] - pest.y)**2)
                )
                
                if pest.move_toward_target(nearest[0], nearest[1]):
                    pest.state = PestState.FEEDING
            
            # Check expiration
            if pest.is_expired():
                expired.append(pest_id)
        
        # Remove expired
        for pest_id in expired:
            pest = self.pests.pop(pest_id)
            self.dead_pests.append(pest)
        
        # Clear food sources for next tick
        self.clear_food_sources()
        
        # Count by type
        type_counts = {}
        for ptype in PestType:
            type_counts[ptype.name] = len(self.get_pests_by_type(ptype))
        
        return {
            "tick": self._tick_count,
            "active_pests": len(self.pests),
            "expired_this_tick": len(expired),
            "type_counts": type_counts,
            "stats": {
                "total_spawned": self.total_spawned,
                "total_scattered": self.total_scattered,
                "total_consumed": self.total_consumed,
                "total_harvested": round(self.total_energy_harvested, 2),
            },
        }
    
    def get_total_energy(self) -> float:
        """Get total energy in all pests."""
        return sum(p.energy for p in self.pests.values())
    
    def get_population_density_at(
        self,
        x: float,
        y: float,
        radius: float = 10.0
    ) -> float:
        """Get pest population density at a position."""
        pests = self.get_pests_at(x, y, radius)
        area = math.pi * radius * radius
        return len(pests) / area if area > 0 else 0
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_pests": len(self.pests),
            "dead_pests": len(self.dead_pests),
            "total_energy": round(self.get_total_energy(), 2),
            "stats": {
                "spawned": self.total_spawned,
                "scattered": self.total_scattered,
                "harvested": round(self.total_energy_harvested, 2),
            },
        }

"""
Predators System
================
Nature's cleanup crew.

Predators hunt pests and keep the population in check.
They're beneficial to the ecosystem.

4 Types of Predators:
1. LADYBUG - Hunts NIBBLER and SWARM
2. LACEWING - Hunts NIBBLER and CHOMPER
3. PRAYING_MANTIS - Hunts CHOMPER and SWARM
4. WASP - Hunts GORGON

Predators reproduce slowly but efficiently hunt pests.

Design: Predators are physics - they're real hunters.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import math

from ..constants import (
    PREDATOR_TYPES,
    PEST_ENERGY_VALUE,
    PHI,
)


class PredatorType(Enum):
    """The 4 beneficial predators."""
    LADYBUG = auto()
    LACEWING = auto()
    PRAYING_MANTIS = auto()
    WASP = auto()


class PredatorState(Enum):
    """States a predator can be in."""
    PATROLLING = auto()
    HUNTING = auto()
    FEEDING = auto()
    RESTING = auto()
    REPRODUCING = auto()
    DYING = auto()
    DEAD = auto()


@dataclass
class PredatorInstance:
    """
    A single predator entity.
    
    Predators hunt specific pest types and reproduce.
    """
    predator_id: str
    predator_type: PredatorType
    x: float
    y: float
    
    energy: float = 1.0
    hunger: float = 0.3
    state: PredatorState = PredatorState.PATROLLING
    
    velocity_x: float = 0.0
    velocity_y: float = 0.0
    
    # Type-specific properties
    prey_types: List[str] = field(default_factory=list)
    efficiency: float = 0.8
    reproduction_rate: float = 0.1
    
    kills: int = 0
    age: int = 0
    
    target_pest_id: Optional[str] = None
    
    _predator_counter = 0
    
    @classmethod
    def create(
        cls,
        predator_type: PredatorType,
        x: float,
        y: float,
        energy: float = 1.0
    ) -> "PredatorInstance":
        """Create a new predator."""
        cls._predator_counter += 1
        
        # Get type properties
        type_props = PREDATOR_TYPES.get(predator_type.name, {})
        
        return cls(
            predator_id=f"predator_{cls._predator_counter}",
            predator_type=predator_type,
            x=x,
            y=y,
            energy=energy,
            prey_types=type_props.get("prey", []),
            efficiency=type_props.get("efficiency", 0.8),
            reproduction_rate=type_props.get("reproduction_rate", 0.1),
        )
    
    def can_hunt(self, pest_type: str) -> bool:
        """Check if this predator can hunt a pest type."""
        return pest_type in self.prey_types
    
    def hunt(self, target_x: float, target_y: float) -> bool:
        """
        Move toward a target.
        
        Returns True if reached.
        """
        speed = 0.8  # Predators are steady
        
        dx = target_x - self.x
        dy = target_y - self.y
        dist = math.sqrt(dx*dx + dy*dy)
        
        if dist < speed:
            self.x = target_x
            self.y = target_y
            return True
        
        self.x += (dx / dist) * speed
        self.y += (dy / dist) * speed
        return False
    
    def feed(self, pest_energy: float) -> float:
        """
        Feed on a pest.
        
        Returns energy gained.
        """
        gained = pest_energy * self.efficiency * PEST_ENERGY_VALUE
        self.energy += gained
        self.hunger = max(0, self.hunger - 0.3)
        self.kills += 1
        return gained
    
    def can_reproduce(self) -> bool:
        """Check if predator can reproduce."""
        return (
            self.energy > 1.5 and
            self.state == PredatorState.RESTING and
            random.random() < self.reproduction_rate
        )
    
    def reproduce(self) -> Optional["PredatorInstance"]:
        """
        Create offspring.
        
        Returns new predator or None.
        """
        if not self.can_reproduce():
            return None
        
        # Cost of reproduction
        self.energy -= 0.5
        
        # Create offspring nearby
        offset_x = random.uniform(-3, 3)
        offset_y = random.uniform(-3, 3)
        
        offspring = PredatorInstance.create(
            self.predator_type,
            self.x + offset_x,
            self.y + offset_y,
            energy=0.5
        )
        
        return offspring
    
    def tick(self) -> Dict[str, Any]:
        """Process predator tick."""
        result = {
            "predator_id": self.predator_id,
            "state": self.state.name,
        }
        
        self.age += 1
        
        # Hunger grows
        self.hunger = min(1.0, self.hunger + 0.005)
        
        # Energy decay
        self.energy *= 0.999
        
        # State transitions
        if self.state == PredatorState.PATROLLING:
            # Random movement
            self.velocity_x += random.uniform(-0.1, 0.1)
            self.velocity_y += random.uniform(-0.1, 0.1)
            
            self.x += self.velocity_x * 0.5
            self.y += self.velocity_y * 0.5
            
            # Damping
            self.velocity_x *= 0.95
            self.velocity_y *= 0.95
        
        elif self.state == PredatorState.HUNTING:
            # Hunting handled by PredatorManager
            pass
        
        elif self.state == PredatorState.FEEDING:
            # Transition to resting after feeding
            if random.random() < 0.1:
                self.state = PredatorState.RESTING
        
        elif self.state == PredatorState.RESTING:
            # Recover energy
            self.energy = min(2.0, self.energy + 0.01)
            
            # Return to patrol
            if random.random() < 0.05:
                self.state = PredatorState.PATROLLING
        
        elif self.state == PredatorState.DYING:
            self.energy -= 0.1
            if self.energy <= 0:
                self.state = PredatorState.DEAD
                result["died"] = True
        
        # Starvation
        if self.hunger >= 1.0 and self.state not in (PredatorState.DYING, PredatorState.DEAD):
            if random.random() < 0.1:
                self.state = PredatorState.DYING
        
        # Old age
        if self.age > 500 and random.random() < 0.01:
            self.state = PredatorState.DYING
        
        result["energy"] = round(self.energy, 2)
        result["hunger"] = round(self.hunger, 2)
        result["kills"] = self.kills
        
        return result
    
    def is_expired(self) -> bool:
        """Check if predator should be removed."""
        return self.state == PredatorState.DEAD


class PredatorManager:
    """
    System that manages all predators in the Midway.
    
    Handles spawning, hunting, and reproduction.
    """
    
    def __init__(self):
        self.predators: Dict[str, PredatorInstance] = {}
        self.dead_predators: List[PredatorInstance] = []  # Archive for 0 = 3
        
        # Population limits
        self.max_population = 30
        
        # Stats
        self.total_spawned = 0
        self.total_kills = 0
        self.total_reproductions = 0
        
        self._tick_count = 0
    
    def spawn(
        self,
        predator_type: PredatorType,
        x: float,
        y: float,
        energy: float = 1.0
    ) -> Optional[PredatorInstance]:
        """
        Spawn a predator at a location.
        
        Returns the spawned predator or None if at capacity.
        """
        if len(self.predators) >= self.max_population:
            return None
        
        predator = PredatorInstance.create(predator_type, x, y, energy)
        self.predators[predator.predator_id] = predator
        self.total_spawned += 1
        
        return predator
    
    def spawn_for_pest_type(
        self,
        pest_type: str,
        x: float,
        y: float
    ) -> Optional[PredatorInstance]:
        """
        Spawn a predator that can hunt a specific pest type.
        """
        # Find predator types that can hunt this pest
        valid_types = []
        for ptype, props in PREDATOR_TYPES.items():
            if pest_type in props.get("prey", []):
                valid_types.append(PredatorType[ptype])
        
        if not valid_types:
            return None
        
        predator_type = random.choice(valid_types)
        return self.spawn(predator_type, x, y)
    
    def get_predator(self, predator_id: str) -> Optional[PredatorInstance]:
        """Get a predator by ID."""
        return self.predators.get(predator_id)
    
    def get_predators_at(
        self,
        x: float,
        y: float,
        radius: float = 10.0
    ) -> List[PredatorInstance]:
        """Get all predators within radius of a position."""
        return [
            pred for pred in self.predators.values()
            if math.sqrt((pred.x - x)**2 + (pred.y - y)**2) <= radius
        ]
    
    def get_predators_by_type(
        self,
        predator_type: PredatorType
    ) -> List[PredatorInstance]:
        """Get all predators of a specific type."""
        return [
            pred for pred in self.predators.values()
            if pred.predator_type == predator_type
        ]
    
    def process_hunting(self, pests: Dict) -> Dict[str, Any]:
        """
        Process hunting for all predators.
        
        Args:
            pests: Dict of pest_id -> PestParticle from PestManager
            
        Returns:
            Hunting results
        """
        hunting_results = []
        kills = []
        
        for predator in self.predators.values():
            if predator.state not in (PredatorState.PATROLLING, PredatorState.HUNTING):
                continue
            
            # Find nearby prey
            best_target = None
            best_dist = float('inf')
            
            for pest_id, pest in pests.items():
                if not predator.can_hunt(pest.pest_type.name):
                    continue
                
                dist = math.sqrt((pest.x - predator.x)**2 + (pest.y - predator.y)**2)
                
                if dist < best_dist and dist < 15:  # Hunting range
                    best_dist = dist
                    best_target = pest
            
            if best_target:
                predator.state = PredatorState.HUNTING
                predator.target_pest_id = best_target.pest_id
                
                # Move toward prey
                if predator.hunt(best_target.x, best_target.y):
                    # Caught prey!
                    gained = predator.feed(best_target.energy)
                    predator.state = PredatorState.FEEDING
                    
                    kills.append(best_target.pest_id)
                    hunting_results.append({
                        "predator_id": predator.predator_id,
                        "prey_id": best_target.pest_id,
                        "energy_gained": round(gained, 2),
                    })
                    
                    self.total_kills += 1
        
        return {
            "kills": kills,
            "results": hunting_results,
        }
    
    def process_reproduction(self) -> List[PredatorInstance]:
        """
        Process reproduction for all predators.
        
        Returns list of new offspring.
        """
        offspring = []
        
        for predator in self.predators.values():
            child = predator.reproduce()
            if child and len(self.predators) + len(offspring) < self.max_population:
                offspring.append(child)
                self.total_reproductions += 1
        
        # Add offspring
        for child in offspring:
            self.predators[child.predator_id] = child
        
        return offspring
    
    def tick(self, pest_manager=None) -> Dict[str, Any]:
        """
        Process all predators for one tick.
        
        Args:
            pest_manager: Optional PestManager for hunting
            
        Returns:
            Summary of processing
        """
        self._tick_count += 1
        
        expired = []
        tick_results = []
        
        for predator_id, predator in self.predators.items():
            result = predator.tick()
            tick_results.append(result)
            
            if predator.is_expired():
                expired.append(predator_id)
        
        # Remove expired
        for predator_id in expired:
            predator = self.predators.pop(predator_id)
            self.dead_predators.append(predator)
        
        # Process hunting if pest manager provided
        hunting_result = {}
        if pest_manager:
            hunting_result = self.process_hunting(pest_manager.pests)
            
            # Remove killed pests
            for pest_id in hunting_result.get("kills", []):
                if pest_id in pest_manager.pests:
                    pest = pest_manager.pests.pop(pest_id)
                    pest_manager.dead_pests.append(pest)
        
        # Process reproduction
        offspring = self.process_reproduction()
        
        # Count by type
        type_counts = {}
        for ptype in PredatorType:
            type_counts[ptype.name] = len(self.get_predators_by_type(ptype))
        
        return {
            "tick": self._tick_count,
            "active_predators": len(self.predators),
            "expired_this_tick": len(expired),
            "kills_this_tick": len(hunting_result.get("kills", [])),
            "births_this_tick": len(offspring),
            "type_counts": type_counts,
            "stats": {
                "total_spawned": self.total_spawned,
                "total_kills": self.total_kills,
                "total_reproductions": self.total_reproductions,
            },
        }
    
    def get_total_hunting_capacity(self) -> float:
        """Get total hunting capacity of all predators."""
        return sum(
            p.efficiency * p.energy for p in self.predators.values()
            if p.state in (PredatorState.PATROLLING, PredatorState.HUNTING)
        )
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_predators": len(self.predators),
            "dead_predators": len(self.dead_predators),
            "stats": {
                "spawned": self.total_spawned,
                "kills": self.total_kills,
                "reproductions": self.total_reproductions,
            },
        }

"""
Decay System
============
The great recycler.

Decay processes dead organic matter and returns
nutrients to the soil. It's the final stage of
the ecosystem cycle.

Decay produces:
- Heat (from decomposition)
- Nutrients (for cover crops)
- Pest attraction (scavengers)

Design: Decay is physics - matter doesn't disappear, it transforms.
"""

from typing import Dict, Any, List, Optional
from dataclasses import dataclass, field
from enum import Enum, auto
import random
import math

from ..constants import PHI


class DecayStage(Enum):
    """Stages of decay."""
    FRESH = auto()
    DECOMPOSING = auto()
    ADVANCED = auto()
    DRYING = auto()
    SOIL = auto()


@dataclass
class DecayPile:
    """
    A pile of decaying matter.
    
    Can contain dead crops, pests, predators, etc.
    """
    pile_id: str
    x: float
    y: float
    
    mass: float = 1.0
    stage: DecayStage = DecayStage.FRESH
    
    heat_output: float = 0.0
    nutrient_output: float = 0.0
    pest_attraction: float = 0.0
    
    age: int = 0
    
    # Contents tracking
    crops_count: int = 0
    pests_count: int = 0
    predators_count: int = 0
    
    _pile_counter = 0
    
    @classmethod
    def create(
        cls,
        x: float,
        y: float,
        initial_mass: float = 1.0
    ) -> "DecayPile":
        """Create a new decay pile."""
        cls._pile_counter += 1
        return cls(
            pile_id=f"pile_{cls._pile_counter}",
            x=x,
            y=y,
            mass=initial_mass,
        )
    
    def add_material(
        self,
        mass: float,
        material_type: str = "organic"
    ):
        """Add material to the pile."""
        self.mass += mass
        
        if material_type == "crop":
            self.crops_count += 1
        elif material_type == "pest":
            self.pests_count += 1
        elif material_type == "predator":
            self.predators_count += 1
    
    def advance_stage(self):
        """Advance to next decay stage."""
        stage_order = [
            DecayStage.FRESH,
            DecayStage.DECOMPOSING,
            DecayStage.ADVANCED,
            DecayStage.DRYING,
            DecayStage.SOIL,
        ]
        
        current_index = stage_order.index(self.stage)
        if current_index < len(stage_order) - 1:
            self.stage = stage_order[current_index + 1]
    
    def tick(self) -> Dict[str, Any]:
        """Process decay tick."""
        self.age += 1
        
        result = {
            "pile_id": self.pile_id,
            "stage": self.stage.name,
            "mass": round(self.mass, 2),
        }
        
        # Stage-specific processing
        if self.stage == DecayStage.FRESH:
            # Fresh matter produces little
            self.heat_output = self.mass * 0.1
            self.nutrient_output = 0
            self.pest_attraction = self.mass * 0.5
            
            # Advance quickly
            if self.age > 10:
                self.advance_stage()
        
        elif self.stage == DecayStage.DECOMPOSING:
            # Peak heat production
            self.heat_output = self.mass * 0.5
            self.nutrient_output = self.mass * 0.1
            self.pest_attraction = self.mass * 0.3
            
            # Mass decreases
            self.mass *= 0.98
            
            if self.age > 50 or self.mass < 0.5:
                self.advance_stage()
        
        elif self.stage == DecayStage.ADVANCED:
            # Good nutrient production
            self.heat_output = self.mass * 0.3
            self.nutrient_output = self.mass * 0.3
            self.pest_attraction = self.mass * 0.1
            
            self.mass *= 0.97
            
            if self.mass < 0.3:
                self.advance_stage()
        
        elif self.stage == DecayStage.DRYING:
            # Low output
            self.heat_output = self.mass * 0.1
            self.nutrient_output = self.mass * 0.2
            self.pest_attraction = 0
            
            self.mass *= 0.99
            
            if self.mass < 0.1:
                self.advance_stage()
        
        elif self.stage == DecayStage.SOIL:
            # Becomes soil
            self.heat_output = 0
            self.nutrient_output = self.mass * 0.5
            self.pest_attraction = 0
            
            result["became_soil"] = True
        
        result["heat_output"] = round(self.heat_output, 2)
        result["nutrient_output"] = round(self.nutrient_output, 2)
        
        return result
    
    def is_expired(self) -> bool:
        """Check if pile should be removed."""
        return self.stage == DecayStage.SOIL and self.mass < 0.05
    
    def harvest_nutrients(self, amount: float = None) -> float:
        """
        Harvest nutrients from the pile.
        
        Returns amount harvested.
        """
        amount = amount or self.nutrient_output
        actual = min(amount, self.mass)
        self.mass -= actual * 0.1
        return actual


class DecaySystem:
    """
    System that manages all decay in the Midway.
    
    Handles decay piles and nutrient cycling.
    """
    
    def __init__(self):
        self.piles: Dict[str, DecayPile] = {}
        self.soil_deposits: List[Dict] = []  # Archive for 0 = 3
        
        # Global nutrient pool
        self.available_nutrients = 100.0
        self.total_heat_produced = 0.0
        self.total_nutrients_cycled = 0.0
        
        self._tick_count = 0
    
    def create_pile(
        self,
        x: float,
        y: float,
        initial_mass: float = 1.0,
        material_type: str = "organic"
    ) -> DecayPile:
        """
        Create a new decay pile.
        
        Args:
            x, y: Position
            initial_mass: Starting mass
            material_type: Type of material
            
        Returns:
            The created pile
        """
        pile = DecayPile.create(x, y, initial_mass)
        pile.add_material(initial_mass, material_type)
        self.piles[pile.pile_id] = pile
        
        return pile
    
    def add_to_nearest_pile(
        self,
        x: float,
        y: float,
        mass: float,
        material_type: str = "organic",
        max_distance: float = 20.0
    ) -> Optional[DecayPile]:
        """
        Add material to nearest pile, or create new one.
        
        Returns the pile used.
        """
        # Find nearest pile
        nearest = None
        nearest_dist = float('inf')
        
        for pile in self.piles.values():
            if pile.stage == DecayStage.SOIL:
                continue
            
            dist = math.sqrt((pile.x - x)**2 + (pile.y - y)**2)
            if dist < nearest_dist:
                nearest_dist = dist
                nearest = pile
        
        if nearest and nearest_dist <= max_distance:
            nearest.add_material(mass, material_type)
            return nearest
        else:
            return self.create_pile(x, y, mass, material_type)
    
    def get_pile(self, pile_id: str) -> Optional[DecayPile]:
        """Get a pile by ID."""
        return self.piles.get(pile_id)
    
    def get_piles_at(
        self,
        x: float,
        y: float,
        radius: float = 10.0
    ) -> List[DecayPile]:
        """Get all piles within radius of a position."""
        return [
            pile for pile in self.piles.values()
            if math.sqrt((pile.x - x)**2 + (pile.y - y)**2) <= radius
        ]
    
    def get_total_heat_output(self) -> float:
        """Get total heat from all piles."""
        return sum(pile.heat_output for pile in self.piles.values())
    
    def get_total_nutrient_output(self) -> float:
        """Get total nutrients from all piles."""
        return sum(pile.nutrient_output for pile in self.piles.values())
    
    def get_total_pest_attraction(self) -> float:
        """Get total pest attraction from all piles."""
        return sum(pile.pest_attraction for pile in self.piles.values())
    
    def harvest_nutrients(
        self,
        x: float,
        y: float,
        amount: float,
        radius: float = 10.0
    ) -> float:
        """
        Harvest nutrients from piles at a location.
        
        Returns amount harvested.
        """
        piles = self.get_piles_at(x, y, radius)
        
        total_harvested = 0.0
        
        for pile in piles:
            harvested = pile.harvest_nutrients(amount - total_harvested)
            total_harvested += harvested
            
            if total_harvested >= amount:
                break
        
        self.available_nutrients += total_harvested
        self.total_nutrients_cycled += total_harvested
        
        return total_harvested
    
    def deposit_dead_crop(
        self,
        x: float,
        y: float,
        mass: float
    ) -> DecayPile:
        """Deposit a dead cover crop."""
        return self.add_to_nearest_pile(x, y, mass, "crop")
    
    def deposit_dead_pest(
        self,
        x: float,
        y: float,
        mass: float
    ) -> DecayPile:
        """Deposit a dead pest."""
        return self.add_to_nearest_pile(x, y, mass, "pest")
    
    def deposit_dead_predator(
        self,
        x: float,
        y: float,
        mass: float
    ) -> DecayPile:
        """Deposit a dead predator."""
        return self.add_to_nearest_pile(x, y, mass, "predator")
    
    def tick(self) -> Dict[str, Any]:
        """
        Process all decay for one tick.
        
        Returns summary of processing.
        """
        self._tick_count += 1
        
        expired = []
        tick_results = []
        
        total_heat = 0.0
        total_nutrients = 0.0
        became_soil = 0
        
        for pile_id, pile in self.piles.items():
            result = pile.tick()
            tick_results.append(result)
            
            total_heat += pile.heat_output
            total_nutrients += pile.nutrient_output
            
            if result.get("became_soil"):
                became_soil += 1
                self.soil_deposits.append({
                    "x": pile.x,
                    "y": pile.y,
                    "nutrients": pile.nutrient_output,
                    "tick": self._tick_count,
                })
            
            if pile.is_expired():
                expired.append(pile_id)
        
        # Remove expired
        for pile_id in expired:
            del self.piles[pile_id]
        
        # Update stats
        self.total_heat_produced += total_heat
        self.total_nutrients_cycled += total_nutrients
        self.available_nutrients += total_nutrients * 0.1  # Some goes to pool
        
        # Count by stage
        stage_counts = {}
        for stage in DecayStage:
            stage_counts[stage.name] = len([
                p for p in self.piles.values() if p.stage == stage
            ])
        
        return {
            "tick": self._tick_count,
            "active_piles": len(self.piles),
            "expired_this_tick": len(expired),
            "became_soil": became_soil,
            "total_heat": round(total_heat, 2),
            "total_nutrients": round(total_nutrients, 2),
            "available_nutrients": round(self.available_nutrients, 2),
            "stage_counts": stage_counts,
            "stats": {
                "total_heat_produced": round(self.total_heat_produced, 2),
                "total_nutrients_cycled": round(self.total_nutrients_cycled, 2),
            },
        }
    
    def get_nutrients_at(self, x: float, y: float) -> float:
        """Get nutrient level at a position."""
        piles = self.get_piles_at(x, y, 10.0)
        return sum(p.nutrient_output for p in piles)
    
    def get_heat_at(self, x: float, y: float) -> float:
        """Get heat level at a position."""
        piles = self.get_piles_at(x, y, 10.0)
        return sum(p.heat_output for p in piles)
    
    def serialize(self) -> Dict[str, Any]:
        """Serialize system state."""
        return {
            "tick_count": self._tick_count,
            "active_piles": len(self.piles),
            "soil_deposits": len(self.soil_deposits),
            "available_nutrients": round(self.available_nutrients, 2),
            "stats": {
                "heat_produced": round(self.total_heat_produced, 2),
                "nutrients_cycled": round(self.total_nutrients_cycled, 2),
            },
        }

"""
DLC Hooks
=========
Integration layer that connects DLC to base engine.

Hooks extend the base V3_carnival engine without modifying it.
This is the GameBoy cartridge connector.
"""

from .entity_hooks import register_entity_hooks
from .engine_hooks import register_engine_hooks
from .biome_hooks import register_biome_hooks

__all__ = [
    "register_entity_hooks",
    "register_engine_hooks",
    "register_biome_hooks",
]

"""
Entity Hooks
============
Extensions to the Entity class.

These hooks add DLC component support to entities
without modifying the base Entity class.

Hook Pattern:
1. Check if entity has the extension
2. Add extension methods/properties
3. Register for DLC systems
"""

from typing import Dict, Any, List, Optional, Callable, TYPE_CHECKING

from ..core.component import Component, ComponentHolder
from ..components.faygo import FaygoComponent, FaygoMode, FaygoFlavor
from ..components.madrox import MadroxComponent
from ..components.carnie import CarnieComponent
from ..components.danger_state import DangerStateComponent, DangerState
from ..components.loyalty import LoyaltyComponent, LoyaltyAction
from ..components.authority import AuthorityComponent, AuthorityLevel
from ..components.hidden_potential import HiddenPotentialComponent
from ..components.toxicity import ToxicityComponent, ToxicityType


def register_entity_hooks(engine) -> List[str]:
    """
    Register all entity-related hooks.
    
    This patches the Entity class to support DLC components.
    
    Args:
        engine: The V3_carnival GameEngine
        
    Returns:
        List of registered hook names
    """
    hooks_registered = []
    
    # Get Entity class from engine
    Entity = engine.Entity if hasattr(engine, 'Entity') else None
    
    if Entity is None:
        # Create a mock for standalone testing
        class Entity:
            """Base Entity class (hooked version)."""
            _entity_id_counter = 0
            
            def __init__(self, *args, **kwargs):
                Entity._entity_id_counter += 1
                self.entity_id = f"entity_{Entity._entity_id_counter}"
                self._components = {}
                self._tick = 0
        
        engine.Entity = Entity
    
    # Add ComponentHolder mixin
    Entity = _add_component_holder(Entity)
    hooks_registered.append("Entity.component_holder")
    
    # Add component accessor properties
    Entity = _add_component_properties(Entity)
    hooks_registered.append("Entity.component_properties")
    
    # Add DLC-specific methods
    Entity = _add_dlc_methods(Entity)
    hooks_registered.append("Entity.dlc_methods")
    
    # Store hooked class
    engine.Entity = Entity
    
    return hooks_registered


def _add_component_holder(Entity):
    """Add ComponentHolder mixin to Entity."""
    
    # Store original __init__
    _original_init = Entity.__init__ if hasattr(Entity, '__init__') else None
    
    def __init__(self, *args, **kwargs):
        # Call original init
        if _original_init:
            _original_init(self, *args, **kwargs)
        
        # Initialize component holder
        if not hasattr(self, '_components'):
            self._components: Dict[str, Component] = {}
        if not hasattr(self, '_component_history'):
            self._component_history: List[Dict] = []
    
    Entity.__init__ = __init__
    
    # Add component methods
    def add_component(self, component: Component) -> Component:
        """Add a component to this entity."""
        component_type = component.__class__.__name__
        
        # Archive existing (0 = 3)
        if component_type in self._components:
            old = self._components[component_type]
            self._component_history.append({
                "component": old,
                "action": "replaced",
                "tick": getattr(self, '_tick', 0),
            })
            old.deactivate()
        
        component.attach(self)
        self._components[component_type] = component
        return component
    
    def get_component(self, component_type: str) -> Optional[Component]:
        """Get a component by type name."""
        return self._components.get(component_type)
    
    def has_component(self, component_type: str) -> bool:
        """Check if entity has a component type."""
        return component_type in self._components
    
    def remove_component(self, component_type: str) -> Optional[Component]:
        """Remove a component (soft delete - archives it)."""
        if component_type not in self._components:
            return None
        
        component = self._components[component_type]
        
        self._component_history.append({
            "component": component,
            "action": "removed",
            "tick": getattr(self, '_tick', 0),
        })
        
        component.detach()
        del self._components[component_type]
        return component
    
    def get_all_components(self) -> Dict[str, Component]:
        """Get all components."""
        return self._components.copy()
    
    Entity.add_component = add_component
    Entity.get_component = get_component
    Entity.has_component = has_component
    Entity.remove_component = remove_component
    Entity.get_all_components = get_all_components
    
    return Entity


def _add_component_properties(Entity):
    """Add convenient component accessor properties."""
    
    @property
    def faygo(self) -> Optional[FaygoComponent]:
        """Get Faygo component."""
        return self.get_component("FaygoComponent")
    
    @property
    def madrox(self) -> Optional[MadroxComponent]:
        """Get Madrox component."""
        return self.get_component("MadroxComponent")
    
    @property
    def carnie(self) -> Optional[CarnieComponent]:
        """Get Carnie component."""
        return self.get_component("CarnieComponent")
    
    @property
    def danger_state(self) -> Optional[DangerStateComponent]:
        """Get DangerState component."""
        return self.get_component("DangerStateComponent")
    
    @property
    def loyalty(self) -> Optional[LoyaltyComponent]:
        """Get Loyalty component."""
        return self.get_component("LoyaltyComponent")
    
    @property
    def authority(self) -> Optional[AuthorityComponent]:
        """Get Authority component."""
        return self.get_component("AuthorityComponent")
    
    @property
    def hidden_potential(self) -> Optional[HiddenPotentialComponent]:
        """Get HiddenPotential component."""
        return self.get_component("HiddenPotentialComponent")
    
    @property
    def toxicity(self) -> Optional[ToxicityComponent]:
        """Get Toxicity component."""
        return self.get_component("ToxicityComponent")
    
    @property
    def is_in_danger(self) -> bool:
        """Check if entity is in any danger state."""
        ds = self.danger_state
        return ds.is_in_danger if ds else False
    
    @property
    def is_overthinking(self) -> bool:
        """Check if entity is overthinking."""
        mx = self.madrox
        return mx.is_overthinking if mx else False
    
    @property
    def anxiety_level(self) -> float:
        """Get entity's anxiety level."""
        mx = self.madrox
        return mx.anxiety_level if mx else 0.0
    
    """
Entity Hooks
============
Extensions to the Entity class.

These hooks add DLC component support to entities
without modifying the base Entity class.

Hook Pattern:
1. Check if entity has the extension
2. Add extension methods/properties
3. Register for DLC systems
"""

from typing import Dict, Any, List, Optional, Callable, TYPE_CHECKING

from ..core.component import Component, ComponentHolder
from ..components.faygo import FaygoComponent, FaygoMode, FaygoFlavor
from ..components.madrox import MadroxComponent
from ..components.carnie import CarnieComponent
from ..components.danger_state import DangerStateComponent, DangerState
from ..components.loyalty import LoyaltyComponent, LoyaltyAction
from ..components.authority import AuthorityComponent, AuthorityLevel
from ..components.hidden_potential import HiddenPotentialComponent
from ..components.toxicity import ToxicityComponent, ToxicityType


def register_entity_hooks(engine) -> List[str]:
    """
    Register all entity-related hooks.
    
    This patches the Entity class to support DLC components.
    
    Args:
        engine: The V3_carnival GameEngine
        
    Returns:
        List of registered hook names
    """
    hooks_registered = []
    
    # Get Entity class from engine
    Entity = engine.Entity if hasattr(engine, 'Entity') else None
    
    if Entity is None:
        # Create a mock for standalone testing
        class Entity:
            """Base Entity class (hooked version)."""
            _entity_id_counter = 0
            
            def __init__(self, *args, **kwargs):
                Entity._entity_id_counter += 1
                self.entity_id = f"entity_{Entity._entity_id_counter}"
                self._components = {}
                self._tick = 0
        
        engine.Entity = Entity
    
    # Add ComponentHolder mixin
    Entity = _add_component_holder(Entity)
    hooks_registered.append("Entity.component_holder")
    
    # Add component accessor properties
    Entity = _add_component_properties(Entity)
    hooks_registered.append("Entity.component_properties")
    
    # Add DLC-specific methods
    Entity = _add_dlc_methods(Entity)
    hooks_registered.append("Entity.dlc_methods")
    
    # Store hooked class
    engine.Entity = Entity
    
    return hooks_registered


def _add_component_holder(Entity):
    """Add ComponentHolder mixin to Entity."""
    
    # Store original __init__
    _original_init = Entity.__init__ if hasattr(Entity, '__init__') else None
    
    def __init__(self, *args, **kwargs):
        # Call original init
        if _original_init:
            _original_init(self, *args, **kwargs)
        
        # Initialize component holder
        if not hasattr(self, '_components'):
            self._components: Dict[str, Component] = {}
        if not hasattr(self, '_component_history'):
            self._component_history: List[Dict] = []
    
    Entity.__init__ = __init__
    
    # Add component methods
    def add_component(self, component: Component) -> Component:
        """Add a component to this entity."""
        component_type = component.__class__.__name__
        
        # Archive existing (0 = 3)
        if component_type in self._components:
            old = self._components[component_type]
            self._component_history.append({
                "component": old,
                "action": "replaced",
                "tick": getattr(self, '_tick', 0),
            })
            old.deactivate()
        
        component.attach(self)
        self._components[component_type] = component
        return component
    
    def get_component(self, component_type: str) -> Optional[Component]:
        """Get a component by type name."""
        return self._components.get(component_type)
    
    def has_component(self, component_type: str) -> bool:
        """Check if entity has a component type."""
        return component_type in self._components
    
    def remove_component(self, component_type: str) -> Optional[Component]:
        """Remove a component (soft delete - archives it)."""
        if component_type not in self._components:
            return None
        
        component = self._components[component_type]
        
        self._component_history.append({
            "component": component,
            "action": "removed",
            "tick": getattr(self, '_tick', 0),
        })
        
        component.detach()
        del self._components[component_type]
        return component
    
    def get_all_components(self) -> Dict[str, Component]:
        """Get all components."""
        return self._components.copy()
    
    Entity.add_component = add_component
    Entity.get_component = get_component
    Entity.has_component = has_component
    Entity.remove_component = remove_component
    Entity.get_all_components = get_all_components
    
    return Entity


def _add_component_properties(Entity):
    """Add convenient component accessor properties."""
    
    @property
    def faygo(self) -> Optional[FaygoComponent]:
        """Get Faygo component."""
        return self.get_component("FaygoComponent")
    
    @property
    def madrox(self) -> Optional[MadroxComponent]:
        """Get Madrox component."""
        return self.get_component("MadroxComponent")
    
    @property
    def carnie(self) -> Optional[CarnieComponent]:
        """Get Carnie component."""
        return self.get_component("CarnieComponent")
    
    @property
    def danger_state(self) -> Optional[DangerStateComponent]:
        """Get DangerState component."""
        return self.get_component("DangerStateComponent")
    
    @property
    def loyalty(self) -> Optional[LoyaltyComponent]:
        """Get Loyalty component."""
        return self.get_component("LoyaltyComponent")
    
    @property
    def authority(self) -> Optional[AuthorityComponent]:
        """Get Authority component."""
        return self.get_component("AuthorityComponent")
    
    @property
    def hidden_potential(self) -> Optional[HiddenPotentialComponent]:
        """Get HiddenPotential component."""
        return self.get_component("HiddenPotentialComponent")
    
    @property
    def toxicity(self) -> Optional[ToxicityComponent]:
        """Get Toxicity component."""
        return self.get_component("ToxicityComponent")
    
    @property
    def is_in_danger(self) -> bool:
        """Check if entity is in any danger state."""
        ds = self.danger_state
        return ds.is_in_danger if ds else False
    
    @property
    def is_overthinking(self) -> bool:
        """Check if entity is overthinking."""
        mx = self.madrox
        return mx.is_overthinking if mx else False
    
    @property
    def anxiety_level(self) -> float:
        """Get entity's anxiety level."""
        mx = self.madrox
        return mx.anxiety_level if mx else 0.0
    
    @property
    def authority_level(self) -> str:
        """Get entity's authority level name."""
        auth = self.authority
        return auth.level.name if auth else "NORMAL"
    
    Entity.faygo = faygo
    Entity.madrox = madrox
    Entity.carnie = carnie
    Entity.danger_state = danger_state
    Entity.loyalty = loyalty
    Entity.authority = authority
    Entity.hidden_potential = hidden_potential
    Entity.toxicity = toxicity
    Entity.is_in_danger = is_in_danger
    Entity.is_overthinking = is_overthinking
    Entity.anxiety_level = anxiety_level
    Entity.authority_level = authority_level
    
    return Entity


def _add_dlc_methods(Entity):
    """Add DLC-specific helper methods to Entity."""
    
    def give_faygo(
        self,
        flavor: FaygoFlavor = FaygoFlavor.GRAPE,
        volume: float = 1.0
    ) -> FaygoComponent:
        """Give this entity some Faygo."""
        component = FaygoComponent(flavor=flavor, volume=volume)
        self.add_component(component)
        return component
    
    def start_overthinking(self, trigger: str = "") -> Dict[str, Any]:
        """Start this entity overthinking."""
        if not self.madrox:
            self.add_component(MadroxComponent())
        return self.madrox.start_overthinking(trigger)
    
    def stop_overthinking(self, reason: str = "calm") -> Dict[str, Any]:
        """Stop this entity from overthinking."""
        if self.madrox:
            return self.madrox.stop_overthinking(reason)
        return {"success": False, "reason": "not_overthinking"}
    
    def enter_danger(
        self,
        state: DangerState,
        source: str = "",
        intensity: float = 1.0,
        tick: int = 0
    ) -> Dict[str, Any]:
        """Enter a danger state."""
        if not self.danger_state:
            self.add_component(DangerStateComponent())
        return self.danger_state.enter_state(state, source, intensity, tick)
    
    def exit_danger(
        self,
        state: DangerState,
        reason: str = "expired",
        tick: int = 0
    ) -> Dict[str, Any]:
        """Exit a danger state."""
        if self.danger_state:
            return self.danger_state.exit_state(state, reason, tick)
        return {"success": False, "reason": "no_danger_state"}
    
    def modify_loyalty(
        self,
        target_entity_id: str,
        action: LoyaltyAction,
        context: str = "",
        tick: int = 0
    ) -> Dict[str, Any]:
        """Modify loyalty toward another entity."""
        if not self.loyalty:
            self.add_component(LoyaltyComponent())
        return self.loyalty.modify_loyalty(target_entity_id, action, context, tick)
    
    def set_authority(
        self,
        level: AuthorityLevel,
        source: str = ""
    ) -> Dict[str, Any]:
        """Set authority level."""
        if not self.authority:
            self.add_component(AuthorityComponent())
        return self.authority.grant_authority(level, source)
    
    def apply_toxin(
        self,
        toxin_type: ToxicityType,
        severity: float = 0.5,
        source: str = "",
        duration: int = None
    ) -> Dict[str, Any]:
        """Apply a toxin to this entity."""
        if not self.toxicity:
            self.add_component(ToxicityComponent())
        return self.toxicity.apply_toxin(
            toxin_type,
            severity=severity,
            source=source,
            duration=duration
        )
    
    def cleanse_toxin(
        self,
        amount: float = 0.1,
        toxin_type: ToxicityType = None
    ) -> Dict[str, Any]:
        """Cleanse toxins from this entity."""
        if self.toxicity:
            return self.toxicity.cleanse(amount, toxin_type)
        return {"success": False, "reason": "no_toxicity"}
    
    def tick_components(self, current_tick: int = 0):
        """Tick all components on this entity."""
        for component in self._components.values():
            if hasattr(component, 'tick'):
                component.tick(current_tick)
        
        if hasattr(self, '_tick'):
            self._tick = current_tick
    
    Entity.give_faygo = give_faygo
    Entity.start_overthinking = start_overthinking
    Entity.stop_overthinking = stop_overthinking
    Entity.enter_danger = enter_danger
    Entity.exit_danger = exit_danger
    Entity.modify_loyalty = modify_loyalty
    Entity.set_authority = set_authority
    Entity.apply_toxin = apply_toxin
    Entity.cleanse_toxin = cleanse_toxin
    Entity.tick_components = tick_components
    
    return Entity


def create_entity_with_components(
    engine,
    component_configs: List[Dict[str, Any]] = None,
    **kwargs
):
    """
    Factory function to create an entity with components.
    
    Args:
        engine: The game engine
        component_configs: List of component configurations
        **kwargs: Additional entity properties
        
    Returns:
        Entity with components attached
    """
    Entity = engine.Entity
    entity = Entity(**kwargs)
    
    if component_configs:
        for config in component_configs:
            component_type = config.pop("type")
            
            # Map type names to classes
            component_map = {
                "FaygoComponent": FaygoComponent,
                "MadroxComponent": MadroxComponent,
                "CarnieComponent": CarnieComponent,
                "DangerStateComponent": DangerStateComponent,
                "LoyaltyComponent": LoyaltyComponent,
                "AuthorityComponent": AuthorityComponent,
                "HiddenPotentialComponent": HiddenPotentialComponent,
                "ToxicityComponent": ToxicityComponent,
            }
            
            component_class = component_map.get(component_type)
            if component_class:
                entity.add_component(component_class(**config))
    
    return entity

"""
Engine Hooks
============
Extensions to the GameEngine class.

These hooks add DLC system support to the engine
without modifying the base GameEngine class.

Hook Pattern:
1. Check if engine has the extension
2. Add system management methods
3. Integrate with engine tick loop
"""

from typing import Dict, Any, List, Optional, Callable
import time

from ..core.event import EventManager, DLC_EVENT
from ..systems.magnetic_fields import MagneticFieldsSystem
from ..systems.rumor import RumorManager
from ..systems.party import JuggaloParty
from ..systems.midway import MidwaySystem
from ..systems.yellow_bus import YellowBusSystem
from ..systems.diamond_rain import DiamondRainSystem
from ..systems.thermodynamics import ThermodynamicsSystem
from ..ecology.cover_crops import CoverCropManager
from ..ecology.pests import PestManager
from ..ecology.predators import PredatorManager
from ..ecology.decay import DecaySystem


def register_engine_hooks(engine) -> List[str]:
    """
    Register all engine-related hooks.
    
    This patches the GameEngine class to support DLC systems.
    
    Args:
        engine: The V3_carnival GameEngine
        
    Returns:
        List of registered hook names
    """
    hooks_registered = []
    
    # Add DLC system storage
    engine = _add_system_storage(engine)
    hooks_registered.append("Engine.dlc_systems")
    
    # Add event manager
    engine = _add_event_manager(engine)
    hooks_registered.append("Engine.event_manager")
    
    # Add system management methods
    engine = _add_system_management(engine)
    hooks_registered.append("Engine.system_management")
    
    # Add DLC tick integration
    engine = _add_tick_integration(engine)
    hooks_registered.append("Engine.tick_integration")
    
    # Add helper methods
    engine = _add_helper_methods(engine)
    hooks_registered.append("Engine.helper_methods")
    
    return hooks_registered


def _add_system_storage(engine):
    """Add DLC system storage to engine."""
    
    if not hasattr(engine, 'dlc_systems'):
        engine.dlc_systems = {}
    
    if not hasattr(engine, 'dlc_components'):
        engine.dlc_components = {}
    
    return engine


def _add_event_manager(engine):
    """Add event manager to engine."""
    
    if not hasattr(engine, 'event_manager'):
        engine.event_manager = EventManager()
    
    # Add event emission helper
    def emit_dlc_event(
        event_type: DLC_EVENT,
        source = None,
        data: Dict = None,
        queue: bool = False
    ):
        """Emit a DLC event."""
        tick = getattr(engine, '_tick_count', 0)
        return engine.event_manager.emit(
            event_type,
            source=source,
            data=data or {},
            tick=tick,
            queue=queue
        )
    
    engine.emit_dlc_event = emit_dlc_event
    
    # Add subscription helper
    def on_dlc_event(event_type: DLC_EVENT, callback: Callable):
        """Subscribe to a DLC event."""
        engine.event_manager.subscribe(event_type, callback)
    
    engine.on_dlc_event = on_dlc_event
    
    return engine


def _add_system_management(engine):
    """Add system management methods to engine."""
    
    def initialize_dlc_systems():
        """Initialize all DLC systems."""
        engine.dlc_systems = {
            "magnetic_fields": MagneticFieldsSystem(),
            "rumor_manager": RumorManager(),
            "juggalo_party": JuggaloParty(),
            "midway": MidwaySystem(),
            "yellow_bus": YellowBusSystem(),
            "diamond_rain": DiamondRainSystem(),
            "thermodynamics": ThermodynamicsSystem(),
            "cover_crops": CoverCropManager(),
            "pests": PestManager(),
            "predators": PredatorManager(),
            "decay": DecaySystem(),
        }
        
        return list(engine.dlc_systems.keys())
    
    def get_dlc_system(name: str):
        """Get a DLC system by name."""
        return engine.dlc_systems.get(name)
    
    def get_all_dlc_systems() -> Dict:
        """Get all DLC systems."""
        return engine.dlc_systems.copy()
    
    engine.initialize_dlc_systems = initialize_dlc_systems
    engine.get_dlc_system = get_dlc_system
    engine.get_all_dlc_systems = get_all_dlc_systems
    
    # Initialize systems if not already done
    if not engine.dlc_systems:
        engine.initialize_dlc_systems()
    
    return engine


def _add_tick_integration(engine):
    """Add DLC tick integration to engine."""
    
    # Store original tick if exists
    _original_tick = engine.tick if hasattr(engine, 'tick') else None
    
    def tick() -> Dict[str, Any]:
        """Process one engine tick with DLC systems."""
        # Get or increment tick count
        if hasattr(engine, '_tick_count'):
            engine._tick_count += 1
        else:
            engine._tick_count = 1
        
        current_tick = engine._tick_count
        
        results = {
            "tick": current_tick,
            "systems": {},
        }
        
        # Call original tick if exists
        if _original_tick:
            try:
                base_result = _original_tick()
                results["base"] = base_result
            except Exception as e:
                results["base_error"] = str(e)
        
        # Process DLC systems in order
        system_order = [
            "thermodynamics",    # Heat flows first
            "cover_crops",       # Crops grow
            "pests",             # Pests spawn/move
            "predators",         # Predators hunt
            "decay",             # Decay processes
            "yellow_bus",        # Energy distribution
            "diamond_rain",      # Cooling cycle
            "magnetic_fields",   # Particle physics
            "rumor_manager",     # Information spread
            "juggalo_party",     # Party mechanics
            "midway",            # Carnival games
        ]
        
        for system_name in system_order:
            system = engine.dlc_systems.get(system_name)
            if system and hasattr(system, 'tick'):
                try:
                    # Special handling for predator system
                    if system_name == "predators":
                        pest_manager = engine.dlc_systems.get("pests")
                        result = system.tick(pest_manager)
                    else:
                        result = system.tick()
                    
                    results["systems"][system_name] = result
                except Exception as e:
                    results["systems"][system_name] = {"error": str(e)}
        
        # Process event queue
        engine.event_manager.process_queue()
        
        return results
    
    engine.tick = tick
    
    # Add tick count property
    if not hasattr(engine, '_tick_count'):
        engine._tick_count = 0
    
    return engine


def _add_helper_methods(engine):
    """Add helper methods to engine."""
    
    def get_global_heat() -> float:
        """Get global heat level."""
        thermo = engine.dlc_systems.get("thermodynamics")
        if thermo:
            return thermo.average_heat
        diamond = engine.dlc_systems.get("diamond_rain")
        if diamond:
            return diamond.global_heat
        return 0.0
    
    def get_global_chaos() -> float:
        """Get global chaos level."""
        party = engine.dlc_systems.get("juggalo_party")
        if party:
            return party.get_global_chaos_level()
        return 0.0
    
    def get_ecosystem_summary() -> Dict[str, Any]:
        """Get summary of ecosystem state."""
        cover_crops = engine.dlc_systems.get("cover_crops")
        pests = engine.dlc_systems.get("pests")
        predators = engine.dlc_systems.get("predators")
        decay = engine.dlc_systems.get("decay")
        
        return {
            "cover_crops": {
                "count": len(cover_crops.crops) if cover_crops else 0,
                "heat_output": cover_crops.get_total_heat_output() if cover_crops else 0,
                "faygo_output": cover_crops.get_total_faygo_output() if cover_crops else 0,
            },
            "pests": {
                "count": len(pests.pests) if pests else 0,
                "total_energy": pests.get_total_energy() if pests else 0,
            },
            "predators": {
                "count": len(predators.predators) if predators else 0,
                "hunting_capacity": predators.get_total_hunting_capacity() if predators else 0,
            },
            "decay": {
                "piles": len(decay.piles) if decay else 0,
                "nutrients": decay.available_nutrients if decay else 0,
            },
        }
    
    def add_heat(x: float, y: float, amount: float, source: str = "") -> Dict:
        """Add heat to a location."""
        # Add to thermodynamics
        thermo = engine.dlc_systems.get("thermodynamics")
        if thermo:
            thermo.add_heat(x, y, amount, source)
        
        # Trigger diamond rain
        diamond = engine.dlc_systems.get("diamond_rain")
        if diamond:
            diamond.add_heat(x, y, amount, source)
        
        # Emit event
        engine.emit_dlc_event(
            DLC_EVENT.HEAT_GENERATED,
            source=source,
            data={"x": x, "y": y, "amount": amount}
        )
        
        return {"success": True, "heat_added": amount}
    
    def start_party(host_id: str, x: float = 0, y: float = 0):
        """Start a Juggalo party."""
        party = engine.dlc_systems.get("juggalo_party")
        if party:
            result = party.start_party(host_id, x, y)
            engine.emit_dlc_event(
                DLC_EVENT.PARTY_STARTED,
                source=host_id,
                data={"party_id": result.party_id}
            )
            return result
        return None
    
    def create_rumor(content: str, source_id: str, tags: List[str] = None):
        """Create a new rumor."""
        rumor_mgr = engine.dlc_systems.get("rumor_manager")
        if rumor_mgr:
            result = rumor_mgr.create_rumor(content, source_id, tags=tags)
            engine.emit_dlc_event(
                DLC_EVENT.RUMOR_STARTED,
                source=source_id,
                data={"rumor_id": result.rumor_id}
            )
            return result
        return None
    
    engine.get_global_heat = get_global_heat
    engine.get_global_chaos = get_global_chaos
    engine.get_ecosystem_summary = get_ecosystem_summary
    engine.add_heat = add_heat
    engine.start_party = start_party
    engine.create_rumor = create_rumor
    
    return engine


def create_test_engine():
    """
    Create a minimal test engine with DLC systems.
    
    Useful for testing without the full V3_carnival.
    """
    class TestEngine:
        """Minimal engine for testing."""
        def __init__(self):
            self._tick_count = 0
            self.dlc_systems = {}
            self.dlc_components = {}
    
    engine = TestEngine()
    register_engine_hooks(engine)
    
    return engine

"""
Biome Hooks
===========
Extensions to the Biome class.

These hooks add DLC environmental support to biomes
without modifying the base Biome class.

Features added:
- Thermal layers
- Cover crop zones
- Pest/predator populations
- Diamond rain zones
"""

from typing import Dict, Any, List, Optional
import math

from ..constants import BIOME_HEAT_BASE, BIOME_NOURISHMENT_BASE, PHI
from ..enums import ThermalLayer, EcologicalPhase


def register_biome_hooks(engine) -> List[str]:
    """
    Register all biome-related hooks.
    
    This patches the Biome class to support DLC environmental features.
    
    Args:
        engine: The V3_carnival GameEngine
        
    Returns:
        List of registered hook names
    """
    hooks_registered = []
    
    # Get or create Biome class
    Biome = engine.Biome if hasattr(engine, 'Biome') else None
    
    if Biome is None:
        # Create a mock for standalone testing
        class Biome:
            """Base Biome class (hooked version)."""
            _biome_id_counter = 0
            
            def __init__(self, name: str = "Biome", **kwargs):
                Biome._biome_id_counter += 1
                self.biome_id = f"biome_{Biome._biome_id_counter}"
                self.name = name
                self.x = 0.0
                self.y = 0.0
                self.radius = 50.0
        
        engine.Biome = Biome
    
    # Add thermal properties
    Biome = _add_thermal_properties(Biome)
    hooks_registered.append("Biome.thermal_properties")
    
    # Add ecological properties
    Biome = _add_ecological_properties(Biome)
    hooks_registered.append("Biome.ecological_properties")
    
    # Add environmental methods
    Biome = _add_environmental_methods(Biome)
    hooks_registered.append("Biome.environmental_methods")
    
    # Store hooked class
    engine.Biome = Biome
    
    return hooks_registered


def _add_thermal_properties(Biome):
    """Add thermal properties to Biome."""
    
    # Store original __init__ if exists
    _original_init = Biome.__init__ if hasattr(Biome, '__init__') else None
    
    def __init__(self, *args, **kwargs):
        if _original_init:
            _original_init(self, *args, **kwargs)
        
        # Thermal state
        if not hasattr(self, 'heat'):
            self.heat = BIOME_HEAT_BASE
        if not hasattr(self, 'moisture'):
            self.moisture = 50.0
        if not hasattr(self, 'thermal_layer'):
            self.thermal_layer = ThermalLayer.SURFACE
        
        # Heat sources within biome
        if not hasattr(self, 'heat_sources'):
            self.heat_sources: List[Dict] = []
        
        # Temperature history
        if not hasattr(self, 'heat_history'):
            self.heat_history: List[float] = []
    
    Biome.__init__ = __init__
    
    @property
    def temperature(self) -> float:
        """Get temperature (alias for heat)."""
        return self.heat
    
    @property
    def is_hot(self) -> bool:
        """Check if biome is hot."""
        return self.heat > 50
    
    @property
    def is_cold(self) -> bool:
        """Check if biome is cold."""
        return self.heat < 20
    
    @property
    def thermal_comfort(self) -> float:
        """Get thermal comfort level (0-1)."""
        # Comfort is highest around 30-40 heat
        if 25 <= self.heat <= 45:
            return 1.0
        elif self.heat < 25:
            return max(0, 1 - (25 - self.heat) / 25)
        else:
            return max(0, 1 - (self.heat - 45) / 55)
    
    Biome.temperature = temperature
    Biome.is_hot = is_hot
    Biome.is_cold = is_cold
    Biome.thermal_comfort = thermal_comfort
    
    return Biome


def _add_ecological_properties(Biome):
    """Add ecological properties to Biome."""
    
    @property
    def ecological_phase(self) -> EcologicalPhase:
        """Determine current ecological phase."""
        if self.heat > 60:
            return EcologicalPhase.BUILD
        elif self.moisture > 70:
            return EcologicalPhase.RISE
        elif self.heat < 30 and self.moisture > 50:
            return EcologicalPhase.CRYSTALLIZE
        else:
            return EcologicalPhase.RAIN
    
    @property
    def fertility(self) -> float:
        """Get soil fertility (affects cover crop growth)."""
        base = BIOME_NOURISHMENT_BASE
        
        # Heat affects fertility
        if self.heat > 60:
            base *= 0.8  # Too hot
        elif self.heat < 20:
            base *= 0.9  # Too cold
        
        # Moisture affects fertility
        if 30 <= self.moisture <= 70:
            base *= 1.2  # Optimal
        elif self.moisture < 20:
            base *= 0.7  # Too dry
        
        return min(100, max(0, base))
    
    @property
    def pest_pressure(self) -> float:
        """Get pest pressure in this biome."""
        # Based on cover crops and heat
        base = 0.0
        
        if hasattr(self, 'cover_crop_count'):
            base += self.cover_crop_count * 0.5
        
        if self.heat > 50:
            base += (self.heat - 50) * 0.1
        
        if self.moisture > 60:
            base += (self.moisture - 60) * 0.05
        
        return min(10, max(0, base))
    
    Biome.ecological_phase = ecological_phase
    Biome.fertility = fertility
    Biome.pest_pressure = pest_pressure
    
    # Initialize ecological state
    if not hasattr(Biome, 'cover_crop_count'):
        Biome.cover_crop_count = 0
    
    if not hasattr(Biome, 'pest_population'):
        Biome.pest_population = 0.0
    
    if not hasattr(Biome, 'predator_population'):
        Biome.predator_population = 0.0
    
    return Biome


def _add_environmental_methods(Biome):
    """Add environmental methods to Biome."""
    
    def add_heat_source(
        self,
        x: float,
        y: float,
        output: float,
        source_id: str = ""
    ):
        """Add a heat source to this biome."""
        self.heat_sources.append({
            "x": x,
            "y": y,
            "output": output,
            "source_id": source_id,
        })
    
    def remove_heat_source(self, source_id: str) -> bool:
        """Remove a heat source by ID."""
        for i, source in enumerate(self.heat_sources):
            if source.get("source_id") == source_id:
                self.heat_sources.pop(i)
                return True
        return False
    
    def get_total_heat_output(self) -> float:
        """Get total heat output from all sources."""
        return sum(s.get("output", 0) for s in self.heat_sources)
    
    def apply_cooling(self, amount: float):
        """Apply cooling to this biome."""
        self.heat = max(0, self.heat - amount)
    
    def apply_moisture(self, amount: float):
        """Add moisture to this biome."""
        self.moisture = min(100, max(0, self.moisture + amount))
    
    def tick_environment(self, current_tick: int = 0):
        """Process environmental tick for this biome."""
        # Heat from sources
        total_output = self.get_total_heat_output()
        self.heat += total_output * 0.1
        
        # Natural cooling
        self.heat = max(BIOME_HEAT_BASE * 0.5, self.heat * 0.99)
        
        # Moisture dynamics
        if self.heat > 50:
            # Evaporation
            self.moisture = max(0, self.moisture - (self.heat - 50) * 0.01)
        
        # Record history
        self.heat_history.append(self.heat)
        if len(self.heat_history) > 100:
            self.heat_history.pop(0)
        
        # Update thermal layer based on position
        if hasattr(self, 'x') and hasattr(self, 'y'):
            dist_from_center = math.sqrt(self.x**2 + self.y**2)
            
            if dist_from_center < 20:
                self.thermal_layer = ThermalLayer.CORE
            elif dist_from_center < 40:
                self.thermal_layer = ThermalLayer.MANTLE
            else:
                self.thermal_layer = ThermalLayer.SURFACE
    
    def get_environment_state(self) -> Dict[str, Any]:
        """Get current environmental state."""
        return {
            "biome_id": getattr(self, 'biome_id', 'unknown'),
            "name": getattr(self, 'name', 'Unknown'),
            "heat": round(self.heat, 2),
            "moisture": round(self.moisture, 2),
            "thermal_layer": self.thermal_layer.name,
            "ecological_phase": self.ecological_phase.name,
            "fertility": round(self.fertility, 2),
            "pest_pressure": round(self.pest_pressure, 2),
            "heat_sources": len(self.heat_sources),
        }
    
    def can_support_cover_crops(self) -> bool:
        """Check if biome can support cover crops."""
        return (
            self.fertility > 30 and
            self.heat < 70 and
            self.moisture > 10
        )
    
    def get_optimal_cover_crop(self) -> Optional[str]:
        """Get optimal cover crop type for this biome."""
        if not self.can_support_cover_crops():
            return None
        
        # Select based on conditions
        if self.heat > 50:
            return "SORGHUM"  # Heat tolerant
        elif self.moisture < 40:
            return "BUCKWHEAT"  # Drought tolerant
        elif self.fertility > 70:
            return "VETCH"  # High fertility
        else:
            return "CLOVER"  # General purpose
    
    Biome.add_heat_source = add_heat_source
    Biome.remove_heat_source = remove_heat_source
    Biome.get_total_heat_output = get_total_heat_output
    Biome.apply_cooling = apply_cooling
    Biome.apply_moisture = apply_moisture
    Biome.tick_environment = tick_environment
    Biome.get_environment_state = get_environment_state
    Biome.can_support_cover_crops = can_support_cover_crops
    Biome.get_optimal_cover_crop = get_optimal_cover_crop
    
    return Biome


def create_biome(
    engine,
    name: str = "Biome",
    x: float = 0.0,
    y: float = 0.0,
    radius: float = 50.0,
    heat: float = BIOME_HEAT_BASE,
    moisture: float = 50.0,
    **kwargs
):
    """
    Factory function to create a biome with DLC features.
    
    Args:
        engine: The game engine
        name: Biome name
        x, y: Position
        radius: Size
        heat: Initial heat level
        moisture: Initial moisture level
        **kwargs: Additional properties
        
    Returns:
        Biome with DLC features
    """
    Biome = engine.Biome
    
    biome = Biome(name=name, **kwargs)
    biome.x = x
    biome.y = y
    biome.radius = radius
    biome.heat = heat
    biome.moisture = moisture
    
    return biome


def create_midway_biome(engine):
    """
    Create the Midway biome.
    
    This is the main carnival grounds.
    """
    biome = create_biome(
        engine,
        name="The Midway",
        x=60.0,  # Center of carnival
        y=0.0,
        radius=100.0,
        heat=35.0,  # Warm from activities
        moisture=40.0,  # Moderate
    )
    
    # Add default heat sources
    biome.add_heat_source(20, 0, 5, "faygo_stand")
    biome.add_heat_source(40, 0, 8, "mosh_pit")
    biome.add_heat_source(80, 0, 3, "high_striker")
    biome.add_heat_source(100, 0, 6, "wheel_of_fate")
    
    return biome



