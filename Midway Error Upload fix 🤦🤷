ðŸ§± PHASE 1 â€“ COMPONENT SYSTEM

Â· A base Component class.
Â· A ComponentHolder mixin for entities (like Particle).
Â· Example component (HealthComponent) to test with.
Â· Full integration instructions for the base engine.

---

ðŸ“ File: dlc1/component.py

```python
# =============================================================================
# COMPONENT SYSTEM â€“ BASE CLASSES
# =============================================================================

class Component:
    """
    Base class for all components.
    Components are attached to an entity (e.g., a Particle) and provide modular behavior.
    """
    def __init__(self, name):
        self.name = name
        self.entity = None  # reference to the owning entity, set on attach

    def on_attach(self, entity):
        """Called when this component is added to an entity."""
        self.entity = entity

    def on_detach(self):
        """Called when this component is removed from an entity."""
        self.entity = None

    def update(self, tick):
        """
        Called every simulation tick.
        Override in subclasses to implement perâ€‘tick behavior.
        """
        pass

    def handle_event(self, event):
        """
        Called when an event is dispatched.
        Return True if the event was handled and should not be passed to other components.
        """
        return False


class ComponentHolder:
    """
    Mixin for entities that can hold components.
    Add this as a base class to your entity class.
    """
    def __init__(self):
        self.components = {}  # name -> Component

    def add_component(self, name, component):
        """Attach a component to this entity."""
        component.on_attach(self)
        self.components[name] = component

    def remove_component(self, name):
        """Detach a component by name."""
        if name in self.components:
            self.components[name].on_detach()
            del self.components[name]

    def get_component(self, name):
        """Retrieve a component by name, or None if not present."""
        return self.components.get(name)

    def update_components(self, tick):
        """Call update on all attached components."""
        for comp in self.components.values():
            comp.update(tick)

    def dispatch_event_to_components(self, event):
        """
        Send an event to all components, stopping if one handles it.
        Returns True if any component handled the event.
        """
        for comp in self.components.values():
            if comp.handle_event(event):
                return True
        return False
```

---

ðŸ”§ Integration Instructions

Modify your Particle class to use the component system.

1. Inherit from ComponentHolder

```python
from dlc1.component import ComponentHolder

class Particle(ComponentHolder):  # add ComponentHolder as a base class
    def __init__(self, name: str = "Particle", ...):
        ComponentHolder.__init__(self)  # initialize the component holder
        # ... rest of your __init__ ...
```

2. Add a default component (optional)

To test, add a simple component that tracks health (or any stat). Create a file dlc1/example_components.py:

```python
from .component import Component

class HealthComponent(Component):
    def __init__(self, max_health=100):
        super().__init__("health")
        self.health = max_health
        self.max_health = max_health

    def update(self, tick):
        # Example: slowly regenerate health
        self.health = min(self.max_health, self.health + 0.1)

    def take_damage(self, amount):
        self.health -= amount
        if self.health <= 0:
            self.entity.die()  # assuming your entity has a die() method
```

Then in Particle.__init__, add the component:

```python
from dlc1.example_components import HealthComponent

class Particle(ComponentHolder):
    def __init__(self, ...):
        ComponentHolder.__init__(self)
        # ... other init ...
        self.add_component("health", HealthComponent())
```

3. Update the particle's update method

```python
def update(self, tick):
    # ... your existing update logic ...
    self.update_components(tick)  # let components do their perâ€‘tick work
```

ðŸ§± PHASE 1 â€“ EVENT SYSTEM

Here is the complete Event System. It provides a global event bus for decoupled communication between components, particles, and the engine.

Â· Event class â€“ holds event data.
Â· EventManager â€“ manages subscriptions and dispatches events.
Â· Integration instructions for UnifiedEngine and Particle.

---

ðŸ“ File: dlc1/event.py

```python
# =============================================================================
# EVENT SYSTEM â€“ GLOBAL EVENT BUS
# =============================================================================

from collections import defaultdict
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional

@dataclass
class Event:
    """Represents an event in the simulation."""
    type: str                       # e.g., "faygo_use", "bond_change", "tile_entered"
    source: Optional[Any] = None    # the object that triggered the event (e.g., a particle)
    target: Optional[Any] = None    # the primary target, if any
    data: Dict[str, Any] = field(default_factory=dict)  # additional information


class EventManager:
    """
    Manages event subscriptions and dispatches events to all registered listeners.
    """
    def __init__(self):
        self._listeners: Dict[str, List[Callable[[Event], None]]] = defaultdict(list)

    def subscribe(self, event_type: str, callback: Callable[[Event], None]) -> None:
        """
        Register a callback to be called when an event of the given type is posted.
        """
        self._listeners[event_type].append(callback)

    def unsubscribe(self, event_type: str, callback: Callable[[Event], None]) -> None:
        """
        Remove a previously registered callback.
        """
        if callback in self._listeners[event_type]:
            self._listeners[event_type].remove(callback)

    def post(self, event: Event) -> None:
        """
        Dispatch an event to all listeners subscribed to its type.
        """
        for cb in self._listeners.get(event.type, []):
            cb(event)
        # Also post to wildcard listeners (type "*") if desired â€“ can be added later
```

---

ðŸ”§ Integration Instructions

1. Add EventManager to UnifiedEngine

In your UnifiedEngine class, add an event_manager attribute and initialize it.

```python
from dlc1.event import EventManager

class UnifiedEngine:
    def __init__(self, ...):
        # ... existing code ...
        self.event_manager = EventManager()
```

2. Modify Particle to post events and handle incoming events

Add a method to post events conveniently:

```python
class Particle(ComponentHolder):
    # ... existing code ...

    def post_event(self, event_type: str, target=None, **data):
        """Create and post an event through the engine's event manager."""
        event = Event(
            type=event_type,
            source=self,
            target=target,
            data=data
        )
        self.engine.event_manager.post(event)

    def handle_event(self, event: Event) -> bool:
        """
        Called by the engine when an event is posted.
        Delegates to components and returns True if handled.
        """
        return self.dispatch_event_to_components(event)
```

Then, ensure the engine calls handle_event on all particles when an event is posted? Actually, the event manager already calls callbacks directly. But particles can subscribe to events themselves. We'll handle that by letting components subscribe in their on_attach.

3. Make components subscribe to events

Components can subscribe in on_attach and unsubscribe in on_detach. Example:

```python
class MadroxComponent(Component):
    def on_attach(self, entity):
        super().on_attach(entity)
        entity.engine.event_manager.subscribe("bond_decrease", self.on_bond_decrease)

    def on_detach(self):
        self.entity.engine.event_manager.unsubscribe("bond_decrease", self.on_bond_decrease)
        super().on_detach()

    def on_bond_decrease(self, event: Event):
        # react to bond decrease events
        pass
```

4. Example: Posting an event from an action

When a particle uses Faygo (once we implement it), they can post an event:

```python
# Inside FaygoComponent.use_faygo
self.entity.post_event("faygo_use", target=target, mode=mode, fizz=self.faygo_fizz)
```

Other components (e.g., Madrox, Carnie) can subscribe to "faygo_use" and react accordingly.

---
ðŸ§± PHASE 1 â€“ ARCHETYPE MANAGER

Here is the complete Archetype Manager. It loads particle archetype definitions from JSON files and applies them to a Particle instance.

Features:

Â· JSON schema for archetypes (base coordinates, starting components, action weights, dialogue preferences).
Â· ArchetypeManager class that loads all archetypes from a directory.
Â· apply_archetype method to configure a particle based on its archetype name.
Â· Support for adding components specified in the archetype JSON.
Â· Placeholder for component creation (you'll need to extend the factory for your custom components).

---

ðŸ“ File: dlc1/archetype.py

```python
# =============================================================================
# ARCHETYPE MANAGER â€“ DATAâ€‘DRIVEN ROLE DEFINITIONS
# =============================================================================

import os
import json
from typing import Dict, Any, Optional
from .component import Component

class ArchetypeManager:
    """
    Loads archetype definitions from JSON files and applies them to particles.
    """
    def __init__(self, archetype_dir: str = "archetypes/"):
        self.archetype_dir = archetype_dir
        self.archetypes: Dict[str, Dict[str, Any]] = {}
        self.load_all()

    def load_all(self) -> None:
        """Load all .json files from the archetype directory."""
        if not os.path.exists(self.archetype_dir):
            os.makedirs(self.archetype_dir)
            print(f"Created archetype directory: {self.archetype_dir}")
            return

        for filename in os.listdir(self.archetype_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.archetype_dir, filename)
                with open(path, 'r') as f:
                    data = json.load(f)
                    name = data.get("name")
                    if name:
                        self.archetypes[name] = data
                        print(f"Loaded archetype: {name}")
                    else:
                        print(f"Warning: {filename} missing 'name' field")

    def get_archetype(self, name: str) -> Optional[Dict[str, Any]]:
        """Return the raw archetype data for a given name."""
        return self.archetypes.get(name)

    def apply_archetype(self, particle: 'Particle', archetype_name: str) -> None:
        """
        Configure a particle using the named archetype.
        Sets base coordinates, builds tensor, adds components, and stores archetype data.
        """
        data = self.archetypes.get(archetype_name)
        if not data:
            raise ValueError(f"Archetype '{archetype_name}' not found")

        # 1. Set base personality coordinates
        coords_data = data.get("base_coords", {})
        particle.coords.warmth = coords_data.get("warmth", 3)
        particle.coords.softness = coords_data.get("softness", 3)
        particle.coords.family = coords_data.get("family", 1)
        particle.coords.axis_a = coords_data.get("axis_a", 3)
        particle.coords.axis_b = coords_data.get("axis_b", 3)
        particle.coords.clamp()

        # 2. Build the personality tensor (assuming your Particle has a tensor attribute)
        if hasattr(particle, 'tensor'):
            particle.tensor.build(particle.coords)

        # 3. Add components specified in the archetype
        components = data.get("components", {})
        for comp_name, comp_config in components.items():
            comp = self._create_component(comp_name, comp_config)
            if comp:
                particle.add_component(comp_name, comp)

        # 4. Store the full archetype data for later use (dialogue, action weights, etc.)
        particle.archetype_data = data

    def _create_component(self, comp_name: str, config: Any) -> Optional[Component]:
        """
        Factory method to instantiate a component from a name and config.
        Extend this with your own component classes.
        """
        # This is a placeholder â€“ you must add your own components here.
        # For example:
        # if comp_name == "inventory":
        #     from .faygo import InventoryComponent
        #     return InventoryComponent()
        # if comp_name == "madrox":
        #     from .madrox import MadroxComponent
        #     return MadroxComponent()
        # ... etc.

        # For now, return a generic component if not recognized
        print(f"Warning: No component class for '{comp_name}'. Using generic Component.")
        return Component(comp_name)
```

---

ðŸ“ Example Archetype JSON

Save this as archetypes/mystic.json:

```json
{
  "name": "MYSTIC",
  "base_coords": {
    "warmth": 4,
    "softness": 3,
    "family": 1,
    "axis_a": 4,
    "axis_b": 2
  },
  "components": {
    "memory": {
      "high_res_max": 10
    }
  },
  "action_weights": {
    "OBSERVE": 1.5,
    "SIGNAL": 1.2,
    "BOND": 1.3
  },
  "dialogue": {
    "tone": "mystical",
    "verbosity": 0.7
  },
  "allowed_actions": ["OBSERVE", "SIGNAL", "BOND", "SUPPORT", "CONVERSE"]
}
```

---

ðŸ”§ Integration Instructions

1. Add ArchetypeManager to UnifiedEngine

In your UnifiedEngine.__init__, add an archetype manager:

```python
from dlc1.archetype import ArchetypeManager

class UnifiedEngine:
    def __init__(self, ...):
        # ... existing code ...
        self.archetype_manager = ArchetypeManager("archetypes/")  # path to your archetype folder
```

2. Modify Particle.init to accept an archetype and apply it

```python
class Particle(ComponentHolder):
    def __init__(self, name: str = "Particle", archetype: str = "NORMAL", ...):
        ComponentHolder.__init__(self)
        self.name = name
        self.archetype_name = archetype
        self.archetype_data = {}   # will hold the full archetype data after applying

        # ... existing base attribute initialization (coords, state, etc.) ...

        # Now apply the archetype (needs engine reference)
        # We'll set engine later, so we'll call apply_archetype after engine is known.
```

Add a method to apply the archetype once the engine is known:

```python
def apply_archetype(self, engine):
    engine.archetype_manager.apply_archetype(self, self.archetype_name)
```

Call this method after adding the particle to the engine, or in a separate initialization step.

3. Ensure components are created

You'll need to extend _create_component in ArchetypeManager to actually instantiate your component classes. As you develop components (Faygo, Madrox, Carnie, etc.), add them there. For now, it will just print a warning and create a generic component.

---

You're absolutely right â€” we don't want to add a new scripted system. The Dialogue Manager should be a thin layer that translates existing particle data (including 5D matrix, mood, arousal, bond strengths, etc.) into emergent, contextâ€‘aware utterances. It's not a library of canned lines; it's a generator that uses templates as skeletons that get filled with dynamic values and can be combined procedurally.

The 5D matrix already defines the particle's personality across five axes: Style, Action, Mood, Attitude, Strategy. These can directly influence which templates are chosen and how they're modified. For example, a particle with high "Style" might prefer more elaborate or poetic phrasings, while one with high "Action" might use short, direct statements. The dialogue manager can use these axes to weight templates or even to generate unique sentence structures.

Bond strengths and rival status can also influence dialogue â€” e.g., a particle speaking to a rival might use more confrontational templates, while speaking to a friend might be warmer. This is all driven by existing data, not new scripts.

Let me provide the revised Dialogue Manager that integrates with the 5D matrix and bond system, and explain how it fits into the existing architecture without adding forced scripts.

---

ðŸ§  Revised Dialogue Manager â€“ Integrated with 5D & Bonds

Key Principles:

Â· No fixed scripts â€“ templates are just parameterized patterns.
Â· Selection is weighted by particle's 5D axes, mood, arousal, and relationship with listener.
Â· Placeholders pull from realâ€‘time stats (energy, bond strength, cause, etc.).
Â· Can combine multiple templates for complex utterances (e.g., Madrox rants).
Â· Templates are stored per archetype, but the archetype already defines the particle's identity â€“ so it's consistent.

---

ðŸ“ File: dlc1/dialogue.py (revised)

```python
# =============================================================================
# DIALOGUE MANAGER â€“ EMERGENT, 5Dâ€‘INTEGRATED SPEECH
# =============================================================================

import os
import json
import random
import math
from typing import Dict, List, Optional, Any

class DialogueManager:
    """
    Generates emergent dialogue based on particle state, 5D matrix, and relationships.
    Templates are weighted by personality axes and mood; placeholders are filled with live data.
    """
    def __init__(self, template_dir: str = "dialogue/"):
        self.template_dir = template_dir
        self.templates: Dict[str, List[Dict[str, Any]]] = {}  # context -> list of template dicts
        self.mood_modifiers: Dict[str, Dict[str, Any]] = {}   # mood -> modifier data
        self.load_all()

    def load_all(self) -> None:
        """Load all JSON files from the template directory."""
        if not os.path.exists(self.template_dir):
            os.makedirs(self.template_dir)
            print(f"Created dialogue directory: {self.template_dir}")
            return

        for filename in os.listdir(self.template_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.template_dir, filename)
                with open(path, 'r') as f:
                    data = json.load(f)
                    # Load contexts
                    for ctx, templates in data.get("contexts", {}).items():
                        self.templates.setdefault(ctx, []).extend(templates)
                    # Load mood modifiers
                    self.mood_modifiers.update(data.get("mood_modifiers", {}))
                    print(f"Loaded dialogue: {filename}")

    def get_response(self, particle: 'Particle', context: str, target: Optional['Particle'] = None, **kwargs) -> str:
        """
        Generate a response for the given context, optionally directed at a target particle.
        Uses particle's 5D matrix, mood, arousal, and bond with target to weight templates.
        """
        templates = self.templates.get(context, [])
        if not templates:
            return "..."

        # Get personality axes (5D) â€“ assume particle.fiveD is a FiveDMatrix with .style, .action, etc.
        fiveD = getattr(particle, 'fiveD', None)
        style = fiveD.style / 100.0 if fiveD else 0.5
        action = fiveD.action / 100.0 if fiveD else 0.5
        mood_axis = fiveD.mood / 100.0 if fiveD else 0.5
        attitude = fiveD.attitude / 100.0 if fiveD else 0.5
        strategy = fiveD.strategy / 100.0 if fiveD else 0.5

        # Mood and arousal
        mood = getattr(particle, 'mood_val', 'neutral')
        arousal = getattr(particle, 'arousal_level', 0) / 5.0  # normalize 0-1

        # Bond with target (if any)
        bond_strength = 0.5
        if target:
            bond = particle.bonds.get(target.uid)
            if bond:
                bond_strength = bond.strength

        # Weighted template selection
        weighted_templates = []
        for t in templates:
            base_weight = t.get("weight", 1.0)

            # Personality modifiers
            # High style prefers elaborate templates (assume a tag "elaborate" in template)
            if "elaborate" in t.get("tags", []) and style > 0.7:
                base_weight *= 1.5
            # High action prefers short, direct templates ("direct" tag)
            if "direct" in t.get("tags", []) and action > 0.7:
                base_weight *= 1.5
            # High mood might prefer emotional templates ("emotional" tag)
            if "emotional" in t.get("tags", []) and mood_axis > 0.7:
                base_weight *= 1.3

            # Mood modifier
            mood_mod = self.mood_modifiers.get(mood, {})
            if context in mood_mod.get("prefer", []):
                base_weight *= mood_mod.get("weight_multiplier", 1.2)

            # Arousal â€“ higher arousal might prefer energetic templates
            if "energetic" in t.get("tags", []) and arousal > 0.7:
                base_weight *= 1.4

            # Bond strength â€“ close bonds might prefer intimate templates ("intimate" tag)
            if "intimate" in t.get("tags", []) and bond_strength > 0.8:
                base_weight *= 1.5
            # Rivals might prefer confrontational templates ("confrontational" tag)
            if "confrontational" in t.get("tags", []) and bond_strength < 0.3:
                base_weight *= 1.5

            weighted_templates.append((t, base_weight))

        # Normalize weights (optional, but helps random selection)
        total = sum(w for _, w in weighted_templates)
        if total <= 0:
            return "..."

        r = random.random() * total
        for t, w in weighted_templates:
            r -= w
            if r <= 0:
                chosen_template = t
                break
        else:
            chosen_template = templates[0]

        # Build placeholders
        placeholders = self._build_placeholders(particle, target, **kwargs)

        # Fill template
        try:
            text = chosen_template["text"].format(**placeholders)
        except KeyError as e:
            print(f"Warning: missing placeholder {e} in template: {chosen_template['text']}")
            text = chosen_template["text"]

        # For Madrox, we might combine multiple templates to simulate rambling
        if context == "madrox_rant" and random.random() < 0.3:
            # Add another random template fragment
            second = random.choice([t for t in templates if t != chosen_template])
            try:
                text += " " + second["text"].format(**placeholders)
            except:
                pass

        return text

    def _build_placeholders(self, particle: 'Particle', target: Optional['Particle'] = None, **kwargs) -> Dict[str, str]:
        """Collect all possible placeholders from particle state, bond, and kwargs."""
        placeholders = {
            "name": particle.name,
            "energy": f"{getattr(particle.state, 'energy', 0):.0f}",
            "valence": str(getattr(particle.state, 'valence', 3)),
            "arousal": str(getattr(particle, 'arousal_level', 0)),
            "cause": getattr(particle, 'madrox_cause', 'something'),
            "fizz": kwargs.get("fizz", "flat"),
        }

        # Add target's name if present
        if target:
            placeholders["target_name"] = target.name
            bond = particle.bonds.get(target.uid)
            if bond:
                placeholders["bond_strength"] = f"{bond.strength:.2f}"
                placeholders["bond_phase"] = str(bond.phase) if hasattr(bond, 'phase') else "unknown"
            else:
                placeholders["bond_strength"] = "0.0"
                placeholders["bond_phase"] = "none"

        # Add 5D values if available
        if hasattr(particle, 'fiveD'):
            placeholders["style"] = str(particle.fiveD.style)
            placeholders["action"] = str(particle.fiveD.action)
            placeholders["mood_axis"] = str(particle.fiveD.mood)
            placeholders["attitude"] = str(particle.fiveD.attitude)
            placeholders["strategy"] = str(particle.fiveD.strategy)

        # Add any extra kwargs
        for k, v in kwargs.items():
            placeholders[k] = str(v)

        return placeholders
```

---

ðŸ“ Example Template with Tags

dialogue/mystic.json (updated):

```json
{
  "contexts": {
    "greeting": [
      {"text": "Hello, {name}. The energies are strong today.", "weight": 1.0, "tags": ["elaborate"]},
      {"text": "Ah, {name}. I've been expecting you.", "weight": 0.7, "tags": ["mysterious"]},
      {"text": "Greetings, traveler.", "weight": 0.5, "tags": ["direct"]}
    ],
    "farewell": [
      {"text": "May the spirits guide you.", "weight": 1.0, "tags": ["blessing"]},
      {"text": "Until we meet again, {name}.", "weight": 0.8, "tags": ["warm"]}
    ],
    "madrox_rant": [
      {"text": "You think you understand? You don't. {cause} demands that I...", "weight": 1.0, "tags": ["confrontational", "emotional"]},
      {"text": "They're all watching. I know it. {cause} is the only truth.", "weight": 0.8, "tags": ["paranoid"]}
    ]
  },
  "mood_modifiers": {
    "angry": {
      "weight_multiplier": 1.2,
      "prefer": ["madrox_rant"]
    },
    "playful": {
      "weight_multiplier": 1.5,
      "prefer": ["greeting"]
    }
  }
}
```

---

ðŸ”§ Integration Notes

Â· The tags field is used to match templates to personality axes. You can define any tags you like â€“ they're just hints.
Â· The fiveD object must be accessible from the particle. If your particle doesn't have a fiveD attribute yet, you'll need to add it (or adapt the code to use whatever personality representation you have).
Â· Bond strength and phase are used to weight templates for intimacy or confrontation.
Â· The manager still doesn't force any dialogue â€“ it simply provides a way for the particle to express its internal state when asked (either by the user or by an event).

This system is fully emergent: the same particle can say different things depending on its current mood, arousal, and relationship with the listener, all driven by the simulation's internal state. No scripts, just dataâ€‘driven expression.

---

ðŸ§± PHASE 2 â€“ FAYGO MODULE

Here is the complete Faygo module. It adds a drinkable item with six modes, fizz decay, and integration with the particle's state, bonds, and the event system.

Features:

Â· InventoryComponent â€“ tracks how many Faygos a particle has and their fizziness.
Â· FaygoMode enum â€“ flat, shook, spray, bathe, hit_in_face, chug.
Â· use_faygo(mode, target) method â€“ applies effects (energy, arousal, anxiety, bond changes, clarity) and posts events.
Â· Fizz decay over time â€“ fresh Faygo becomes flat.
Â· AI decision logic â€“ particles may choose to use Faygo based on personality and context.
Â· Integration with dialogue manager â€“ after using Faygo, particle may comment.
Â· Placeholder for Midway generation (to be linked later).

---

ðŸ“ File: dlc1/faygo.py

```python
# =============================================================================
# FAYGO â€“ THE MAGIC DRINK
# =============================================================================

import random
from enum import Enum
from dlc1.component import Component
from dlc1.constants import (
    FAYGO_FIZZ_FRESH, FAYGO_FIZZ_DECAY, FAYGO_FLAT_THRESHOLD,
    FAYGO_GEN_BASE, FAYGO_GEN_MULTIPLIER
)
from core.event import Event

class FaygoMode(Enum):
    FLAT = "flat"
    SHOOK = "shook"
    SPRAY = "spray"
    BATHE = "bathe"
    HIT_IN_FACE = "hit_in_face"
    CHUG = "chug"

class InventoryComponent(Component):
    """
    Holds items, currently only Faygo.
    """
    def __init__(self):
        super().__init__("inventory")
        self.faygo_count = 0
        self.faygo_fizz = FAYGO_FIZZ_FRESH   # 1.0 = fresh, 0.0 = flat

    def add_faygo(self, count: int = 1):
        """Add one or more Faygos, resetting fizz to fresh."""
        self.faygo_count += count
        self.faygo_fizz = FAYGO_FIZZ_FRESH

    def use_faygo(self, mode: FaygoMode, target=None) -> bool:
        """
        Attempt to use one Faygo. Returns True if successful.
        """
        if self.faygo_count <= 0:
            return False

        self.faygo_count -= 1

        # Post event before applying effects (for other components to react)
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.event_manager.post(Event(
                type="faygo_use",
                source=self.entity,
                target=target,
                data={
                    "mode": mode.value,
                    "fizz": self.faygo_fizz,
                    "flat": self.faygo_fizz < FAYGO_FLAT_THRESHOLD
                }
            ))

        self._apply_effects(mode, target)

        # Optionally, the particle may comment on the experience
        if random.random() < 0.3 and hasattr(self.entity, 'engine'):
            # Use dialogue manager to generate a comment
            context = "faygo_" + mode.value
            comment = self.entity.engine.dialogue_manager.get_response(
                self.entity, context, target=target, fizz=self.faygo_fizz
            )
            if comment != "...":
                # Post a speech event (engine should log or display it)
                self.entity.engine.event_manager.post(Event(
                    type="speech",
                    source=self.entity,
                    target=target,
                    data={"text": comment}
                ))

        return True

    def _apply_effects(self, mode: FaygoMode, target):
        p = self.entity
        if not p:
            return

        flat_bonus = 1.0 if self.faygo_fizz < FAYGO_FLAT_THRESHOLD else 1.5

        if mode == FaygoMode.FLAT:
            # Drink slowly â€“ calm, small energy
            p.energy_econ.gain(10 * flat_bonus)
            p.anx_cur.anxiety = max(0, p.anx_cur.anxiety - 0.2 * flat_bonus)
            # Share with a friend? Not implemented â€“ could be a separate action.

        elif mode == FaygoMode.SHOOK:
            # Shake then drink â€“ energy boost, hyper
            p.energy_econ.gain(20 * flat_bonus)
            p.arousal_level = min(5, p.arousal_level + int(2 * flat_bonus))
            # Temporary speed boost â€“ we can add a status effect later

        elif mode == FaygoMode.SPRAY and target:
            # Spray on another particle â€“ cools them down
            target.energy_econ.spend(5 * flat_bonus)
            target.arousal_level = max(0, target.arousal_level - int(1 * flat_bonus))
            # Bond effect
            if target.uid in p.bonds:
                # Playful gesture might strengthen bond
                p.bonds[target.uid].strengthen(0.05 * flat_bonus)
            else:
                # Could annoy â€“ we could add a small negative, but not for now
                pass

        elif mode == FaygoMode.BATHE:
            # Pour on self â€“ cleanses negative statuses
            p.poison_level = 0
            p.thirst = max(0, p.thirst - 0.5 * flat_bonus)
            # Also reduce anxiety slightly
            p.anx_cur.anxiety = max(0, p.anx_cur.anxiety - 0.1 * flat_bonus)

        elif mode == FaygoMode.HIT_IN_FACE and target:
            # Aggressive throw â€“ energy loss, may provoke rivalry
            target.energy_econ.spend(15 * flat_bonus)
            if random.random() < 0.3 * flat_bonus:
                # Start a rivalry if not already (simplified)
                # We can post an event for the Madrox component to notice
                p.engine.event_manager.post(Event(
                    type="provoke",
                    source=p,
                    target=target,
                    data={"reason": "faygo_hit"}
                ))

        elif mode == FaygoMode.CHUG:
            # Chug the whole thing â€“ big energy, risk of brain freeze
            p.energy_econ.gain(30 * flat_bonus)
            if random.random() < 0.2 * flat_bonus:
                # Brain freeze â€“ temporary clarity reduction
                if hasattr(p, 'scg') and p.scg:
                    p.scg.clarity_score = max(0, p.scg.clarity_score * 0.8)
                # Also maybe a burp that affects nearby particles? Not implemented.

    def update(self, tick):
        """Fizz decays over time if we have any Faygo."""
        if self.faygo_count > 0:
            self.faygo_fizz = max(0, self.faygo_fizz - FAYGO_FIZZ_DECAY)


# -----------------------------------------------------------------------------
# AI DECISION LOGIC (to be integrated into Particle.decide_action)
# -----------------------------------------------------------------------------

def should_use_faygo(particle) -> bool:
    """
    Determine if a particle should use a Faygo this tick.
    Called from decide_action.
    """
    inv = particle.get_component("inventory")
    if not inv or inv.faygo_count <= 0:
        return False

    # Conditions for wanting to use Faygo
    # 1. Low energy and not in danger
    if particle.energy < 30 and particle.anx_cur.anxiety < 0.5:
        return random.random() < 0.3

    # 2. High arousal and playful personality
    if particle.arousal_level > 3 and particle.stats.playfulness > 60:
        return random.random() < 0.4

    # 3. Bored and at a festival
    if particle.boredom_state >= 2 and hasattr(particle, 'x'):
        # Check if on a midway tile (simplified â€“ actual check depends on engine)
        if random.random() < 0.1:
            return True

    # 4. Madrox state â€“ might chug to cope
    madrox = particle.get_component("madrox")
    if madrox and madrox.active and random.random() < 0.2:
        return True

    return False


def choose_faygo_mode(particle, target=None) -> FaygoMode:
    """
    Choose a Faygo mode based on personality and situation.
    """
    inv = particle.get_component("inventory")
    flat_chance = 0.1 if inv.faygo_fizz < FAYGO_FLAT_THRESHOLD else 0.01

    # Personality influences
    playful = particle.stats.playfulness > 60
    aggressive = particle.genes.get('aggression', 0.5) > 0.6
    anxious = particle.anx_cur.anxiety > 0.6

    modes = []

    # Always possible
    if random.random() < flat_chance:
        modes.append(FaygoMode.FLAT)

    # Playful personalities like shook and spray
    if playful:
        modes.append(FaygoMode.SHOOK)
        if target:
            modes.append(FaygoMode.SPRAY)

    # Aggressive personalities like hit_in_face
    if aggressive and target:
        modes.append(FaygoMode.HIT_IN_FACE)

    # Anxious particles might bathe to calm down
    if anxious:
        modes.append(FaygoMode.BATHE)

    # Chug is for the bold (high energy, low anxiety)
    if particle.energy > 70 and particle.anx_cur.anxiety < 0.4:
        modes.append(FaygoMode.CHUG)

    # If no modes selected, default to flat or shook
    if not modes:
        return FaygoMode.FLAT if random.random() < 0.5 else FaygoMode.SHOOK

    return random.choice(modes)
```

---

ðŸ”§ Integration Instructions

1. Add the USE_FAYGO action

In your ActionType enum (likely in core/__init__.py or similar), add:

```python
USE_FAYGO = "use_faygo"
```

In ACTION_COST (a dict mapping actions to energy cost), add:

```python
ACTION_COST[ActionType.USE_FAYGO] = 0   # uses item, not energy
```

2. Add the USE_FAYGO action to decide_action

In Particle.decide_action, after generating the base candidates, add a chance to use Faygo:

```python
from dlc1.faygo import should_use_faygo, choose_faygo_mode

def decide_action(self):
    candidates = []   # existing candidate generation

    # ... existing code ...

    # Check if we should use Faygo
    if should_use_faygo(self):
        mode = choose_faygo_mode(self)
        # We need a target for spray/hit â€“ find a nearby particle
        target = None
        if mode in (FaygoMode.SPRAY, FaygoMode.HIT_IN_FACE):
            nearby = [e for e in self.engine.social_hub.entities
                      if e != self and e.alive and abs(e.x-self.x)+abs(e.y-self.y) <= 2]
            if nearby:
                target = random.choice(nearby)
            else:
                # Can't use spray/hit without target, fall back to other mode
                mode = random.choice([FaygoMode.FLAT, FaygoMode.SHOOK, FaygoMode.CHUG])
        candidates.append((ActionType.USE_FAYGO, 2.0))   # high weight when condition met
        # Store mode and target for later execution (e.g., in perform_action)

    # ... rest of decision ...
```

In perform_action, handle the USE_FAYGO action:

```python
def perform_action(self, action, target=None):
    if action == ActionType.USE_FAYGO:
        inv = self.get_component("inventory")
        if inv:
            # Retrieve the mode chosen earlier (you need to store it, e.g., in self._pending_faygo_mode)
            mode = getattr(self, '_pending_faygo_mode', FaygoMode.FLAT)
            return inv.use_faygo(mode, target)
    # ... other actions ...
```

3. Add InventoryComponent to particles by default

In Particle.__init__, after initializing components:

```python
self.add_component("inventory", InventoryComponent())
```

4. Ensure particle has access to stats.playfulness and genes

These should already be present. If not, you may need to add them.

5. (Optional) Add dialogue templates for Faygo contexts

Add to your archetype dialogue files contexts like faygo_flat, faygo_shook, etc., with tags that match personality preferences. Example:

```json
"faygo_chug": [
  {"text": "*gulp* WHOO! That hit the spot!", "weight": 1.0, "tags": ["energetic"]},
  {"text": "Brain freeze! Ugh...", "weight": 0.3, "tags": ["silly"]}
]
```

The dialogue manager will automatically fill placeholders.

---

ðŸ§± PHASE 2 â€“ FAYGO MODULE (with Flavor System)

This updated Faygo module integrates the full flavor system, including the Fireworks Mix Formula. Each Faygo now has a flavor (one of six) and can be used in one of the six usage modes (flat, shook, spray, bathe, hit_in_face, chug). The flavor modifies the effects of the mode, creating deep strategic interactions.

---

ðŸ¬ Faygo Flavor Enum

```python
from enum import Enum

class FaygoFlavor(Enum):
    WATERMELON = "watermelon"   # Red â€“ burst, high amplitude, short duration
    PINEAPPLE = "pineapple"     # Blue â€“ sequencing, control
    GRAPE = "grape"             # Black â€“ stored weight, delayed advantage
    ORANGE = "orange"           # White â€“ symmetry, invariant
    ROOT_BEER = "root_beer"     # Green â€“ embedding, slow internal growth
    COTTON_CANDY = "cotton_candy" # Modifier â€“ variance injection, perceived sweetness
    # RED_POP is rejected per note â€“ we omit it
```

---

ðŸŽ† Fireworks Mix Formula

When two particles use Faygo of complementary flavors in close proximity (same tile within a short time window), a special combined effect triggers.

```python
FIREWORKS_MIX = {
    (FaygoFlavor.WATERMELON, FaygoFlavor.PINEAPPLE): "Tactical Spike",
    (FaygoFlavor.WATERMELON, FaygoFlavor.GRAPE): "Emotional Debt",
    (FaygoFlavor.PINEAPPLE, FaygoFlavor.GRAPE): "Hidden Advantage",
    (FaygoFlavor.GRAPE, FaygoFlavor.ORANGE): "Ledgered Law",
    (FaygoFlavor.WATERMELON, FaygoFlavor.ORANGE): "Clean Combat",
}
```

---

ðŸ“ Updated dlc1/faygo.py

```python
# =============================================================================
# FAYGO â€“ THE MAGIC DRINK (with Flavor System)
# =============================================================================

import random
from enum import Enum
from dlc1.component import Component
from dlc1.constants import (
    FAYGO_FIZZ_FRESH, FAYGO_FIZZ_DECAY, FAYGO_FLAT_THRESHOLD,
    FAYGO_GEN_BASE, FAYGO_GEN_MULTIPLIER
)
from core.event import Event

class FaygoMode(Enum):
    FLAT = "flat"
    SHOOK = "shook"
    SPRAY = "spray"
    BATHE = "bathe"
    HIT_IN_FACE = "hit_in_face"
    CHUG = "chug"

class FaygoFlavor(Enum):
    WATERMELON = "watermelon"
    PINEAPPLE = "pineapple"
    GRAPE = "grape"
    ORANGE = "orange"
    ROOT_BEER = "root_beer"
    COTTON_CANDY = "cotton_candy"

# Fireworks mix formula
FIREWORKS_MIX = {
    (FaygoFlavor.WATERMELON, FaygoFlavor.PINEAPPLE): "Tactical Spike",
    (FaygoFlavor.WATERMELON, FaygoFlavor.GRAPE): "Emotional Debt",
    (FaygoFlavor.PINEAPPLE, FaygoFlavor.GRAPE): "Hidden Advantage",
    (FaygoFlavor.GRAPE, FaygoFlavor.ORANGE): "Ledgered Law",
    (FaygoFlavor.WATERMELON, FaygoFlavor.ORANGE): "Clean Combat",
}

class InventoryComponent(Component):
    """
    Holds items â€“ now each Faygo has a flavor.
    """
    def __init__(self):
        super().__init__("inventory")
        self.faygos = []  # list of (flavor, fizz) tuples
        # fizz is per bottle, so each bottle has its own fizz level

    def add_faygo(self, flavor: FaygoFlavor = None, count: int = 1):
        """Add one or more Faygos of a given flavor. If flavor is None, choose random."""
        for _ in range(count):
            if flavor is None:
                flavor = random.choice(list(FaygoFlavor))
            self.faygos.append({
                'flavor': flavor,
                'fizz': FAYGO_FIZZ_FRESH
            })

    def use_faygo(self, mode: FaygoMode, target=None) -> bool:
        """Use the oldest Faygo (simple FIFO). Returns True if successful."""
        if not self.faygos:
            return False

        faygo = self.faygos.pop(0)  # take the oldest
        flavor = faygo['flavor']
        fizz = faygo['fizz']

        # Post event before applying effects
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.event_manager.post(Event(
                type="faygo_use",
                source=self.entity,
                target=target,
                data={
                    "mode": mode.value,
                    "flavor": flavor.value,
                    "fizz": fizz,
                    "flat": fizz < FAYGO_FLAT_THRESHOLD
                }
            ))

        self._apply_effects(flavor, mode, target, fizz)

        # Possibly trigger a fireworks mix if another particle used Faygo nearby recently
        self._check_fireworks(target, flavor, mode)

        # Optional dialogue
        if random.random() < 0.3 and hasattr(self.entity, 'engine'):
            context = f"faygo_{mode.value}"
            comment = self.entity.engine.dialogue_manager.get_response(
                self.entity, context, target=target,
                flavor=flavor.value, fizz=fizz
            )
            if comment != "...":
                self.entity.engine.event_manager.post(Event(
                    type="speech",
                    source=self.entity,
                    target=target,
                    data={"text": comment}
                ))

        return True

    def _apply_effects(self, flavor: FaygoFlavor, mode: FaygoMode, target, fizz: float):
        """Apply effects based on flavor and mode."""
        p = self.entity
        if not p:
            return

        flat_bonus = 1.0 if fizz < FAYGO_FLAT_THRESHOLD else 1.5

        # Base effects from mode (as before)
        # These will be modified by flavor
        base_effects = self._get_base_effects(mode, target, flat_bonus)

        # Apply flavor modifiers
        self._apply_flavor_modifiers(flavor, base_effects, target, fizz)

    def _get_base_effects(self, mode, target, flat_bonus):
        """Return a dict of base effect magnitudes (to be modified by flavor)."""
        p = self.entity
        effects = {
            'energy_self': 0,
            'energy_target': 0,
            'arousal_self': 0,
            'arousal_target': 0,
            'anxiety_self': 0,
            'bond_change': 0,
            'clarity_change': 0,
            'poison_self': 0,
            'thirst_self': 0,
        }

        if mode == FaygoMode.FLAT:
            effects['energy_self'] = 10 * flat_bonus
            effects['anxiety_self'] = -0.2 * flat_bonus
        elif mode == FaygoMode.SHOOK:
            effects['energy_self'] = 20 * flat_bonus
            effects['arousal_self'] = 2 * flat_bonus
        elif mode == FaygoMode.SPRAY and target:
            effects['energy_target'] = -5 * flat_bonus
            effects['arousal_target'] = -1 * flat_bonus
            effects['bond_change'] = 0.05 * flat_bonus if target.uid in p.bonds else 0
        elif mode == FaygoMode.BATHE:
            effects['poison_self'] = -1  # remove poison completely
            effects['thirst_self'] = -0.5 * flat_bonus
            effects['anxiety_self'] = -0.1 * flat_bonus
        elif mode == FaygoMode.HIT_IN_FACE and target:
            effects['energy_target'] = -15 * flat_bonus
            # provoke chance handled separately
        elif mode == FaygoMode.CHUG:
            effects['energy_self'] = 30 * flat_bonus
            if random.random() < 0.2 * flat_bonus:
                effects['clarity_change'] = -0.2  # brain freeze

        return effects

    def _apply_flavor_modifiers(self, flavor, effects, target, fizz):
        """Modify base effects according to flavor."""
        p = self.entity
        flat_bonus = 1.0 if fizz < FAYGO_FLAT_THRESHOLD else 1.5

        # Watermelon (Red) â€“ burst, high amplitude, short duration
        if flavor == FaygoFlavor.WATERMELON:
            effects['energy_self'] *= 1.5
            effects['arousal_self'] *= 1.5
            # Duration not directly represented â€“ could add temporary buff later

        # Pineapple (Blue) â€“ sequencing, control
        elif flavor == FaygoFlavor.PINEAPPLE:
            # Pineapple gives more control: less random variation, maybe boost bond effects
            effects['bond_change'] *= 1.3
            # Reduce negative effects
            if effects['energy_target'] < 0:
                effects['energy_target'] *= 0.8  # less harmful
            if effects['arousal_target'] < 0:
                effects['arousal_target'] *= 0.8

        # Grape (Black) â€“ stored weight, delayed advantage
        elif flavor == FaygoFlavor.GRAPE:
            # Instead of immediate effects, store some as "debt" for later
            # We'll add a new component for stored weight
            # For now, simply increase energy gain over time? Not implemented.
            # We'll just make effects less immediate but give a memory
            effects['energy_self'] *= 0.7
            # Add a delayed effect marker (placeholder)
            if hasattr(p, 'grimoire'):
                p.grimoire.add_memory("You feel a grape debt forming...", importance=0.3)

        # Orange (White) â€“ symmetry, invariant
        elif flavor == FaygoFlavor.ORANGE:
            # Make effects more predictable (reduce randomness)
            # For now, just make all effects consistent (no random variations)
            # Also may strengthen rules-based effects
            pass

        # Root Beer (Green) â€“ embedding, slow internal growth
        elif flavor == FaygoFlavor.ROOT_BEER:
            # Effects are slower but longer-lasting â€“ for now, reduce immediate but add a regen buff
            effects['energy_self'] *= 0.5
            # Add a small regeneration over time (we could implement a status effect)
            if hasattr(p, 'energy_econ'):
                # Simple: just give a bit more over the next few ticks (simulate)
                p.energy_econ.gain(5)  # one-time extra

        # Cotton Candy (Modifier) â€“ variance injection, perceived sweetness
        elif flavor == FaygoFlavor.COTTON_CANDY:
            # High variance: multiply random aspects
            # For example, bond change could be doubled or halved randomly
            if 'bond_change' in effects and effects['bond_change'] != 0:
                effects['bond_change'] *= random.choice([0.5, 1.5])
            # Energy could also vary
            effects['energy_self'] *= random.uniform(0.8, 1.5)

        # Apply the modified effects
        self._apply_effect_dict(effects, target)

    def _apply_effect_dict(self, effects, target):
        p = self.entity
        if effects['energy_self'] != 0:
            p.energy_econ.gain(effects['energy_self'])
        if effects['energy_target'] != 0 and target:
            target.energy_econ.spend(-effects['energy_target'])  # gain if negative?
        if effects['arousal_self'] != 0:
            p.arousal_level = max(0, min(5, p.arousal_level + int(effects['arousal_self'])))
        if effects['arousal_target'] != 0 and target:
            target.arousal_level = max(0, min(5, target.arousal_level + int(effects['arousal_target'])))
        if effects['anxiety_self'] != 0:
            p.anx_cur.anxiety = max(0, min(1, p.anx_cur.anxiety + effects['anxiety_self']))
        if effects['bond_change'] != 0 and target and target.uid in p.bonds:
            if effects['bond_change'] > 0:
                p.bonds[target.uid].strengthen(effects['bond_change'])
            else:
                p.bonds[target.uid].weaken(-effects['bond_change'])
        if effects['clarity_change'] != 0 and hasattr(p, 'scg') and p.scg:
            p.scg.clarity_score = max(0, min(1, p.scg.clarity_score + effects['clarity_change']))
        if effects['poison_self'] < 0:
            p.poison_level = 0
        if effects['thirst_self'] < 0:
            p.thirst = max(0, p.thirst + effects['thirst_self'])

    def _check_fireworks(self, target, flavor, mode):
        """
        Check if this Faygo use can combine with a recent use by another particle.
        """
        if not target or not hasattr(self.entity, 'engine'):
            return
        # Look for recent Faygo use events from target within a short window
        # This would require the event manager to have a history, or we could store last use time.
        # Simplified: we just check if target also used Faygo in the same tick (unlikely)
        # Instead, we could store a timestamp in the engine's memory.
        # For now, we'll leave fireworks as a future enhancement.
        pass

    def update(self, tick):
        """Fizz decays for all stored Faygos."""
        for f in self.faygos:
            f['fizz'] = max(0, f['fizz'] - FAYGO_FIZZ_DECAY)
```

---

ðŸ”§ Integration Instructions

1. Update InventoryComponent usage in particle

The add_faygo method now requires a flavor. In your game, when a particle finds a Faygo, you'll need to generate a random flavor (or use the Midway's cover crop to bias flavors). For testing, you can just call inv.add_faygo(FaygoFlavor.WATERMELON).

2. Update AI decision for Faygo use

In choose_faygo_mode, you might also consider flavor preference based on personality (e.g., aggressive particles prefer Watermelon, controlling particles prefer Pineapple). You can extend the function to pick a flavor from inventory, not just mode.

3. Dialogue templates

Add contexts like faygo_watermelon, faygo_pineapple, etc., to allow particles to comment on the flavor they just used.

4. Fireworks mix implementation

To fully implement fireworks, we need a way to detect when two particles use complementary flavors near each other within a short time window. This could be done by storing the last Faygo use for each particle (flavor and tick) in the engine, and when a new use occurs, check nearby particles for a matching pair. Then trigger a special event. We'll implement this in a future update.

---

ðŸ§ª Testing the Flavor System

1. Give a particle a Faygo of a specific flavor.
2. Have the particle use it in a mode (e.g., CHUG).
3. Observe the effects (energy change, arousal, etc.) and verify they match the flavor's modifiers.
4. Try different flavorâ€“mode combinations to see the variety.

---
We'll build DLC 1 as a selfâ€‘contained package that plugs into your existing base engine (the one from Here.txt). Below is the complete, readyâ€‘toâ€‘ship code for all DLC 1 systems, split into logical files. Place these in a folder named dlc1 and follow the integration instructions at the end.

---

ðŸ“ File: dlc1/init.py

```python
# DLC 1: THE MISSING LINK â€“ Package Initializer
from .component import Component, ComponentHolder
from .event import Event, EventManager
from .archetype import ArchetypeManager
from .dialogue import DialogueManager
from .faygo import InventoryComponent, FaygoMode, FaygoFlavor, FIREWORKS_MIX, should_use_faygo, choose_faygo_mode
from .madrox import MadroxComponent
from .carnie import CarnieComponent, CarnieMode
from .dangerstate import DangerStateComponent, DangerState
from .magnetic import MagneticFieldsSystem
from .rumor import Rumor, RumorManager
from .midway import MidwayBiome, CoverCropType, FIELD_CONTRIBUTIONS, STAGE_MULTIPLIERS, CONSENT_BONUS
from .juggalo import JuggaloParty, JuggaloPartyManager
from .cop import CopMoment

__all__ = [
    'Component', 'ComponentHolder',
    'Event', 'EventManager',
    'ArchetypeManager',
    'DialogueManager',
    'InventoryComponent', 'FaygoMode', 'FaygoFlavor', 'FIREWORKS_MIX', 'should_use_faygo', 'choose_faygo_mode',
    'MadroxComponent',
    'CarnieComponent', 'CarnieMode',
    'DangerStateComponent', 'DangerState',
    'MagneticFieldsSystem',
    'Rumor', 'RumorManager',
    'MidwayBiome', 'CoverCropType', 'FIELD_CONTRIBUTIONS', 'STAGE_MULTIPLIERS', 'CONSENT_BONUS',
    'JuggaloParty', 'JuggaloPartyManager',
    'CopMoment'
]
```

---

ðŸ“ File: dlc1/component.py

```python
# =============================================================================
# COMPONENT SYSTEM â€“ BASE CLASSES
# =============================================================================

class Component:
    """
    Base class for all components.
    Components are attached to an entity (e.g., a Particle) and provide modular behavior.
    """
    def __init__(self, name):
        self.name = name
        self.entity = None  # reference to the owning entity, set on attach

    def on_attach(self, entity):
        """Called when this component is added to an entity."""
        self.entity = entity

    def on_detach(self):
        """Called when this component is removed from an entity."""
        self.entity = None

    def update(self, tick):
        """
        Called every simulation tick.
        Override in subclasses to implement perâ€‘tick behavior.
        """
        pass

    def handle_event(self, event):
        """
        Called when an event is dispatched.
        Return True if the event was handled and should not be passed to other components.
        """
        return False


class ComponentHolder:
    """
    Mixin for entities that can hold components.
    Add this as a base class to your entity class.
    """
    def __init__(self):
        self.components = {}  # name -> Component

    def add_component(self, name, component):
        """Attach a component to this entity."""
        component.on_attach(self)
        self.components[name] = component

    def remove_component(self, name):
        """Detach a component by name."""
        if name in self.components:
            self.components[name].on_detach()
            del self.components[name]

    def get_component(self, name):
        """Retrieve a component by name, or None if not present."""
        return self.components.get(name)

    def update_components(self, tick):
        """Call update on all attached components."""
        for comp in self.components.values():
            comp.update(tick)

    def dispatch_event_to_components(self, event):
        """
        Send an event to all components, stopping if one handles it.
        Returns True if any component handled the event.
        """
        for comp in self.components.values():
            if comp.handle_event(event):
                return True
        return False
```

---

ðŸ“ File: dlc1/event.py

```python
# =============================================================================
# EVENT SYSTEM â€“ GLOBAL EVENT BUS
# =============================================================================

from collections import defaultdict
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional

@dataclass
class Event:
    """Represents an event in the simulation."""
    type: str                       # e.g., "faygo_use", "bond_change", "tile_entered"
    source: Optional[Any] = None    # the object that triggered the event (e.g., a particle)
    target: Optional[Any] = None    # the primary target, if any
    data: Dict[str, Any] = field(default_factory=dict)  # additional information


class EventManager:
    """
    Manages event subscriptions and dispatches events to all registered listeners.
    """
    def __init__(self):
        self._listeners: Dict[str, List[Callable[[Event], None]]] = defaultdict(list)
        self.history: List[Event] = []
        self.max_history = 1000

    def subscribe(self, event_type: str, callback: Callable[[Event], None]) -> None:
        """
        Register a callback to be called when an event of the given type is posted.
        """
        self._listeners[event_type].append(callback)

    def unsubscribe(self, event_type: str, callback: Callable[[Event], None]) -> None:
        """
        Remove a previously registered callback.
        """
        if callback in self._listeners[event_type]:
            self._listeners[event_type].remove(callback)

    def post(self, event: Event) -> None:
        """
        Dispatch an event to all listeners subscribed to its type.
        """
        self.history.append(event)
        if len(self.history) > self.max_history:
            self.history.pop(0)

        for cb in self._listeners.get(event.type, []):
            try:
                cb(event)
            except Exception as e:
                print(f"[EventManager] Error in callback for {event.type}: {e}")

    def get_recent(self, event_type: str = None, limit: int = 10) -> List[Event]:
        """
        Get recent events, optionally filtered by type.
        """
        if event_type:
            filtered = [e for e in self.history if e.type == event_type]
            return filtered[-limit:]
        return self.history[-limit:]
```

---

ðŸ“ File: dlc1/constants.py

```python
# =============================================================================
# DLC 1: THE MISSING LINK â€“ CONSTANTS
# =============================================================================

# --- Magnetic Fields ---
MADROX_FIELD_RADIUS = 12
CALM_FIELD_RADIUS = 15
MADROX_OPTIMAL_DIST = 6
MADROX_INNER_RADIUS = 3
MADROX_OUTER_RADIUS = 12
CALM_BASE_RATE = 0.01
MONOXIDE_CALM_STRENGTH = 1.0
CALM_BASE_STRENGTH = 0.3

# --- Madrox State ---
MADROX_MAX_DURATION = 500
MADROX_BIAS_MULTIPLIER = 1.5
MADROX_CHILL_DURATION = 50

# --- Carnie ---
CARNIE_DEPLOYMENT_VARIANCE_THRESHOLD = 0.2
CARNIE_DEPLOYMENT_MIN_TICKS = 200
CARNIE_WORKING_ENERGY_DRAIN = 0.1
CARNIE_SMOKE_BREAK_MIN = 30
CARNIE_SMOKE_BREAK_MAX = 100

# --- Faygo ---
FAYGO_FRESH_DURATION = 100          # ticks until flat
FAYGO_FIZZ_FRESH = 1.0
FAYGO_FIZZ_DECAY = 0.01
FAYGO_FLAT_THRESHOLD = 0.3
FAYGO_GEN_BASE = 1
FAYGO_GEN_MULTIPLIER = 2

# Faygo effects (base, before flavor)
FAYGO_EFFECTS = {
    "flat": {"energy": 10, "anxiety": -0.2},
    "shook": {"energy": 20, "arousal": 2},
    "spray": {"target_energy": -5, "target_arousal": -1},
    "bathe": {"cleanse": True, "thirst": -0.5, "anxiety": -0.1},
    "hit_in_face": {"target_energy": -15},
    "chug": {"energy": 30}
}

# --- The Midway ---
MIDWAY_RADIUS = 3
MIDWAY_POWER_DECAY = 0.001
MIDWAY_BASE_FIELD = 10
MIDWAY_MAX_FIELD = 100
RESIDUE_DURATION = 200

# Cover crop types (from the color pie document)
COVER_CROP_TYPES = {
    "CLOVER": {"faygo_boost": 1.5, "energy_regen": 0.1},
    "BORAGE": {"gossip_boost": 1.5},
    "COMFREY": {"nutrient_pump": True},
    "BUCKWHEAT": {"pest_suppression": 0.7, "rivalry_suppress": True},
    "TILLAGE_RADISH": {"movement_cost": -0.3, "path_permanence": True},
    "VETCH": {"compound_benefit": True},
    "MUSTARD": {"disease_resist": 0.5},
    "SORGHUM_SUDAN": {"power_growth": 1.5, "lush_bonus": True}
}

# --- Midway Field Strength ---
FIELD_DECAY_RATE = 0.01
FIELD_LOW_THRESHOLD = 5
FIELD_HIGH_THRESHOLD = 50

FIELD_CONTRIBUTIONS = {
    "GAME": 1,
    "FAYGO_FLAT": 1,
    "FAYGO_SHOOK": 2,
    "FAYGO_SPRAY": 2,
    "FAYGO_CHUG": 3,
    "COP_MOMENT": 5,
    "CARNIE_WORKING": 0.5,
    "CARNIE_SMOKE": 0.2
}

STAGE_MULTIPLIERS = {
    "MAIN": 1.0,
    "SIDE1": 1.5,
    "SIDE2": 0.5,
    "SIDE3": 2.0
}

CONSENT_BONUS = 0.2

# --- Juggalo Party ---
PARTY_RADIUS_BASE = 5
PARTY_MIN_PARTICIPANTS = 3
PARTY_TIMEOUT = 50
PARTY_GROWTH_PER_TICK = 1
PARTY_GROWTH_DECAY_TICKS = 50
PARTY_TEMP_DECAY = 0.1
PULL_RADIUS_MULTIPLIER = 2
PULL_BASE_CHANCE = 0.05

PARTY_GROWTH_CONTRIBUTIONS = {
    "GAME": 5,
    "FAYGO": 3,
    "NEW_BOND": 10,
    "WIN_CHALLENGE": 8,
    "COP_MOMENT": 15,
    "CHEER": 2,
    "BUY_ROUND": 20
}

PARTY_BENEFITS = {
    1: {"radius": 5, "bond_mult": 1.2, "curiosity": 0.05, "energy_regen": 0.1},
    2: {"radius": 6, "bond_mult": 1.4, "curiosity": 0.10, "energy_regen": 0.2},
    3: {"radius": 7, "bond_mult": 1.6, "curiosity": 0.15, "energy_regen": 0.3},
    4: {"radius": 8, "bond_mult": 1.8, "curiosity": 0.20, "energy_regen": 0.4},
    5: {"radius": 10, "bond_mult": 2.0, "curiosity": 0.25, "energy_regen": 0.5, "veteran_trait": True}
}

# --- Danger Zone States ---
DANGER_STATE_DURATIONS = {
    "GET_CLOWNED": (50, 150),
    "JUGGALO_PARTY": (30, 100),
    "THE_MIDWAY": None,  # until win/lose
    "LOST_AT_THE_CARNIVAL": None,  # until reconnection
    "I_FUCKED_A_COP": (100, 300)
}

# --- Legendary Party Spots ---
LEGENDARY_POWER_DECAY = 0.001
LEGENDARY_POWER_INCREASE_VISIT = 0.01
LEGENDARY_POWER_DECREASE_CHICKEN = 0.1
LEGENDARY_POWER_DECREASE_JUFF = 0.15
LEGENDARY_POWER_DECREASE_SKEPTIC = 0.05
LEGENDARY_POWER_THRESHOLD = 1.0

# --- Faygo Flavor Enum (for color pie integration) ---
FAYGO_FLAVORS = ["WATERMELON", "PINEAPPLE", "GRAPE", "ORANGE", "ROOT_BEER", "COTTON_CANDY"]

# Fireworks mix formula
FIREWORKS_MIX = {
    ("WATERMELON", "PINEAPPLE"): "Tactical Spike",
    ("WATERMELON", "GRAPE"): "Emotional Debt",
    ("PINEAPPLE", "GRAPE"): "Hidden Advantage",
    ("GRAPE", "ORANGE"): "Ledgered Law",
    ("WATERMELON", "ORANGE"): "Clean Combat",
}
```

---

ðŸ“ File: dlc1/faygo.py

```python
# =============================================================================
# FAYGO â€“ THE MAGIC DRINK (with Flavor System)
# =============================================================================

import random
from enum import Enum
from .component import Component
from .constants import (
    FAYGO_FIZZ_FRESH, FAYGO_FIZZ_DECAY, FAYGO_FLAT_THRESHOLD,
    FAYGO_GEN_BASE, FAYGO_GEN_MULTIPLIER, FAYGO_FLAVORS,
    FIREWORKS_MIX, FIELD_CONTRIBUTIONS
)
from .event import Event

class FaygoMode(Enum):
    FLAT = "flat"
    SHOOK = "shook"
    SPRAY = "spray"
    BATHE = "bathe"
    HIT_IN_FACE = "hit_in_face"
    CHUG = "chug"

class FaygoFlavor(Enum):
    WATERMELON = "watermelon"
    PINEAPPLE = "pineapple"
    GRAPE = "grape"
    ORANGE = "orange"
    ROOT_BEER = "root_beer"
    COTTON_CANDY = "cotton_candy"


class InventoryComponent(Component):
    """
    Holds items â€“ now each Faygo has a flavor.
    """
    def __init__(self):
        super().__init__("inventory")
        self.faygos = []  # list of (flavor, fizz) tuples

    def add_faygo(self, flavor: FaygoFlavor = None, count: int = 1):
        """Add one or more Faygos of a given flavor. If flavor is None, choose random."""
        for _ in range(count):
            if flavor is None:
                flavor = random.choice(list(FaygoFlavor))
            self.faygos.append({
                'flavor': flavor,
                'fizz': FAYGO_FIZZ_FRESH
            })

    def use_faygo(self, mode: FaygoMode, target=None) -> bool:
        """Use the oldest Faygo (simple FIFO). Returns True if successful."""
        if not self.faygos:
            return False

        faygo = self.faygos.pop(0)  # take the oldest
        flavor = faygo['flavor']
        fizz = faygo['fizz']

        # Post event before applying effects
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.event_manager.post(Event(
                type="faygo_use",
                source=self.entity,
                target=target,
                data={
                    "mode": mode.value,
                    "flavor": flavor.value,
                    "fizz": fizz,
                    "flat": fizz < FAYGO_FLAT_THRESHOLD
                }
            ))

        self._apply_effects(flavor, mode, target, fizz)

        # Possibly trigger a fireworks mix if another particle used Faygo nearby recently
        self._check_fireworks(target, flavor, mode)

        # Optional dialogue
        if random.random() < 0.3 and hasattr(self.entity, 'engine'):
            context = f"faygo_{mode.value}"
            comment = self.entity.engine.dialogue_manager.get_response(
                self.entity, context, target=target,
                flavor=flavor.value, fizz=fizz
            )
            if comment != "...":
                self.entity.engine.event_manager.post(Event(
                    type="speech",
                    source=self.entity,
                    target=target,
                    data={"text": comment}
                ))

        return True

    def _apply_effects(self, flavor: FaygoFlavor, mode: FaygoMode, target, fizz: float):
        """Apply effects based on flavor and mode."""
        p = self.entity
        if not p:
            return

        flat_bonus = 1.0 if fizz < FAYGO_FLAT_THRESHOLD else 1.5

        # Base effects from mode
        base_effects = self._get_base_effects(mode, target, flat_bonus)

        # Apply flavor modifiers
        self._apply_flavor_modifiers(flavor, base_effects, target, fizz)

    def _get_base_effects(self, mode, target, flat_bonus):
        """Return a dict of base effect magnitudes (to be modified by flavor)."""
        p = self.entity
        effects = {
            'energy_self': 0,
            'energy_target': 0,
            'arousal_self': 0,
            'arousal_target': 0,
            'anxiety_self': 0,
            'bond_change': 0,
            'clarity_change': 0,
            'poison_self': 0,
            'thirst_self': 0,
        }

        if mode == FaygoMode.FLAT:
            effects['energy_self'] = 10 * flat_bonus
            effects['anxiety_self'] = -0.2 * flat_bonus
        elif mode == FaygoMode.SHOOK:
            effects['energy_self'] = 20 * flat_bonus
            effects['arousal_self'] = 2 * flat_bonus
        elif mode == FaygoMode.SPRAY and target:
            effects['energy_target'] = -5 * flat_bonus
            effects['arousal_target'] = -1 * flat_bonus
            if target.uid in p.bonds:
                effects['bond_change'] = 0.05 * flat_bonus
        elif mode == FaygoMode.BATHE:
            effects['poison_self'] = -1
            effects['thirst_self'] = -0.5 * flat_bonus
            effects['anxiety_self'] = -0.1 * flat_bonus
        elif mode == FaygoMode.HIT_IN_FACE and target:
            effects['energy_target'] = -15 * flat_bonus
            # provoke chance handled separately
        elif mode == FaygoMode.CHUG:
            effects['energy_self'] = 30 * flat_bonus
            if random.random() < 0.2 * flat_bonus:
                effects['clarity_change'] = -0.2

        return effects

    def _apply_flavor_modifiers(self, flavor, effects, target, fizz):
        """Modify base effects according to flavor."""
        p = self.entity
        flat_bonus = 1.0 if fizz < FAYGO_FLAT_THRESHOLD else 1.5

        if flavor == FaygoFlavor.WATERMELON:
            effects['energy_self'] *= 1.5
            effects['arousal_self'] *= 1.5

        elif flavor == FaygoFlavor.PINEAPPLE:
            effects['bond_change'] *= 1.3
            if effects['energy_target'] < 0:
                effects['energy_target'] *= 0.8
            if effects['arousal_target'] < 0:
                effects['arousal_target'] *= 0.8

        elif flavor == FaygoFlavor.GRAPE:
            effects['energy_self'] *= 0.7
            if hasattr(p, 'grimoire'):
                p.grimoire.update({"memory": "grape debt"}, is_vivid=True)

        elif flavor == FaygoFlavor.ORANGE:
            # Reduce randomness â€“ currently no random elements to reduce
            pass

        elif flavor == FaygoFlavor.ROOT_BEER:
            effects['energy_self'] *= 0.5
            if hasattr(p, 'energy_econ'):
                p.energy_econ.gain(5)

        elif flavor == FaygoFlavor.COTTON_CANDY:
            if 'bond_change' in effects and effects['bond_change'] != 0:
                effects['bond_change'] *= random.choice([0.5, 1.5])
            effects['energy_self'] *= random.uniform(0.8, 1.5)

        self._apply_effect_dict(effects, target)

    def _apply_effect_dict(self, effects, target):
        p = self.entity
        if effects['energy_self'] != 0:
            p.energy_econ.gain(effects['energy_self'])
        if effects['energy_target'] != 0 and target:
            target.energy_econ.spend(-effects['energy_target'])
        if effects['arousal_self'] != 0 and hasattr(p, 'arousal'):
            p.arousal.excitation = max(0, min(5, p.arousal.excitation + int(effects['arousal_self'])))
        if effects['arousal_target'] != 0 and target and hasattr(target, 'arousal'):
            target.arousal.excitation = max(0, min(5, target.arousal.excitation + int(effects['arousal_target'])))
        if effects['anxiety_self'] != 0 and hasattr(p, 'anx_cur'):
            p.anx_cur.anxiety = max(0, min(1, p.anx_cur.anxiety + effects['anxiety_self']))
        if effects['bond_change'] != 0 and target and target.uid in p.bonds:
            if effects['bond_change'] > 0:
                p.bonds[target.uid].strengthen(effects['bond_change'])
            else:
                p.bonds[target.uid].weaken(-effects['bond_change'])
        if effects['clarity_change'] != 0 and hasattr(p, 'scg') and p.scg:
            p.scg.clarity_score = max(0, min(1, p.scg.clarity_score + effects['clarity_change']))
        if effects['poison_self'] < 0:
            p.poison_level = 0
        if effects['thirst_self'] < 0:
            p.thirst = max(0, p.thirst + effects['thirst_self'])

    def _check_fireworks(self, target, flavor, mode):
        """
        Check if this Faygo use can combine with a recent use by another particle.
        Simplified: just log a hint.
        """
        if not target or not hasattr(self.entity, 'engine'):
            return
        # For now, just a chance to trigger fireworks if flavors are complementary
        if target and hasattr(target, 'get_component'):
            other_inv = target.get_component("inventory")
            if other_inv and other_inv.faygos:
                # Not implemented; placeholder
                pass

    def update(self, tick):
        """Fizz decays for all stored Faygos."""
        for f in self.faygos:
            f['fizz'] = max(0, f['fizz'] - FAYGO_FIZZ_DECAY)


# -----------------------------------------------------------------------------
# AI DECISION LOGIC (to be integrated into Particle.decide_action)
# -----------------------------------------------------------------------------

def should_use_faygo(particle) -> bool:
    """
    Determine if a particle should use a Faygo this tick.
    Called from decide_action.
    """
    inv = particle.get_component("inventory")
    if not inv or not inv.faygos:
        return False

    # Conditions for wanting to use Faygo
    # 1. Low energy and not in danger
    if particle.energy < 30 and particle.anx_cur.anxiety < 0.5:
        return random.random() < 0.3

    # 2. High arousal and playful personality
    if hasattr(particle, 'arousal') and particle.arousal.excitation > 3 and particle.stats.playfulness > 60:
        return random.random() < 0.4

    # 3. Bored and at a festival
    if hasattr(particle, 'boredom_state') and particle.boredom_state >= 2 and hasattr(particle, 'engine'):
        if random.random() < 0.1:
            return True

    # 4. Madrox state â€“ might chug to cope
    madrox = particle.get_component("madrox")
    if madrox and madrox.active and random.random() < 0.2:
        return True

    return False


def choose_faygo_mode(particle, target=None) -> FaygoMode:
    """
    Choose a Faygo mode based on personality and situation.
    """
    inv = particle.get_component("inventory")
    flat_chance = 0.1 if inv and inv.faygos and inv.faygos[0]['fizz'] < FAYGO_FLAT_THRESHOLD else 0.01

    # Personality influences
    playful = particle.stats.playfulness > 60
    aggressive = particle.genes.get('aggression', 0.5) > 0.6
    anxious = particle.anx_cur.anxiety > 0.6

    modes = []

    if random.random() < flat_chance:
        modes.append(FaygoMode.FLAT)

    if playful:
        modes.append(FaygoMode.SHOOK)
        if target:
            modes.append(FaygoMode.SPRAY)

    if aggressive and target:
        modes.append(FaygoMode.HIT_IN_FACE)

    if anxious:
        modes.append(FaygoMode.BATHE)

    if particle.energy > 70 and particle.anx_cur.anxiety < 0.4:
        modes.append(FaygoMode.CHUG)

    if not modes:
        return FaygoMode.FLAT if random.random() < 0.5 else FaygoMode.SHOOK

    return random.choice(modes)
```

---

ðŸ“ File: dlc1/madrox.py

```python
# =============================================================================
# MADROX COMPONENT â€“ THE OVERTHINKER
# =============================================================================

import random
from .component import Component
from .constants import MADROX_MAX_DURATION, MADROX_BIAS_MULTIPLIER, MADROX_CHILL_DURATION

class MadroxComponent(Component):
    """Jamie Madrox state â€“ the overthinker."""
    def __init__(self):
        super().__init__("madrox")
        self.active = False
        self.timer = 0
        self.counter = 0
        self.bias_multiplier = MADROX_BIAS_MULTIPLIER
        self.cause = ""  # selfâ€‘righteous crusade
        self.biases = {}  # temporary biases against types

    def enter(self, cause: str = ""):
        """Enter the Madrox state."""
        if self.active:
            return
        self.active = True
        self.timer = MADROX_MAX_DURATION
        self.cause = cause or "defending the truth"
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Madrox] {self.entity.uid} has entered the Madrox state. Cause: {self.cause}")

    def exit(self):
        """Exit the Madrox state."""
        if not self.active:
            return
        self.active = False
        self.timer = 0
        self.biases.clear()
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Madrox] {self.entity.uid} has emerged from the Madrox state.")

    def update(self, tick):
        """Update Madrox state each tick."""
        if not self.active:
            return

        self.timer -= 1

        # Check exit conditions
        if self.timer <= 0 or self.entity.anx_cur.anxiety < 0.4:
            self.exit()
            return

        # Amplify anxiety
        self.entity.anx_cur.anxiety = min(1.0, self.entity.anx_cur.anxiety + 0.01)

        # Selfâ€‘justification
        if random.random() < 0.05:
            self.entity.engine.event_manager.post(Event(
                type="madrox_rant",
                source=self.entity,
                data={"cause": self.cause}
            ))

    def modify_action_weight(self, action, base_weight):
        """Increase weight of overthinkâ€‘type actions when active."""
        if not self.active:
            return base_weight
        if action in ["OVERTHINK", "PREACH", "ACCUSE", "JUSTIFY"]:
            return base_weight * self.bias_multiplier
        return base_weight

    def handle_event(self, event):
        """React to events that might trigger or affect Madrox."""
        if event.type == "provoke" and event.target == self.entity:
            self.enter(cause=event.data.get("reason", "being provoked"))
            return True
        return False
```

---

ðŸ“ File: dlc1/carnie.py

```python
# =============================================================================
# CARNIE COMPONENT â€“ MONOXIDE, THE WRAITHâ€‘SPAWNED CARNIE
# =============================================================================

import random
from enum import Enum
from .component import Component
from .constants import CARNIE_WORKING_ENERGY_DRAIN, CARNIE_SMOKE_BREAK_MIN, CARNIE_SMOKE_BREAK_MAX

class CarnieMode(Enum):
    WORKING = "working"
    SMOKE_BREAK = "smoke_break"
    SMOKE_GOSSIP = "smoke_gossip"
    SMOKE_CHILL = "smoke_chill"

class CarnieComponent(Component):
    """Monoxide â€“ the Wraithâ€‘spawned carnie."""
    def __init__(self):
        super().__init__("carnie")
        self.active = False
        self.mode = CarnieMode.WORKING
        self.sub_mode = None
        self.timer = 0
        self.original_role = ""
        self.games_offered = 0
        self.rumors_generated = 0

    def activate(self, original_role: str):
        """Activate the carnie role."""
        self.active = True
        self.mode = CarnieMode.WORKING
        self.original_role = original_role
        self.timer = 0
        if self.entity:
            self.entity.role = "CARNIE"
            if hasattr(self.entity, 'engine'):
                self.entity.engine.add_log(f"[Carnie] {self.entity.uid} is now running the midway.")

    def deactivate(self):
        """Deactivate the carnie role."""
        self.active = False
        if self.entity and self.original_role:
            self.entity.role = self.original_role
            if hasattr(self.entity, 'engine'):
                self.entity.engine.add_log(f"[Carnie] {self.entity.uid} returns to being {self.original_role}.")

    def update(self, tick):
        """Update carnie state each tick."""
        if not self.active:
            return

        # Energy drain while working
        if self.mode == CarnieMode.WORKING:
            if self.entity.energy < 30:
                self.enter_smoke_break()
            else:
                self.entity.energy -= CARNIE_WORKING_ENERGY_DRAIN
        else:
            # Smoke break
            self.timer -= 1
            if self.timer <= 0:
                self.exit_smoke_break()

    def enter_smoke_break(self):
        """Enter smoke break mode."""
        self.mode = CarnieMode.SMOKE_BREAK
        self.sub_mode = random.choice([CarnieMode.SMOKE_GOSSIP, CarnieMode.SMOKE_CHILL])
        self.timer = random.randint(CARNIE_SMOKE_BREAK_MIN, CARNIE_SMOKE_BREAK_MAX)

        # If chill mode, Wraith may nudge toward Madrox particles
        if self.sub_mode == CarnieMode.SMOKE_CHILL and self.entity and hasattr(self.entity, 'engine'):
            engine = self.entity.engine
            for e in engine.social_hub.entities:
                if e.alive and hasattr(e, 'get_component'):
                    madrox = e.get_component('madrox')
                    if madrox and madrox.active and madrox.timer < MADROX_MAX_DURATION - MADROX_CHILL_DURATION:
                        # Move toward them
                        dx = e.x - self.entity.x
                        dy = e.y - self.entity.y
                        if abs(dx) <= 2 and abs(dy) <= 2:
                            engine.add_log(f"[Wraith] Carnie {self.entity.uid} is chilling near {e.uid}. Smoke on the wind.")

    def exit_smoke_break(self):
        """Exit smoke break and return to work."""
        self.mode = CarnieMode.WORKING
        self.sub_mode = None

    def offer_game(self, participant):
        """Offer a carnival game to another entity."""
        self.games_offered += 1
        games = ["ring_toss", "milk_bottle", "guess_weight"]
        game = random.choice(games)
        success_chance = 0.3 + participant.stats.playfulness / 200.0

        if random.random() < success_chance:
            reward = "Faygo" if random.random() < 0.5 else "energy"
            return {"game": game, "won": True, "reward": reward}
        return {"game": game, "won": False, "reward": None}
```

---

ðŸ“ File: dlc1/dangerstate.py

```python
# =============================================================================
# DANGER STATE COMPONENT â€“ TEMPORARY PSYCHOLOGICAL STATES
# =============================================================================

import random
from enum import Enum
from .component import Component
from .constants import DANGER_STATE_DURATIONS

class DangerState(Enum):
    GET_CLOWNED = "get_clowned"
    JUGGALO_PARTY = "juggalo_party"
    THE_MIDWAY = "the_midway"
    LOST_AT_THE_CARNIVAL = "lost_at_the_carnival"
    I_FUCKED_A_COP = "i_fucked_a_cop"

class DangerStateComponent(Component):
    """Manages temporary danger zone states."""
    def __init__(self):
        super().__init__("danger_state")
        self.current_state: Optional[DangerState] = None
        self.timer = 0
        self.data = {}  # stateâ€‘specific data

    def enter(self, state: DangerState, data: dict = None):
        """Enter a new danger state."""
        self.current_state = state
        self.data = data or {}

        duration_range = DANGER_STATE_DURATIONS.get(state.value, (50, 150))
        if duration_range:
            self.timer = random.randint(*duration_range)
        else:
            self.timer = -1  # indefinite

        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Danger] {self.entity.uid} enters {state.value} state.")

    def exit(self):
        """Exit the current danger state."""
        if self.entity and self.current_state and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Danger] {self.entity.uid} exits {self.current_state.value} state.")
        self.current_state = None
        self.timer = 0
        self.data.clear()

    def update(self, tick):
        """Update the danger state each tick."""
        if self.current_state is None:
            return

        if self.timer > 0:
            self.timer -= 1
            if self.timer == 0:
                self.exit()
        elif self.timer == -1:
            # indefinite state â€“ handled by subclasses
            pass

        # Stateâ€‘specific updates
        if self.current_state == DangerState.LOST_AT_THE_CARNIVAL:
            self._update_lost()
        elif self.current_state == DangerState.THE_MIDWAY:
            self._update_midway_gambling()

    def _update_lost(self):
        """Lost particles wander and hallucinate."""
        if not self.entity:
            return
        self.entity.x = max(0, min(self.entity.engine.biome.w - 1,
                                   self.entity.x + random.choice([-1, 0, 1])))
        self.entity.y = max(0, min(self.entity.engine.biome.h - 1,
                                   self.entity.y + random.choice([-1, 0, 1])))

        if random.random() < 0.05 and hasattr(self.entity, 'grimoire'):
            self.entity.grimoire.update({
                "type": "hallucination",
                "description": f"I see someone familiar at ({self.entity.x}, {self.entity.y})...",
                "importance": 0.3
            }, is_vivid=True)

    def _update_midway_gambling(self):
        """Midway state: decide whether to keep gambling or walk away."""
        if not self.entity:
            return

        desperation = self.data.get("desperation", 0)
        consecutive_losses = self.data.get("consecutive_losses", 0)

        play_chance = max(0.3, 0.7 - desperation * 0.05)

        if random.random() < play_chance:
            # Play again
            game = random.choice(["ring_toss", "milk_bottle", "wheel"])
            win = random.random() < (0.3 + self.entity.stats.playfulness / 200.0)

            if win:
                self.entity.energy += 10
                self.data["consecutive_losses"] = 0
                if hasattr(self.entity, 'treasures'):
                    self.entity.treasures += 1
                self.enter(DangerState.JUGGALO_PARTY)
            else:
                self.entity.energy -= 5
                consecutive_losses += 1
                self.data["consecutive_losses"] = consecutive_losses
                desperation += 0.1
                self.data["desperation"] = desperation

                if consecutive_losses >= 3:
                    self.enter(DangerState.GET_CLOWNED, {"humiliation_source": "the_carnie"})
        else:
            # Walk away
            if desperation > 0.5:
                self.enter(DangerState.GET_CLOWNED)
            else:
                self.exit()
```

---

ðŸ“ File: dlc1/magnetic.py

```python
# =============================================================================
# MAGNETIC FIELDS SYSTEM â€“ ATTRACTION/REPULSION FOR MADROX
# =============================================================================

import math
import random
from .constants import (
    MADROX_FIELD_RADIUS, CALM_FIELD_RADIUS, MADROX_OPTIMAL_DIST,
    MADROX_INNER_RADIUS, MADROX_OUTER_RADIUS, CALM_BASE_RATE,
    MONOXIDE_CALM_STRENGTH, CALM_BASE_STRENGTH
)

class MagneticFieldsSystem:
    """Manages invisible attraction/repulsion fields."""
    def __init__(self):
        self.field_vectors = {}  # entity_uid -> (x, y) vector

    def update_entity(self, entity, engine):
        """Apply magnetic bias to entity movement."""
        # Only affects Madrox particles
        madrox = entity.get_component('madrox')
        if not madrox or not madrox.active:
            return

        # Find all calming sources
        calming_sources = self._find_calming_sources(entity, engine)
        if not calming_sources:
            return

        # Compute net field vector
        net_vector = self._compute_field_bias(entity, calming_sources)

        # Apply bias with 10% chance
        if random.random() < 0.1 and (abs(net_vector[0]) > 0 or abs(net_vector[1]) > 0):
            dx = 1 if net_vector[0] > 0 else -1 if net_vector[0] < 0 else 0
            dy = 1 if net_vector[1] > 0 else -1 if net_vector[1] < 0 else 0

            new_x = max(0, min(engine.biome.w - 1, entity.x + dx))
            new_y = max(0, min(engine.biome.h - 1, entity.y + dy))

            entity.x, entity.y = new_x, new_y

        # Apply proximity calming
        self._apply_proximity_calming(entity, calming_sources, engine)

    def _find_calming_sources(self, entity, engine) -> list:
        """Find all calming sources within range."""
        sources = []
        for e in engine.social_hub.entities:
            if not e.alive or e.uid == entity.uid:
                continue
            strength = self._get_calm_strength(e)
            if strength <= 0:
                continue
            dist = math.sqrt((e.x - entity.x)**2 + (e.y - entity.y)**2)
            if dist <= CALM_FIELD_RADIUS:
                sources.append((e, strength, dist))
        return sources

    def _get_calm_strength(self, entity) -> float:
        """Get calm field strength of an entity."""
        carnie = entity.get_component('carnie')
        if carnie and carnie.active and carnie.sub_mode == CarnieMode.SMOKE_CHILL:
            return MONOXIDE_CALM_STRENGTH * 1.5
        if carnie and carnie.active:
            return MONOXIDE_CALM_STRENGTH * 0.7
        return CALM_BASE_STRENGTH

    def _compute_field_bias(self, entity, calming_sources: list) -> tuple:
        """Compute net magnetic vector from all calming sources."""
        net_x, net_y = 0.0, 0.0
        for source, strength, dist in calming_sources:
            dx = source.x - entity.x
            dy = source.y - entity.y
            if dist == 0:
                continue
            d = dist
            optimal = MADROX_OPTIMAL_DIST
            spread = (MADROX_OUTER_RADIUS - MADROX_INNER_RADIUS) / 2
            w = 1 - ((d - optimal) ** 2) / (spread ** 2)
            w = max(-1, min(1, w))
            w *= strength
            net_x += (dx / dist) * w
            net_y += (dy / dist) * w
        return (net_x, net_y)

    def _apply_proximity_calming(self, entity, calming_sources, engine):
        """Apply calming effect when in proximity."""
        for source, strength, dist in calming_sources:
            if dist <= 3:
                base_rate = CALM_BASE_RATE * strength
                madrox = entity.get_component('madrox')
                if madrox:
                    duration = MADROX_MAX_DURATION - madrox.timer
                    resistance = min(0.77, duration / MADROX_MAX_DURATION * 0.77)
                    calm_rate = base_rate * (1 - resistance)
                else:
                    calm_rate = base_rate
                entity.anx_cur.anxiety = max(0, entity.anx_cur.anxiety - calm_rate)

                carnie = source.get_component('carnie')
                if carnie and carnie.sub_mode == CarnieMode.SMOKE_CHILL and madrox:
                    if random.random() < 0.05:
                        self._offer_smoke(entity, source, engine)

    def _offer_smoke(self, madrox_entity, carnie_entity, engine):
        """Carnie offers smoke to Madrox entity."""
        engine.add_log(f"[Carnie] {carnie_entity.uid} offers a smoke to {madrox_entity.uid}.")
        madrox = madrox_entity.get_component('madrox')
        if madrox:
            madrox_entity.anx_cur.anxiety = max(0, madrox_entity.anx_cur.anxiety - 0.3)
            madrox.timer = max(0, madrox.timer - 100)
            madrox.bias_multiplier *= 0.5
            if hasattr(madrox_entity, 'grimoire') and madrox_entity.grimoire.high_res_memory:
                mem = random.choice(list(madrox_entity.grimoire.high_res_memory))
                if isinstance(mem, dict) and 'importance' in mem:
                    mem['doubtful'] = True
            engine.add_log(f"[Madrox] {madrox_entity.uid} feels the smoke. The carnival inside quiets.")
```

---

ðŸ“ File: dlc1/rumor.py

```python
# =============================================================================
# RUMOR SYSTEM â€“ INFORMATION PROPAGATION
# =============================================================================

from dataclasses import dataclass
from typing import Optional, List
import random
from .constants import COVER_CROP_TYPES, MIDWAY_RADIUS

@dataclass
class Rumor:
    """A piece of information that spreads through the world."""
    text: str
    truth: float = 0.5  # 0.0 = false, 1.0 = true
    source: Optional[str] = None
    timestamp: int = 0
    spread_count: int = 0
    tags: list = None

    def __post_init__(self):
        if self.tags is None:
            self.tags = []


class RumorManager:
    """Manages global rumor propagation."""
    def __init__(self):
        self.rumors: List[Rumor] = []
        self.max_rumors = 100

    def create_rumor(self, text: str, truth: float = 0.5, source: str = None,
                     timestamp: int = 0, tags: list = None) -> Rumor:
        """Create and store a new rumor."""
        rumor = Rumor(
            text=text,
            truth=max(0.0, min(1.0, truth)),
            source=source,
            timestamp=timestamp,
            tags=tags or []
        )
        self.rumors.append(rumor)
        if len(self.rumors) > self.max_rumors:
            self.rumors.pop(0)
        return rumor

    def spread_rumor(self, rumor: Rumor, listener, teller, engine) -> bool:
        """Spread a rumor from teller to listener."""
        if listener.genes.get('curiosity', 0.5) < 0.3:
            return False

        listener.curiosity = min(1.0, listener.curiosity + 0.05)

        if hasattr(listener, 'grimoire'):
            listener.grimoire.update({
                "type": "rumor",
                "text": rumor.text,
                "source": teller.uid if teller else "unknown",
                "truth": rumor.truth,
                "importance": 0.5
            }, is_vivid=True)

        rumor.spread_count += 1

        if hasattr(engine, 'midway'):
            for festival in engine.midway.festivals:
                fx, fy, _ = festival
                if abs(listener.x - fx) + abs(listener.y - fy) < MIDWAY_RADIUS:
                    gossip_mult = COVER_CROP_TYPES.get(
                        engine.midway.festival_data.get((fx, fy), {}).get('cover_crop', 'CLOVER'),
                        {}
                    ).get('gossip_boost', 1.0)
                    listener.curiosity = min(1.0, listener.curiosity + 0.05 * (gossip_mult - 1))

        engine.add_log(f"[Rumor] Spreading: \"{rumor.text[:30]}...\" (truth: {rumor.truth:.1f})")
        return True

    def get_random_rumor(self, min_truth: float = 0.0, max_truth: float = 1.0) -> Optional[Rumor]:
        """Get a random rumor within truth range."""
        candidates = [r for r in self.rumors if min_truth <= r.truth <= max_truth]
        return random.choice(candidates) if candidates else None

    def get_rumors_by_tag(self, tag: str) -> List[Rumor]:
        """Get all rumors with a specific tag."""
        return [r for r in self.rumors if tag in r.tags]
```

---

ðŸ“ File: dlc1/midway.py

```python
# =============================================================================
# THE MIDWAY BIOME â€“ FESTIVAL OVERLAY WITH COVER CROPS
# =============================================================================

import random
import math
from enum import Enum
from .constants import (
    MIDWAY_RADIUS, MIDWAY_BASE_FIELD, MIDWAY_MAX_FIELD,
    FIELD_DECAY_RATE, FIELD_LOW_THRESHOLD, FIELD_HIGH_THRESHOLD,
    FIELD_CONTRIBUTIONS, STAGE_MULTIPLIERS, CONSENT_BONUS,
    COVER_CROP_TYPES, RESIDUE_DURATION
)

class CoverCropType(Enum):
    CLOVER = "clover"
    BORAGE = "borage"
    COMFREY = "comfrey"
    BUCKWHEAT = "buckwheat"
    TILLAGE_RADISH = "tillage_radish"
    VETCH = "vetch"
    MUSTARD = "mustard"
    SORGHUM_SUDAN = "sorghum_sudan"


class MidwayBiome:
    """Manages the carnival/festival Midway biome overlay."""
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.festival_data: dict = {}          # (x, y) -> {cover_crop, field_strength, duration, created_tick, radius}
        self.field_history: list = []
        self.root_memories: dict = {}          # (x, y, entity_uid) -> strength
        self.legendary_spots: dict = {}        # (x, y) -> power

    def create_festival(self, x: int, y: int, cover_crop: str = None, tick: int = 0) -> dict:
        """Create a new festival (Midway overlay)."""
        if not (0 <= x < self.width and 0 <= y < self.height):
            return None

        if cover_crop is None:
            cover_crop = random.choice([c.value for c in CoverCropType])

        self.festival_data[(x, y)] = {
            "cover_crop": cover_crop,
            "field_strength": MIDWAY_BASE_FIELD,
            "duration": RESIDUE_DURATION,
            "created_tick": tick,
            "radius": MIDWAY_RADIUS
        }
        return self.festival_data[(x, y)]

    def remove_festival(self, x: int, y: int, current_tick: int) -> None:
        """Remove a festival and apply residue effects."""
        if (x, y) not in self.festival_data:
            return
        data = self.festival_data[(x, y)]
        power = data["field_strength"] / MIDWAY_MAX_FIELD

        if power > 0.5:
            self._check_legendary_spot(x, y, power)

        del self.festival_data[(x, y)]

    def contribute_to_field(self, amount: float, entity, stage: str = "MAIN", consent: bool = False) -> None:
        """Contribute to field strength at nearest festival."""
        nearest = self._find_nearest_festival(entity.x, entity.y)
        if not nearest:
            return

        x, y = nearest
        if (x, y) not in self.festival_data:
            return

        stage_mult = STAGE_MULTIPLIERS.get(stage, 1.0)
        consent_mult = 1 + (CONSENT_BONUS if consent else 0)
        contribution = amount * stage_mult * consent_mult

        data = self.festival_data[(x, y)]
        data["field_strength"] = min(MIDWAY_MAX_FIELD, data["field_strength"] + contribution)

        self.field_history.append({
            "tick": entity.engine.time_sys.total_ticks,
            "x": x, "y": y,
            "amount": contribution,
            "source": entity.uid,
            "action": getattr(entity, 'last_action', 'unknown')
        })

    def tick(self, engine):
        """Update all festivals."""
        current_tick = engine.time_sys.total_ticks

        for (x, y), data in list(self.festival_data.items()):
            data["field_strength"] *= (1 - FIELD_DECAY_RATE)
            data["duration"] -= 1

            if data["duration"] <= 0 or data["field_strength"] < FIELD_LOW_THRESHOLD:
                self.remove_festival(x, y, current_tick)
                continue

            self._apply_midway_effects(x, y, data, engine)

            if data["field_strength"] > FIELD_HIGH_THRESHOLD:
                self._check_field_events(x, y, data, engine)

    def _apply_midway_effects(self, fx: int, fy: int, data: dict, engine):
        """Apply Midway biome effects to tiles in radius."""
        radius = data["radius"]
        cover_crop = data["cover_crop"]
        field_ratio = data["field_strength"] / MIDWAY_MAX_FIELD
        crop_data = COVER_CROP_TYPES.get(cover_crop, {})

        for dx in range(-radius, radius + 1):
            for dy in range(-radius, radius + 1):
                x, y = fx + dx, fy + dy
                if not (0 <= x < engine.biome.w and 0 <= y < engine.biome.h):
                    continue
                dist = abs(dx) + abs(dy)
                if dist > radius:
                    continue

                strength = field_ratio * (1 - dist / (radius + 1))

                if "faygo_boost" in crop_data and strength > 0.5:
                    if random.random() < 0.01 * strength * crop_data["faygo_boost"]:
                        self._spawn_faygo(x, y, engine)

                if "energy_regen" in crop_data:
                    for e in engine.social_hub.entities:
                        if e.alive and e.x == x and e.y == y and e.stance == 0:  # DORMANT
                            e.energy += crop_data["energy_regen"] * strength

    def _spawn_faygo(self, x: int, y: int, engine):
        """Spawn a Faygo item on a tile."""
        for e in engine.social_hub.entities:
            if e.alive and e.x == x and e.y == y:
                inv = e.get_component("inventory")
                if inv:
                    inv.add_faygo(None, 1)
                    engine.add_log(f"[Midway] {e.uid} found a Faygo!")
                    return

    def _check_field_events(self, x: int, y: int, data: dict, engine):
        """Check for special events at high field strength."""
        field = data["field_strength"]

        if field > 80 and random.random() < 0.01:
            self._trigger_carnival_of_carnage(x, y, engine)

        if field > 90 and random.random() < 0.005:
            self._trigger_shangri_la_resonance(engine)

    def _trigger_carnival_of_carnage(self, x: int, y: int, engine):
        """Trigger a chaos event."""
        engine.add_log(f"[Midway] Carnival of Carnage erupts at ({x}, {y})!")
        for e in engine.social_hub.entities:
            if e.alive and abs(e.x - x) + abs(e.y - y) < MIDWAY_RADIUS:
                if random.random() < 0.5:
                    e.energy += 20
                else:
                    e.energy -= 10
                    e.anx_cur.anxiety += 0.2

    def _trigger_shangri_la_resonance(self, engine):
        """Trigger global harmony effect."""
        engine.add_log("[Midway] Shangriâ€‘La Resonance â€“ the world feels calmer.")
        for e in engine.social_hub.entities:
            if e.alive:
                if hasattr(e, 'kanban'):
                    e.kanban.vector_bias += 0.1
                if hasattr(e, 'stats'):
                    e.stats.warmth = min(100, e.stats.warmth + 5)
                if hasattr(e, 'anx_cur'):
                    e.anx_cur.anxiety = max(0, e.anx_cur.anxiety - 0.2)

    def _check_legendary_spot(self, x: int, y: int, power: float) -> None:
        """Check if this should become a legendary party spot."""
        if power > 0.5:
            if (x, y) not in self.legendary_spots:
                self.legendary_spots[(x, y)] = power
            else:
                self.legendary_spots[(x, y)] = min(1.0, self.legendary_spots[(x, y)] + 0.1)

    def update_root_memories(self, entity, engine):
        """Update root memories for an entity on Midway tiles."""
        nearest = self._find_nearest_festival(entity.x, entity.y)
        if not nearest:
            return
        x, y = nearest
        if (x, y) not in self.festival_data:
            return

        key = (x, y, entity.uid)
        self.root_memories[key] = self.root_memories.get(key, 0) + 0.01
        if self.root_memories[key] > 0.3:
            entity.anx_cur.anxiety = max(0, entity.anx_cur.anxiety - 0.01)

    def _find_nearest_festival(self, x: int, y: int) -> Optional[tuple]:
        """Find coordinates of nearest festival."""
        nearest = None
        nearest_dist = float('inf')
        for (fx, fy) in self.festival_data:
            dist = abs(x - fx) + abs(y - fy)
            if dist < nearest_dist:
                nearest_dist = dist
                nearest = (fx, fy)
        return nearest
```

---

ðŸ“ File: dlc1/juggalo.py

```python
# =============================================================================
# JUGGALO PARTY â€“ COLLECTIVE CELEBRATION
# =============================================================================

import random
from .constants import (
    PARTY_RADIUS_BASE, PARTY_MIN_PARTICIPANTS, PARTY_TIMEOUT,
    PARTY_GROWTH_PER_TICK, PARTY_GROWTH_DECAY_TICKS, PARTY_TEMP_DECAY,
    PULL_RADIUS_MULTIPLIER, PULL_BASE_CHANCE,
    PARTY_GROWTH_CONTRIBUTIONS, PARTY_BENEFITS
)

class JuggaloParty:
    """A collective celebration event."""
    def __init__(self, center_x: int, center_y: int, engine):
        self.center_x = center_x
        self.center_y = center_y
        self.engine = engine
        self.level = 1
        self.temperature = 50.0
        self.growth_meter = 0.0
        self.participants = set()
        self.radius = PARTY_RADIUS_BASE
        self.created_tick = engine.time_sys.total_ticks
        self.last_action_tick = self.created_tick
        self.inactivity_timer = 0

    def add_participant(self, entity_uid: int) -> None:
        """Add a participant to the party."""
        self.participants.add(entity_uid)
        self.last_action_tick = self.engine.time_sys.total_ticks

    def remove_participant(self, entity_uid: int) -> None:
        """Remove a participant."""
        self.participants.discard(entity_uid)

    def contribute(self, action_type: str, contributor) -> None:
        """Contribute to party growth."""
        base_contrib = PARTY_GROWTH_CONTRIBUTIONS.get(action_type, 1)
        temp_mult = 1.2 if self.temperature > 80 else (0.8 if self.temperature < 20 else 1.0)

        self.growth_meter += base_contrib * temp_mult
        self.last_action_tick = self.engine.time_sys.total_ticks
        self.inactivity_timer = 0

        temp_change = 2.0 if action_type in ["COP_MOMENT", "WIN_CHALLENGE"] else 1.0
        self.temperature = max(0, min(100, self.temperature + temp_change))

        if self.growth_meter >= 100:
            self._level_up()

    def tick(self) -> bool:
        """Update party state. Returns False if party should end."""
        current_tick = self.engine.time_sys.total_ticks

        self.temperature = max(0, self.temperature - PARTY_TEMP_DECAY)

        if current_tick - self.last_action_tick > 10:
            self.inactivity_timer += 1
            if self.inactivity_timer > PARTY_GROWTH_DECAY_TICKS:
                self.growth_meter -= 1
                if self.growth_meter <= 0:
                    self._level_down()
        else:
            if len(self.participants) >= 3:
                self.growth_meter += PARTY_GROWTH_PER_TICK

        if len(self.participants) < PARTY_MIN_PARTICIPANTS:
            self.inactivity_timer += 1
        else:
            self.inactivity_timer = max(0, self.inactivity_timer - 1)

        if self.inactivity_timer >= PARTY_TIMEOUT:
            return False

        if self.temperature > 80 and random.random() < 0.01:
            self._trigger_chaos_event()

        self._pull_outsiders()

        return True

    def _level_up(self) -> None:
        """Increase party level."""
        if self.level >= 5:
            return
        self.level += 1
        self.growth_meter = 0
        self.radius = PARTY_BENEFITS[self.level]["radius"]
        self.engine.add_log(f"[Party] Level up! Now level {self.level} at ({self.center_x}, {self.center_y})")

        if self.level == 5 and hasattr(self.engine, 'midway'):
            self.engine.midway.legendary_spots[(self.center_x, self.center_y)] = 0.5
            self.engine.add_log("[Party] This party is legendary!")

    def _level_down(self) -> None:
        """Decrease party level."""
        if self.level <= 1:
            return
        self.level -= 1
        self.growth_meter = 50
        self.radius = PARTY_BENEFITS[self.level]["radius"]

    def _trigger_chaos_event(self) -> None:
        """Trigger a chaos event."""
        events = ["spill", "argument", "game_fail"]
        event = random.choice(events)
        self.engine.add_log(f"[Party] Chaos: {event}!")

        for uid in self.participants:
            entity = next((e for e in self.engine.social_hub.entities if e.uid == uid), None)
            if entity and entity.alive:
                if event == "spill":
                    entity.energy -= 2
                elif event == "argument":
                    if hasattr(entity, 'kanban'):
                        entity.kanban.vector_bias -= 0.1
                elif event == "game_fail":
                    entity.energy -= 5

        self.temperature += 10

    def _pull_outsiders(self) -> None:
        """Pull curious outsiders toward the party."""
        pull_radius = self.radius * PULL_RADIUS_MULTIPLIER

        for entity in self.engine.social_hub.entities:
            if not entity.alive or entity.uid in self.participants:
                continue

            dist = abs(entity.x - self.center_x) + abs(entity.y - self.center_y)

            if dist <= pull_radius and dist > self.radius:
                skepticism = 1.0 - entity.genes.get('curiosity', 0.5)
                pull_chance = PULL_BASE_CHANCE * (self.level / 5) * (1 - skepticism)

                if random.random() < pull_chance:
                    dx = 1 if entity.x < self.center_x else -1 if entity.x > self.center_x else 0
                    dy = 1 if entity.y < self.center_y else -1 if entity.y > self.center_y else 0
                    entity.x = max(0, min(self.engine.biome.w - 1, entity.x + dx))
                    entity.y = max(0, min(self.engine.biome.h - 1, entity.y + dy))

    def apply_benefits(self, entity) -> None:
        """Apply party benefits to a participant."""
        if entity.uid not in self.participants:
            return

        benefits = PARTY_BENEFITS.get(self.level, {})
        if "bond_mult" in benefits:
            entity._party_bond_mult = benefits["bond_mult"]
        if "curiosity" in benefits:
            entity.curiosity = min(1.0, entity.curiosity + benefits["curiosity"] * 0.01)
        if "energy_regen" in benefits:
            entity.energy = min(100, entity.energy + benefits["energy_regen"])

    def end(self) -> dict:
        """End the party and return summary."""
        if hasattr(self.engine, 'midway'):
            self.engine.midway.root_memories.setdefault(
                (self.center_x, self.center_y, 'party_residue'), 0
            )
            self.engine.midway.root_memories[(self.center_x, self.center_y, 'party_residue')] = min(
                1.0, self.engine.midway.root_memories[(self.center_x, self.center_y, 'party_residue')] + 0.3
            )

        veterans = []
        if self.level == 5:
            for uid in self.participants:
                entity = next((e for e in self.engine.social_hub.entities if e.uid == uid), None)
                if entity:
                    entity._party_veteran = True
                    veterans.append(uid)

        return {
            "level_reached": self.level,
            "max_temperature": self.temperature,
            "total_participants": len(self.participants),
            "veterans": veterans
        }


class JuggaloPartyManager:
    """Manages all active Juggalo parties."""
    def __init__(self):
        self.parties: List[JuggaloParty] = []

    def tick(self, engine) -> None:
        """Update all parties."""
        self.parties = [p for p in self.parties if p.tick()]

        for party in self.parties:
            for uid in party.participants:
                entity = next((e for e in engine.social_hub.entities if e.uid == uid), None)
                if entity and entity.alive:
                    party.apply_benefits(entity)

        self._check_party_triggers(engine)

    def _check_party_triggers(self, engine) -> None:
        """Check if conditions are met for a new party."""
        tile_counts = {}
        for e in engine.social_hub.entities:
            if not e.alive:
                continue
            key = (e.x, e.y)
            tile_counts.setdefault(key, []).append(e)

        for (x, y), entities in tile_counts.items():
            if len(entities) < PARTY_MIN_PARTICIPANTS:
                continue

            if any(abs(p.center_x - x) + abs(p.center_y - y) < 3 for p in self.parties):
                continue

            high_valence = [e for e in entities if hasattr(e, 'state') and e.state.valence >= 4]
            low_anxiety = [e for e in entities if hasattr(e, 'anx_cur') and e.anx_cur.anxiety < 0.4]

            if len(high_valence) >= 1 and len(low_anxiety) >= 2:
                party = JuggaloParty(x, y, engine)
                for e in entities:
                    party.add_participant(e.uid)
                self.parties.append(party)
                engine.add_log(f"[Party] A party starts at ({x}, {y})!")

    def get_party_at(self, x: int, y: int) -> Optional[JuggaloParty]:
        """Get party at or near coordinates."""
        for party in self.parties:
            if abs(party.center_x - x) + abs(party.center_y - y) < party.radius:
                return party
        return None
```

---

ðŸ“ File: dlc1/cop.py

```python
# =============================================================================
# COP MOMENT â€“ I FUCKED A COP (RIVAL'S TRUCE)
# =============================================================================

import random
from .event import Event

class CopMoment:
    """Represents a 'Cop Moment' â€“ a rival's truce event."""

    @staticmethod
    def check_trigger(entity_a, entity_b, engine) -> bool:
        """Check if a Cop Moment should trigger between two entities."""
        # 1. Longâ€‘standing opposition (TENSE bond phase or rivalry)
        bond_a = entity_a.bonds.get(entity_b.uid)
        bond_b = entity_b.bonds.get(entity_a.uid)

        is_opposed = False
        if bond_a and hasattr(entity_a, 'kanban') and entity_a.kanban.phase in [3, 4]:  # GIBBOUS, FULL
            is_opposed = True
        if bond_b and hasattr(entity_b, 'kanban') and entity_b.kanban.phase in [3, 4]:
            is_opposed = True

        if not is_opposed and hasattr(entity_a, 'social_layer') and entity_a.social_layer.current_layer == 4:  # RIVALS
            is_opposed = True

        if not is_opposed:
            return False

        # 2. High arousal for both
        if hasattr(entity_a, 'arousal') and hasattr(entity_b, 'arousal'):
            if entity_a.arousal.excitation < 3 or entity_b.arousal.excitation < 3:
                return False

        # 3. Proximity
        if abs(entity_a.x - entity_b.x) + abs(entity_a.y - entity_b.y) > 2:
            return False

        danger_mult = 1.0
        if hasattr(entity_a, 'get_component'):
            danger_a = entity_a.get_component('danger_state')
            if danger_a and danger_a.current_state:
                danger_mult += 0.5
        if hasattr(entity_b, 'get_component'):
            danger_b = entity_b.get_component('danger_state')
            if danger_b and danger_b.current_state:
                danger_mult += 0.5

        return random.random() < 0.1 * danger_mult

    @staticmethod
    def trigger(entity_a, entity_b, engine) -> None:
        """Trigger a Cop Moment between two entities."""
        CopMoment._enter_ride_along(entity_a, entity_b)
        CopMoment._enter_ride_along(entity_b, entity_a)
        engine.add_log(f"[CopMoment] A moment passes between {entity_a.uid} and {entity_b.uid}...")

    @staticmethod
    def _enter_ride_along(entity, partner) -> None:
        """Enter rideâ€‘along state."""
        entity._ride_along_active = True
        entity._ride_along_partner = partner.uid
        entity._ride_along_timer = random.randint(30, 60)

        if partner.uid not in entity.bonds:
            from .bond import Bond  # assuming Bond class exists in base
            entity.bonds[partner.uid] = Bond(partner.uid, 2)  # EMERGING

        entity._suppress_hostile_actions = True

    @staticmethod
    def update(entity, engine) -> None:
        """Update rideâ€‘along state."""
        if not getattr(entity, '_ride_along_active', False):
            return

        entity._ride_along_timer -= 1

        partner = next((e for e in engine.social_hub.entities
                       if e.uid == entity._ride_along_partner and e.alive), None)

        if partner:
            if partner.uid in entity.bonds:
                entity.bonds[partner.uid].strength = min(1.0, entity.bonds[partner.uid].strength + 0.05)

            dx = 1 if entity.x < partner.x else -1 if entity.x > partner.x else 0
            dy = 1 if entity.y < partner.y else -1 if entity.y > partner.y else 0
            entity.x = max(0, min(engine.biome.w - 1, entity.x + dx))
            entity.y = max(0, min(engine.biome.h - 1, entity.y + dy))

        if entity._ride_along_timer <= 0:
            CopMoment._exit_ride_along(entity, engine)

    @staticmethod
    def _exit_ride_along(entity, engine) -> None:
        """Exit rideâ€‘along with awkward aftermath."""
        partner_uid = entity._ride_along_partner
        entity._post_cop_cooldown = 200

        if hasattr(entity, 'grimoire'):
            entity.grimoire.update({
                "type": "cop_moment",
                "partner": partner_uid,
                "description": f"We had a moment... it was weird.",
                "importance": 0.7
            }, is_vivid=True)

        del entity._ride_along_active
        del entity._ride_along_partner
        del entity._ride_along_timer

        if hasattr(entity, '_suppress_hostile_actions'):
            del entity._suppress_hostile_actions

        engine.add_log(f"[CopMoment] The moment between {entity.uid} and {partner_uid} ends. Awkward silence.")
```

---

ðŸ“ File: dlc1/archetype.py

```python
# =============================================================================
# ARCHETYPE MANAGER â€“ DATAâ€‘DRIVEN ROLE DEFINITIONS
# =============================================================================

import os
import json
from typing import Dict, Any, Optional
from .component import Component

class ArchetypeManager:
    """
    Loads archetype definitions from JSON files and applies them to particles.
    """
    def __init__(self, archetype_dir: str = "archetypes/"):
        self.archetype_dir = archetype_dir
        self.archetypes: Dict[str, Dict[str, Any]] = {}
        self.load_all()

    def load_all(self) -> None:
        """Load all .json files from the archetype directory."""
        if not os.path.exists(self.archetype_dir):
            os.makedirs(self.archetype_dir)
            print(f"Created archetype directory: {self.archetype_dir}")
            return

        for filename in os.listdir(self.archetype_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.archetype_dir, filename)
                with open(path, 'r') as f:
                    data = json.load(f)
                    name = data.get("name")
                    if name:
                        self.archetypes[name] = data
                        print(f"Loaded archetype: {name}")
                    else:
                        print(f"Warning: {filename} missing 'name' field")

    def get_archetype(self, name: str) -> Optional[Dict[str, Any]]:
        """Return the raw archetype data for a given name."""
        return self.archetypes.get(name)

    def apply_archetype(self, particle: 'Particle', archetype_name: str) -> None:
        """
        Configure a particle using the named archetype.
        Sets base coordinates, builds tensor, adds components, and stores archetype data.
        """
        data = self.archetypes.get(archetype_name)
        if not data:
            raise ValueError(f"Archetype '{archetype_name}' not found")

        # 1. Set base personality coordinates
        coords_data = data.get("base_coords", {})
        if hasattr(particle, 'coords'):
            particle.coords.warmth = coords_data.get("warmth", 3)
            particle.coords.softness = coords_data.get("softness", 3)
            particle.coords.family = coords_data.get("family", 1)
            particle.coords.axis_a = coords_data.get("axis_a", 3)
            particle.coords.axis_b = coords_data.get("axis_b", 3)
            particle.coords.clamp()

        # 2. Build the personality tensor
        if hasattr(particle, 'tensor'):
            particle.tensor.build(particle.coords)

        # 3. Add components specified in the archetype
        components = data.get("components", {})
        for comp_name, comp_config in components.items():
            comp = self._create_component(comp_name, comp_config)
            if comp:
                particle.add_component(comp_name, comp)

        # 4. Store the full archetype data
        particle.archetype_data = data

    def _create_component(self, comp_name: str, config: Any) -> Optional[Component]:
        """
        Factory method to instantiate a component from a name and config.
        Extend this with your own component classes.
        """
        from .faygo import InventoryComponent
        from .madrox import MadroxComponent
        from .carnie import CarnieComponent
        from .dangerstate import DangerStateComponent

        if comp_name == "inventory":
            return InventoryComponent()
        if comp_name == "madrox":
            return MadroxComponent()
        if comp_name == "carnie":
            return CarnieComponent()
        if comp_name == "danger_state":
            return DangerStateComponent()

        print(f"Warning: No component class for '{comp_name}'. Using generic Component.")
        return Component(comp_name)
```

---

ðŸ“ File: dlc1/dialogue.py

```python
# =============================================================================
# DIALOGUE MANAGER â€“ EMERGENT, 5Dâ€‘INTEGRATED SPEECH
# =============================================================================

import os
import json
import random
import math
from typing import Dict, List, Optional, Any

class DialogueManager:
    """
    Generates emergent dialogue based on particle state, 5D matrix, and relationships.
    Templates are weighted by personality axes and mood; placeholders are filled with live data.
    """
    def __init__(self, template_dir: str = "dialogue/"):
        self.template_dir = template_dir
        self.templates: Dict[str, List[Dict[str, Any]]] = {}  # context -> list of template dicts
        self.mood_modifiers: Dict[str, Dict[str, Any]] = {}   # mood -> modifier data
        self.load_all()

    def load_all(self) -> None:
        """Load all JSON files from the template directory."""
        if not os.path.exists(self.template_dir):
            os.makedirs(self.template_dir)
            print(f"Created dialogue directory: {self.template_dir}")
            return

        for filename in os.listdir(self.template_dir):
            if filename.endswith(".json"):
                path = os.path.join(self.template_dir, filename)
                with open(path, 'r') as f:
                    data = json.load(f)
                    for ctx, templates in data.get("contexts", {}).items():
                        self.templates.setdefault(ctx, []).extend(templates)
                    self.mood_modifiers.update(data.get("mood_modifiers", {}))
                    print(f"Loaded dialogue: {filename}")

    def get_response(self, particle: 'Particle', context: str, target: Optional['Particle'] = None, **kwargs) -> str:
        """
        Generate a response for the given context, optionally directed at a target particle.
        Uses particle's 5D matrix, mood, arousal, and bond with target to weight templates.
        """
        templates = self.templates.get(context, [])
        if not templates:
            return "..."

        # Get personality axes (5D)
        fiveD = getattr(particle, 'fiveD', None)
        style = fiveD.style / 100.0 if fiveD else 0.5
        action = fiveD.action / 100.0 if fiveD else 0.5
        mood_axis = fiveD.mood / 100.0 if fiveD else 0.5
        attitude = fiveD.attitude / 100.0 if fiveD else 0.5
        strategy = fiveD.strategy / 100.0 if fiveD else 0.5

        mood = getattr(particle, 'mood_val', 'neutral')
        arousal = getattr(particle, 'arousal_level', 0) / 5.0

        bond_strength = 0.5
        if target:
            bond = particle.bonds.get(target.uid)
            if bond:
                bond_strength = bond.strength

        weighted_templates = []
        for t in templates:
            base_weight = t.get("weight", 1.0)

            if "elaborate" in t.get("tags", []) and style > 0.7:
                base_weight *= 1.5
            if "direct" in t.get("tags", []) and action > 0.7:
                base_weight *= 1.5
            if "emotional" in t.get("tags", []) and mood_axis > 0.7:
                base_weight *= 1.3

            mood_mod = self.mood_modifiers.get(mood, {})
            if context in mood_mod.get("prefer", []):
                base_weight *= mood_mod.get("weight_multiplier", 1.2)

            if "energetic" in t.get("tags", []) and arousal > 0.7:
                base_weight *= 1.4
            if "intimate" in t.get("tags", []) and bond_strength > 0.8:
                base_weight *= 1.5
            if "confrontational" in t.get("tags", []) and bond_strength < 0.3:
                base_weight *= 1.5

            weighted_templates.append((t, base_weight))

        total = sum(w for _, w in weighted_templates)
        if total <= 0:
            return "..."

        r = random.random() * total
        for t, w in weighted_templates:
            r -= w
            if r <= 0:
                chosen_template = t
                break
        else:
            chosen_template = templates[0]

        placeholders = self._build_placeholders(particle, target, **kwargs)

        try:
            text = chosen_template["text"].format(**placeholders)
        except KeyError as e:
            print(f"Warning: missing placeholder {e} in template: {chosen_template['text']}")
            text = chosen_template["text"]

        if context == "madrox_rant" and random.random() < 0.3:
            second = random.choice([t for t in templates if t != chosen_template])
            try:
                text += " " + second["text"].format(**placeholders)
            except:
                pass

        return text

    def _build_placeholders(self, particle: 'Particle', target: Optional['Particle'] = None, **kwargs) -> Dict[str, str]:
        """Collect all possible placeholders from particle state, bond, and kwargs."""
        placeholders = {
            "name": particle.name,
            "energy": f"{getattr(particle.state, 'energy', 0):.0f}",
            "valence": str(getattr(particle.state, 'valence', 3)),
            "arousal": str(getattr(particle, 'arousal_level', 0)),
            "cause": getattr(particle, 'madrox_cause', 'something'),
            "fizz": kwargs.get("fizz", "flat"),
        }

        if target:
            placeholders["target_name"] = target.name
            bond = particle.bonds.get(target.uid)
            if bond:
                placeholders["bond_strength"] = f"{bond.strength:.2f}"
                placeholders["bond_phase"] = str(getattr(bond, 'phase', 'unknown'))
            else:
                placeholders["bond_strength"] = "0.0"
                placeholders["bond_phase"] = "none"

        if hasattr(particle, 'fiveD'):
            placeholders["style"] = str(particle.fiveD.style)
            placeholders["action"] = str(particle.fiveD.action)
            placeholders["mood_axis"] = str(particle.fiveD.mood)
            placeholders["attitude"] = str(particle.fiveD.attitude)
            placeholders["strategy"] = str(particle.fiveD.strategy)

        for k, v in kwargs.items():
            placeholders[k] = str(v)

        return placeholders
```

---

ðŸ“ File: dlc1/bond.py (optional, if base engine doesn't have a Bond class)

```python
# =============================================================================
# BOND CLASS â€“ CONNECTION BETWEEN PARTICLES
# =============================================================================

class Bond:
    def __init__(self, target_uid, bond_type=0):
        self.target_uid = target_uid
        self.type = bond_type
        self.strength = 0.0
        self.history = []

    def strengthen(self, amount):
        self.strength = min(1.0, self.strength + amount)
        self.history.append(f"+{amount:.2f}")

    def weaken(self, amount):
        self.strength = max(0.0, self.strength - amount)
        self.history.append(f"-{amount:.2f}")
```

---

ðŸ”§ Integration Instructions

1. Copy the dlc1 folder into your project root.
2. In your base Particle class (from Here.txt), add ComponentHolder as a base class:

```python
from dlc1 import ComponentHolder

class Particle(ComponentHolder):
    def __init__(self, ...):
        ComponentHolder.__init__(self)
        # ... rest of init ...
```

1. In your base engine's __init__, add the new managers:

```python
from dlc1 import EventManager, ArchetypeManager, DialogueManager, MidwayBiome, JuggaloPartyManager, MagneticFieldsSystem, RumorManager

class UnifiedEngine:
    def __init__(self, ...):
        # ... existing code ...
        self.event_manager = EventManager()
        self.archetype_manager = ArchetypeManager("archetypes/")
        self.dialogue_manager = DialogueManager("dialogue/")
        self.midway = MidwayBiome(self.biome.w, self.biome.h)
        self.party_manager = JuggaloPartyManager()
        self.magnetic_fields = MagneticFieldsSystem()
        self.rumor_manager = RumorManager()
```

1. In the engine's tick(), add updates for the new systems:

```python
def tick(self, user_input=None):
    # ... existing updates ...
    self.midway.tick(self)
    self.party_manager.tick(self)
    for e in self.social_hub.entities:
        if e.alive:
            self.magnetic_fields.update_entity(e, self)
            self.midway.update_root_memories(e, self)
            # CopMoment update (call static method)
            from dlc1 import CopMoment
            CopMoment.update(e, self)
```

1. In your Particle class, add a method to post events:

```python
def post_event(self, event_type: str, target=None, **data):
    event = Event(
        type=event_type,
        source=self,
        target=target,
        data=data
    )
    self.engine.event_manager.post(event)
```

1. In your action handling (e.g., perform_action), call the appropriate DLC functions (e.g., Faygo use).
2. Add example archetype JSON files in archetypes/ (e.g., mystic.json as shown in Untitled (1).txt).
3. Add example dialogue JSON files in dialogue/ (e.g., mystic.json with contexts like greeting, madrox_rant).

---
I'll read through all the uploaded files to gather the complete DLC 1 implementation and provide it in a single code block for you.
Let me read the remaining files to get the complete DLC 1 content:
Here's the complete DLC 1: THE MISSING LINK implementation in a single code block:

```python
# =============================================================================
# JOKE YA MIND v2 â€” DLC 1: THE MISSING LINK
# Complete Implementation
# License: MIT "No Kings" Edition
# =============================================================================

import random
import math
import json
import os
from enum import Enum, IntEnum
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Tuple, Callable
from collections import deque, defaultdict

# =============================================================================
# DLC 1: NEW CONSTANTS
# =============================================================================

# --- Magnetic Fields ---
MADROX_FIELD_RADIUS = 12
CALM_FIELD_RADIUS = 15
MADROX_OPTIMAL_DIST = 6
MADROX_INNER_RADIUS = 3
MADROX_OUTER_RADIUS = 12
CALM_BASE_RATE = 0.01
MONOXIDE_CALM_STRENGTH = 1.0
CALM_BASE_STRENGTH = 0.3

# --- Madrox State ---
MADROX_MAX_DURATION = 500
MADROX_BIAS_MULTIPLIER = 1.5
MADROX_CHILL_DURATION = 50

# --- Carnie ---
CARNIE_DEPLOYMENT_VARIANCE_THRESHOLD = 0.2
CARNIE_DEPLOYMENT_MIN_TICKS = 200
CARNIE_WORKING_ENERGY_DRAIN = 0.1
CARNIE_SMOKE_BREAK_MIN = 30
CARNIE_SMOKE_BREAK_MAX = 100

# --- Faygo ---
FAYGO_FRESH_DURATION = 100  # ticks until flat
FAYGO_MODES = ["FLAT", "SHOOK", "SPRAY", "BATHE", "HIT_IN_FACE", "CHUG"]
FAYGO_FLAT_THRESHOLD = 0.3
FAYGO_FIZZ_FRESH = 1.0
FAYGO_FIZZ_DECAY = 0.005
FAYGO_GEN_BASE = 0.01
FAYGO_GEN_MULTIPLIER = 1.5

# Faygo effects
FAYGO_EFFECTS = {
    "FLAT": {"energy": 10, "anxiety": -0.2},
    "SHOOK": {"energy": 20, "arousal": 2, "speed_boost": True},
    "SPRAY": {"target_energy": -5, "target_arousal": -1, "social": True},
    "BATHE": {"cleanse": True, "refresh_buff": True},
    "HIT_IN_FACE": {"target_energy": -15, "hostility": 0.3},
    "CHUG": {"energy": 30, "brain_freeze_chance": 0.2, "burp": True}
}

# --- The Midway ---
MIDWAY_RADIUS = 3
MIDWAY_POWER_DECAY = 0.001
MIDWAY_BASE_FIELD = 10
MIDWAY_MAX_FIELD = 100
RESIDUE_DURATION = 200

# Cover crop types
COVER_CROP_TYPES = {
    "CLOVER": {"faygo_boost": 1.5, "energy_regen": 0.1},
    "BORAGE": {"gossip_boost": 1.5},
    "COMFREY": {"nutrient_pump": True},
    "BUCKWHEAT": {"pest_suppression": 0.7, "rivalry_suppress": True},
    "TILLAGE_RADISH": {"movement_cost": -0.3, "path_permanence": True},
    "VETCH": {"compound_benefit": True},
    "MUSTARD": {"disease_resist": 0.5},
    "SORGHUM_SUDAN": {"power_growth": 1.5, "lush_bonus": True}
}

# --- Midway Field Strength ---
FIELD_DECAY_RATE = 0.01
FIELD_LOW_THRESHOLD = 5
FIELD_HIGH_THRESHOLD = 50

# Field contribution by action
FIELD_CONTRIBUTIONS = {
    "GAME": 1,
    "FAYGO_FLAT": 1,
    "FAYGO_SHOOK": 2,
    "FAYGO_SPRAY": 2,
    "FAYGO_CHUG": 3,
    "COP_MOMENT": 5,
    "CARNIE_WORKING": 0.5,
    "CARNIE_SMOKE": 0.2
}

# Stage multipliers
STAGE_MULTIPLIERS = {
    "MAIN": 1.0,
    "SIDE1": 1.5,
    "SIDE2": 0.5,
    "SIDE3": 2.0
}

# Consent bonus
CONSENT_BONUS = 0.2

# --- Juggalo Party ---
PARTY_RADIUS_BASE = 5
PARTY_MIN_PARTICIPANTS = 3
PARTY_TIMEOUT = 50
PARTY_GROWTH_PER_TICK = 1
PARTY_GROWTH_DECAY_TICKS = 50
PARTY_TEMP_DECAY = 0.1
PULL_RADIUS_MULTIPLIER = 2
PULL_BASE_CHANCE = 0.05

# Party growth contributions
PARTY_GROWTH_CONTRIBUTIONS = {
    "GAME": 5,
    "FAYGO": 3,
    "NEW_BOND": 10,
    "WIN_CHALLENGE": 8,
    "COP_MOMENT": 15,
    "CHEER": 2,
    "BUY_ROUND": 20
}

# Party benefits by level
PARTY_BENEFITS = {
    1: {"radius": 5, "bond_mult": 1.2, "curiosity": 0.05, "energy_regen": 0.1},
    2: {"radius": 6, "bond_mult": 1.4, "curiosity": 0.10, "energy_regen": 0.2},
    3: {"radius": 7, "bond_mult": 1.6, "curiosity": 0.15, "energy_regen": 0.3},
    4: {"radius": 8, "bond_mult": 1.8, "curiosity": 0.20, "energy_regen": 0.4},
    5: {"radius": 10, "bond_mult": 2.0, "curiosity": 0.25, "energy_regen": 0.5, "veteran_trait": True}
}

# --- Danger Zone States ---
DANGER_STATE_DURATIONS = {
    "GET_CLOWNED": (50, 150),
    "JUGGALO_PARTY": (30, 100),
    "THE_MIDWAY": None,  # until win/lose
    "LOST_AT_THE_CARNIVAL": None,  # until reconnection
    "I_FUCKED_A_COP": (100, 300)
}

# --- Legendary Party Spots ---
LEGENDARY_POWER_DECAY = 0.001
LEGENDARY_POWER_INCREASE_VISIT = 0.01
LEGENDARY_POWER_DECREASE_CHICKEN = 0.1
LEGENDARY_POWER_DECREASE_JUFF = 0.15
LEGENDARY_POWER_DECREASE_SKEPTIC = 0.05
LEGENDARY_POWER_THRESHOLD = 1.0

# =============================================================================
# DLC 1: NEW ENUMS
# =============================================================================

class FaygoMode(Enum):
    """Six modes of Faygo consumption."""
    FLAT = "flat"
    SHOOK = "shook"
    SPRAY = "spray"
    BATHE = "bathe"
    HIT_IN_FACE = "hit_in_face"
    CHUG = "chug"

class FaygoFlavor(Enum):
    """Six flavors of Faygo."""
    WATERMELON = "watermelon"
    PINEAPPLE = "pineapple"
    GRAPE = "grape"
    ORANGE = "orange"
    ROOT_BEER = "root_beer"
    COTTON_CANDY = "cotton_candy"

class CarnieMode(Enum):
    """Carnie operational modes."""
    WORKING = "working"
    SMOKE_BREAK = "smoke_break"
    SMOKE_GOSSIP = "smoke_gossip"
    SMOKE_CHILL = "smoke_chill"

class CoverCropType(Enum):
    """Types of cover crops in Midway biome."""
    CLOVER = "clover"
    BORAGE = "borage"
    COMFREY = "comfrey"
    BUCKWHEAT = "buckwheat"
    TILLAGE_RADISH = "tillage_radish"
    VETCH = "vetch"
    MUSTARD = "mustard"
    SORGHUM_SUDAN = "sorghum_sudan"

class DangerState(Enum):
    """Temporary psychological/physical states."""
    GET_CLOWNED = "get_clowned"
    JUGGALO_PARTY = "juggalo_party"
    THE_MIDWAY = "the_midway"
    LOST_AT_THE_CARNIVAL = "lost_at_the_carnival"
    I_FUCKED_A_COP = "i_fucked_a_cop"

class RumorTruth(Enum):
    """Truth value of a rumor."""
    FALSE = 0.0
    MIXED = 0.5
    TRUE = 1.0

# =============================================================================
# COMPONENT SYSTEM
# =============================================================================

class Component:
    """Base class for all components."""
    
    def __init__(self, name: str):
        self.name = name
        self.entity: Optional['Entity'] = None
    
    def on_attach(self, entity: 'Entity') -> None:
        """Called when component is added to entity."""
        self.entity = entity
    
    def on_detach(self) -> None:
        """Called when component is removed."""
        self.entity = None
    
    def update(self, tick: int) -> None:
        """Called every tick. Override for behavior."""
        pass
    
    def handle_event(self, event: 'Event') -> bool:
        """Handle event. Return True if handled."""
        return False

class ComponentHolder:
    """Mixin for entities that can hold components."""
    
    def __init__(self):
        self.components: Dict[str, Component] = {}
    
    def add_component(self, name: str, component: Component) -> None:
        """Attach a component to this entity."""
        component.on_attach(self)
        self.components[name] = component
    
    def remove_component(self, name: str) -> None:
        """Detach a component by name."""
        if name in self.components:
            self.components[name].on_detach()
            del self.components[name]
    
    def get_component(self, name: str) -> Optional[Component]:
        """Retrieve a component by name, or None if not present."""
        return self.components.get(name)
    
    def update_components(self, tick: int) -> None:
        """Call update on all attached components."""
        for comp in self.components.values():
            comp.update(tick)
    
    def dispatch_event_to_components(self, event: 'Event') -> bool:
        """Send an event to all components, stopping if one handles it."""
        for comp in self.components.values():
            if comp.handle_event(event):
                return True
        return False

# =============================================================================
# EVENT SYSTEM
# =============================================================================

@dataclass
class Event:
    """Global event data structure."""
    type: str
    source: Any = None
    target: Any = None
    data: Dict[str, Any] = field(default_factory=dict)
    tick: int = 0

class EventManager:
    """Global event bus for loose coupling."""
    
    def __init__(self):
        self.listeners: Dict[str, List[Callable]] = defaultdict(list)
        self.history: List[Event] = []
        self.max_history = 1000
    
    def subscribe(self, event_type: str, callback: Callable) -> None:
        """Register a callback for an event type."""
        self.listeners[event_type].append(callback)
    
    def unsubscribe(self, event_type: str, callback: Callable) -> None:
        """Unregister a callback."""
        if callback in self.listeners[event_type]:
            self.listeners[event_type].remove(callback)
    
    def post(self, event: Event) -> None:
        """Dispatch event to all listeners."""
        self.history.append(event)
        if len(self.history) > self.max_history:
            self.history.pop(0)
        
        for callback in self.listeners.get(event.type, []):
            try:
                callback(event)
            except Exception as e:
                print(f"[EventManager] Error in callback for {event.type}: {e}")
    
    def get_recent(self, event_type: str = None, limit: int = 10) -> List[Event]:
        """Get recent events, optionally filtered by type."""
        if event_type:
            filtered = [e for e in self.history if e.type == event_type]
            return filtered[-limit:]
        return self.history[-limit:]

# =============================================================================
# ARCHETYPE MANAGER
# =============================================================================

class ArchetypeManager:
    """Loads and applies archetype definitions."""
    
    def __init__(self, archetype_dir: str = "archetypes/"):
        self.archetype_dir = archetype_dir
        self.archetypes: Dict[str, Dict] = {}
        self._load_all()
    
    def _load_all(self):
        """Load all archetype JSON files."""
        os.makedirs(self.archetype_dir, exist_ok=True)
        
        if os.path.exists(self.archetype_dir):
            for filename in os.listdir(self.archetype_dir):
                if filename.endswith('.json'):
                    filepath = os.path.join(self.archetype_dir, filename)
                    try:
                        with open(filepath, 'r') as f:
                            data = json.load(f)
                            name = data.get('name')
                            if name:
                                self.archetypes[name] = data
                    except Exception as e:
                        print(f"[ArchetypeManager] Failed to load {filename}: {e}")
    
    def get(self, name: str) -> Dict[str, Any]:
        """Get archetype data by name."""
        return self.archetypes.get(name, {})
    
    def apply_to_entity(self, entity, archetype_name: str) -> None:
        """Apply archetype stats and components to entity."""
        data = self.get(archetype_name)
        if not data:
            return
        
        # Apply base stats
        if 'base_stats' in data:
            stats = data['base_stats']
            for key, value in stats.items():
                if hasattr(entity, key):
                    setattr(entity, key, value)
        
        # Apply genes
        if 'genes' in data and hasattr(entity, 'genes'):
            for gene, value in data['genes'].items():
                if gene in entity.genes:
                    entity.genes[gene] = value
        
        # Add components
        if 'components' in data:
            for comp_name, comp_data in data['components'].items():
                component = self._create_component(comp_name, comp_data)
                if component and hasattr(entity, 'add_component'):
                    entity.add_component(comp_name, component)
        
        # Store archetype data for reference
        entity.archetype_data = data
    
    def _create_component(self, comp_type: str, data: dict) -> Optional[Component]:
        """Factory method for creating components."""
        return Component(comp_type)

# =============================================================================
# DIALOGUE MANAGER
# =============================================================================

class DialogueManager:
    """Manages dialogue templates and generates responses."""
    
    def __init__(self, template_dir: str = "dialogue/"):
        self.template_dir = template_dir
        self.templates: Dict[str, List[dict]] = defaultdict(list)
        self.mood_modifiers: Dict[str, dict] = {}
        self._load_all()
    
    def _load_all(self):
        """Load all dialogue template files."""
        self._load_builtin_templates()
    
    def _load_builtin_templates(self):
        """Load built-in dialogue templates."""
        
        # Greetings
        self.templates["greeting"] = [
            {"text": "Hello, {name}.", "weight": 1.0, "tags": ["direct"]},
            {"text": "Oh, it's you again.", "weight": 0.5, "tags": ["intimate"]},
            {"text": "What brings you here?", "weight": 0.8, "tags": ["curious"]}
        ]
        
        # Madrox rants
        self.templates["madrox_rant"] = [
            {"text": "You think you understand? You don't. {cause} demands that I...", "weight": 1.0, "tags": ["confrontational", "emotional"]},
            {"text": "They're all watching. I know it. {cause} is the only truth.", "weight": 0.8, "tags": ["paranoid"]},
            {"text": "I've seen things. Patterns you wouldn't believe. {cause}.", "weight": 0.6, "tags": ["elaborate"]}
        ]
        
        # Carnie offers
        self.templates["carnie_offer"] = [
            {"text": "Step right up! Test your luck!", "weight": 1.0, "tags": ["energetic"]},
            {"text": "Hey, you look like you need a distraction. Care to play?", "weight": 0.8, "tags": ["friendly"]},
            {"text": "Three rings, one treasure. What do you say?", "weight": 0.7, "tags": ["mysterious"]}
        ]
        
        # Faygo interactions
        self.templates["faygo_offer"] = [
            {"text": "Want a Faygo? It's {fizz}.", "weight": 1.0, "tags": ["friendly"]},
            {"text": "Care for a drink? Fresh from the midway.", "weight": 0.7, "tags": ["intimate"]}
        ]
        
        # Mood modifiers
        self.mood_modifiers = {
            "angry": {"weight_multiplier": 1.2, "prefer": ["madrox_rant"]},
            "playful": {"weight_multiplier": 1.5, "prefer": ["greeting", "carnie_offer"]},
            "tense": {"weight_multiplier": 0.8, "prefer": []}
        }
    
    def get_response(self, entity, context: str, target=None, **kwargs) -> str:
        """Generate a response based on context."""
        templates = self.templates.get(context, [])
        if not templates:
            return "..."
        
        # Get mood modifier
        mood = self._determine_mood(entity)
        mod = self.mood_modifiers.get(mood, {})
        
        # Apply weight multiplier
        multiplier = mod.get("weight_multiplier", 1.0)
        
        # Weighted random selection
        total_weight = sum(t.get("weight", 1.0) for t in templates) * multiplier
        r = random.random() * total_weight
        
        chosen = templates[0]
        for t in templates:
            r -= t.get("weight", 1.0) * multiplier
            if r <= 0:
                chosen = t
                break
        
        # Fill placeholders
        placeholders = self._get_placeholders(entity, target, context, **kwargs)
        try:
            return chosen["text"].format(**placeholders)
        except KeyError:
            return chosen["text"]
    
    def _determine_mood(self, entity) -> str:
        """Determine entity's current mood."""
        # Check for Madrox
        if hasattr(entity, 'get_component'):
            madrox = entity.get_component('madrox')
            if madrox and madrox.active:
                return "angry"
        
        # Check energy
        energy = getattr(entity, 'energy', 50)
        if energy > 80:
            return "playful"
        elif energy < 20:
            return "tense"
        
        return "neutral"
    
    def _get_placeholders(self, entity, target, context: str, **kwargs) -> Dict[str, str]:
        """Build placeholder dict for template formatting."""
        placeholders = {
            "name": getattr(entity, 'name', str(getattr(entity, 'uid', 'unknown'))),
            "energy": f"{getattr(entity, 'energy', 50):.0f}",
            "role": getattr(entity, 'role', 'unknown'),
            "cause": "",
            "fizz": kwargs.get("fizz", "fresh")
        }
        
        # Add Madrox cause if applicable
        if hasattr(entity, 'get_component'):
            madrox = entity.get_component('madrox')
            if madrox and madrox.active:
                placeholders["cause"] = madrox.cause
        
        # Add target info
        if target:
            placeholders["target_name"] = getattr(target, 'name', 'someone')
        
        return placeholders

# =============================================================================
# FAYGO COMPONENT
# =============================================================================

class FaygoComponent(Component):
    """Faygo inventory and usage."""
    
    def __init__(self):
        super().__init__("faygo")
        self.inventory = 0
        self.fizz_timers = []  # list of (tick_acquired, flavor) for tracking freshness
        self.faygo_fizz = FAYGO_FIZZ_FRESH
    
    def acquire(self, amount: int = 1, flavor: FaygoFlavor = FaygoFlavor.WATERMELON) -> None:
        current_tick = 0
        if self.entity and hasattr(self.entity, 'engine'):
            current_tick = self.entity.engine.time_sys.total_ticks
        for _ in range(amount):
            self.inventory += 1
            self.fizz_timers.append((current_tick, flavor))
        self.faygo_fizz = FAYGO_FIZZ_FRESH
    
    def use(self, mode: FaygoMode, target=None) -> dict:
        """Use a Faygo. Returns effect dict."""
        if self.inventory <= 0:
            return {"success": False, "reason": "no_faygo"}
        
        # Get oldest Faygo
        if not self.fizz_timers:
            return {"success": False, "reason": "no_faygo_data"}
        
        oldest_tick, flavor = self.fizz_timers[0]
        
        # Determine current tick
        current_tick = 0
        if self.entity and hasattr(self.entity, 'engine'):
            current_tick = self.entity.engine.time_sys.total_ticks
        
        # Determine fizz level
        age = current_tick - oldest_tick
        is_fresh = age < FAYGO_FRESH_DURATION
        self.faygo_fizz = max(0.0, FAYGO_FIZZ_FRESH - (age * FAYGO_FIZZ_DECAY))
        
        # Adjust mode based on freshness
        if not is_fresh and mode in [FaygoMode.SHOOK, FaygoMode.CHUG]:
            mode = FaygoMode.FLAT
        
        # Consume
        self.inventory -= 1
        self.fizz_timers.pop(0)
        
        # Apply effects
        effects = self._get_flavor_effects(mode, flavor, is_fresh)
        result = {"success": True, "mode": mode.value, "flavor": flavor.value, "effects": effects.copy()}
        
        if not self.entity:
            return result
        
        # Apply energy
        if "energy" in effects:
            new_energy = max(0, min(100, getattr(self.entity, 'energy', 50) + effects["energy"]))
            setattr(self.entity, 'energy', new_energy)
        
        # Apply anxiety
        if "anxiety" in effects and hasattr(self.entity, 'anx_cur'):
            self.entity.anx_cur.anxiety = max(0, min(1, getattr(self.entity.anx_cur, 'anxiety', 0.5) + effects["anxiety"]))
        
        # Apply arousal
        if "arousal" in effects and hasattr(self.entity, 'arousal_level'):
            self.entity.arousal_level = min(5, max(0, self.entity.arousal_level + effects["arousal"]))
        
        # Apply target effects
        if "target_energy" in effects and target:
            target.energy = max(0, min(100, getattr(target, 'energy', 50) + effects["target_energy"]))
        
        # Apply cleanse
        if "cleanse" in effects and effects["cleanse"]:
            self.entity.poison_level = 0
            self.entity.thirst = max(0, getattr(self.entity, 'thirst', 0.5) - 0.5)
        
        # Brain freeze
        if "brain_freeze_chance" in effects and random.random() < effects["brain_freeze_chance"]:
            if hasattr(self.entity, 'scg'):
                self.entity.scg.clarity_score *= 0.8
            result["brain_freeze"] = True
        
        # Post event
        if hasattr(self.entity, 'engine') and hasattr(self.entity.engine, 'event_manager'):
            self.entity.engine.event_manager.post(Event(
                type="faygo_use",
                source=self.entity,
                target=target,
                data={
                    "mode": mode.value,
                    "flavor": flavor.value,
                    "fizz": self.faygo_fizz,
                    "flat": not is_fresh
                }
            ))
        
        return result
    
    def _get_flavor_effects(self, mode: FaygoMode, flavor: FaygoFlavor, is_fresh: bool) -> Dict[str, Any]:
        """Get effects based on mode and flavor."""
        base_effects = FAYGO_EFFECTS.get(mode.value, {}).copy()
        
        # Flavor modifiers
        flavor_mult = 1.0
        if flavor == FaygoFlavor.WATERMELON:
            flavor_mult = 1.3  # Burst effect
        elif flavor == FaygoFlavor.PINEAPPLE:
            flavor_mult = 1.1  # Control effect
        elif flavor == FaygoFlavor.GRAPE:
            flavor_mult = 0.8  # Delayed effect
        elif flavor == FaygoFlavor.ORANGE:
            flavor_mult = 1.0  # Balanced
        elif flavor == FaygoFlavor.ROOT_BEER:
            flavor_mult = 1.2  # Slow growth
        elif flavor == FaygoFlavor.COTTON_CANDY:
            flavor_mult = 1.5  # Sweet variance
        
        # Apply multiplier to numeric effects
        for key in ["energy", "arousal", "target_energy", "anxiety"]:
            if key in base_effects and isinstance(base_effects[key], (int, float)):
                base_effects[key] *= flavor_mult
        
        return base_effects
    
    def update(self, tick: int) -> None:
        """Fizz decays over time."""
        if self.fizz_timers and self.entity and hasattr(self.entity, 'engine'):
            current_tick = self.entity.engine.time_sys.total_ticks
            self.faygo_fizz = max(0.0, FAYGO_FIZZ_FRESH - ((current_tick - self.fizz_timers[0][0]) * FAYGO_FIZZ_DECAY))

# =============================================================================
# MADROX COMPONENT
# =============================================================================

class MadroxComponent(Component):
    """Jamie Madrox state - the overthinker."""
    
    def __init__(self):
        super().__init__("madrox")
        self.active = False
        self.timer = 0
        self.counter = 0
        self.bias_multiplier = MADROX_BIAS_MULTIPLIER
        self.cause = ""
        self.biases = {}
    
    def enter(self, cause: str = "") -> None:
        self.active = True
        self.timer = MADROX_MAX_DURATION
        self.cause = cause or "defending the truth"
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Madrox] {getattr(self.entity, 'uid', 'unknown')} has entered the Madrox state. Cause: {self.cause}")
    
    def exit(self) -> None:
        self.active = False
        self.timer = 0
        self.biases.clear()
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Madrox] {getattr(self.entity, 'uid', 'unknown')} has emerged from the Madrox state.")
    
    def update(self, tick: int) -> None:
        if not self.active:
            return
        
        self.timer -= 1
        
        # Check exit conditions
        anxiety = 0.5
        if self.entity and hasattr(self.entity, 'anx_cur'):
            anxiety = getattr(self.entity.anx_cur, 'anxiety', 0.5)
        
        if self.timer <= 0 or anxiety < 0.4:
            self.exit()
    
    def handle_event(self, event: Event) -> bool:
        """React to events that might trigger Madrox state."""
        if not self.active and event.type == "bond_decrease":
            # Bond decreases can trigger Madrox state
            if self.entity and event.source == self.entity:
                if random.random() < 0.3:
                    self.enter("a bond was broken")
        return False

# =============================================================================
# CARNIE COMPONENT
# =============================================================================

class CarnieComponent(Component):
    """Monoxide - the Wraith-spawned carnie."""
    
    def __init__(self):
        super().__init__("carnie")
        self.active = False
        self.mode = CarnieMode.WORKING
        self.sub_mode = None
        self.timer = 0
        self.original_role = ""
        self.games_offered = 0
        self.rumors_generated = 0
    
    def activate(self, original_role: str) -> None:
        self.active = True
        self.mode = CarnieMode.WORKING
        self.original_role = original_role
        self.timer = 0
        if self.entity:
            self.entity.role = "CARNIE"
            if hasattr(self.entity, 'engine'):
                self.entity.engine.add_log(f"[Carnie] {getattr(self.entity, 'uid', 'unknown')} is now running the midway.")
    
    def deactivate(self) -> None:
        self.active = False
        if self.entity and self.original_role:
            self.entity.role = self.original_role
            if hasattr(self.entity, 'engine'):
                self.entity.engine.add_log(f"[Carnie] {getattr(self.entity, 'uid', 'unknown')} returns to being {self.original_role}.")
    
    def update(self, tick: int) -> None:
        if not self.active:
            return
        
        # Energy drain while working
        if self.mode == CarnieMode.WORKING:
            if hasattr(self.entity, 'energy') and self.entity.energy < 30:
                self.enter_smoke_break()
            elif hasattr(self.entity, 'energy'):
                self.entity.energy -= CARNIE_WORKING_ENERGY_DRAIN
        else:
            # Smoke break
            self.timer -= 1
            if self.timer <= 0:
                self.exit_smoke_break()
    
    def enter_smoke_break(self):
        self.mode = CarnieMode.SMOKE_BREAK
        self.sub_mode = random.choice([CarnieMode.SMOKE_GOSSIP, CarnieMode.SMOKE_CHILL])
        self.timer = random.randint(CARNIE_SMOKE_BREAK_MIN, CARNIE_SMOKE_BREAK_MAX)
        
        # If chill mode, Wraith may nudge toward Madrox particles
        if self.sub_mode == CarnieMode.SMOKE_CHILL and self.entity:
            if hasattr(self.entity, 'engine') and hasattr(self.entity.engine, 'social_hub'):
                engine = self.entity.engine
                for e in engine.social_hub.entities:
                    if hasattr(e, 'alive') and e.alive and hasattr(e, 'get_component'):
                        madrox = e.get_component('madrox')
                        if (madrox and madrox.active and 
                            madrox.timer < MADROX_MAX_DURATION - MADROX_CHILL_DURATION):
                            engine.add_log(f"[Wraith] Carnie {getattr(self.entity, 'uid', 'unknown')} is chilling near {getattr(e, 'uid', 'unknown')}.")
    
    def exit_smoke_break(self):
        self.mode = CarnieMode.WORKING
        self.sub_mode = None
    
    def offer_game(self, participant):
        """Offer a carnival game to another entity."""
        self.games_offered += 1
        games = ["ring_toss", "milk_bottle", "guess_weight"]
        game = random.choice(games)
        
        playfulness = getattr(participant, 'stats', type('obj', (), {'playfulness': 50}))
        success_chance = 0.3 + getattr(playfulness, 'playfulness', 50) / 200.0
        
        if random.random() < success_chance:
            reward = "Faygo" if random.random() < 0.5 else "energy"
            return {"game": game, "won": True, "reward": reward}
        return {"game": game, "won": False, "reward": None}

# =============================================================================
# DANGER STATE COMPONENT
# =============================================================================

class DangerStateComponent(Component):
    """Manages temporary danger zone states."""
    
    def __init__(self):
        super().__init__("danger_state")
        self.current_state: Optional[DangerState] = None
        self.timer = 0
        self.data = {}
    
    def enter(self, state: DangerState, data: dict = None) -> None:
        self.current_state = state
        self.data = data or {}
        
        # Set duration
        duration_range = DANGER_STATE_DURATIONS.get(state.value, (50, 150))
        if duration_range:
            self.timer = random.randint(*duration_range)
        else:
            self.timer = -1  # indefinite
        
        if self.entity and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Danger] {getattr(self.entity, 'uid', 'unknown')} enters {state.value} state.")
    
    def exit(self) -> None:
        if self.entity and self.current_state and hasattr(self.entity, 'engine'):
            self.entity.engine.add_log(f"[Danger] {getattr(self.entity, 'uid', 'unknown')} exits {self.current_state.value} state.")
        self.current_state = None
        self.timer = 0
        self.data.clear()
    
    def update(self, tick: int) -> None:
        if self.current_state is None:
            return
        
        if self.timer > 0:
            self.timer -= 1
            if self.timer == 0:
                self.exit()
        
        # State-specific updates
        if self.current_state == DangerState.LOST_AT_THE_CARNIVAL:
            self._update_lost()
        elif self.current_state == DangerState.THE_MIDWAY:
            self._update_midway_gambling()
    
    def _update_lost(self):
        """Lost particles wander and hallucinate."""
        if not self.entity:
            return
        
        # Random movement
        if hasattr(self.entity, 'engine') and hasattr(self.entity.engine, 'biome'):
            engine = self.entity.engine
            self.entity.x = max(0, min(engine.biome.w - 1, 
                                       getattr(self.entity, 'x', 0) + random.choice([-1, 0, 1])))
            self.entity.y = max(0, min(engine.biome.h - 1,
                                       getattr(self.entity, 'y', 0) + random.choice([-1, 0, 1])))
        
        # Occasional false memory
        if random.random() < 0.05 and hasattr(self.entity, 'grimoire'):
            self.entity.grimoire.update({
                "type": "hallucination",
                "description": f"I see someone familiar...",
                "importance": 0.3
            }, is_vivid=True)
    
    def _update_midway_gambling(self):
        """Midway state: decide whether to keep gambling or walk away."""
        if not self.entity:
            return
        
        desperation = self.data.get("desperation", 0)
        consecutive_losses = self.data.get("consecutive_losses", 0)
        
        # Internal conflict
        play_chance = max(0.3, 0.7 - desperation * 0.05)
        
        if random.random() < play_chance:
            # Play again
            game = random.choice(["ring_toss", "milk_bottle", "wheel"])
            playfulness = getattr(self.entity, 'stats', type('obj', (), {'playfulness': 50}))
            win = random.random() < (0.3 + getattr(playfulness, 'playfulness', 50) / 200.0)
            
            if win:
                self.entity.energy = getattr(self.entity, 'energy', 50) + 10
                self.data["consecutive_losses"] = 0
                self.enter(DangerState.JUGGALO_PARTY)
            else:
                self.entity.energy = max(0, getattr(self.entity, 'energy', 50) - 5)
                consecutive_losses += 1
                self.data["consecutive_losses"] = consecutive_losses
                desperation += 0.1
                self.data["desperation"] = desperation
                
                if consecutive_losses >= 3:
                    self.enter(DangerState.GET_CLOWNED, {"humiliation_source": "the_carnie"})
        else:
            # Walk away
            if desperation > 0.5:
                self.enter(DangerState.GET_CLOWNED)
            else:
                self.exit()

# =============================================================================
# MAGNETIC FIELDS SYSTEM
# =============================================================================

class MagneticFieldsSystem:
    """Manages invisible attraction/repulsion fields."""
    
    def __init__(self):
        self.field_vectors = {}
    
    def update_entity(self, entity, engine) -> None:
        """Apply magnetic bias to entity movement."""
        if not hasattr(entity, 'get_component'):
            return
        
        madrox = entity.get_component('madrox')
        if not (madrox and madrox.active):
            return
        
        # Find all calming sources
        calming_sources = self._find_calming_sources(entity, engine)
        if not calming_sources:
            return
        
        # Compute net field vector
        net_vector = self._compute_field_bias(entity, calming_sources)
        
        # Apply bias with 10% chance
        if random.random() < 0.1 and (abs(net_vector[0]) > 0 or abs(net_vector[1]) > 0):
            dx = 1 if net_vector[0] > 0 else -1 if net_vector[0] < 0 else 0
            dy = 1 if net_vector[1] > 0 else -1 if net_vector[1] < 0 else 0
            
            if hasattr(entity, 'x') and hasattr(entity, 'y'):
                new_x = max(0, min(engine.biome.w - 1 if hasattr(engine, 'biome') else 40, 
                                  getattr(entity, 'x', 0) + dx))
                new_y = max(0, min(engine.biome.h - 1 if hasattr(engine, 'biome') else 20, 
                                  getattr(entity, 'y', 0) + dy))
                entity.x, entity.y = new_x, new_y
        
        # Apply proximity calming
        self._apply_proximity_calming(entity, calming_sources)
    
    def _find_calming_sources(self, entity, engine) -> List[Tuple]:
        """Find all calming sources within range."""
        sources = []
        
        if not hasattr(engine, 'social_hub'):
            return sources
        
        for e in engine.social_hub.entities:
            if not (hasattr(e, 'alive') and e.alive and getattr(e, 'uid', None) != getattr(entity, 'uid', None)):
                continue
            
            strength = self._get_calm_strength(e)
            if strength <= 0:
                continue
            
            # Check distance
            dx = getattr(e, 'x', 0) - getattr(entity, 'x', 0)
            dy = getattr(e, 'y', 0) - getattr(entity, 'y', 0)
            dist = math.sqrt(dx**2 + dy**2)
            
            if dist <= CALM_FIELD_RADIUS:
                sources.append((e, strength, dist))
        
        return sources
    
    def _get_calm_strength(self, entity) -> float:
        """Get calm field strength of an entity."""
        if hasattr(entity, 'get_component'):
            carnie = entity.get_component('carnie')
            if carnie and carnie.active and carnie.sub_mode == CarnieMode.SMOKE_CHILL:
                return MONOXIDE_CALM_STRENGTH * 1.5
            if carnie and carnie.active:
                return MONOXIDE_CALM_STRENGTH * 0.7
        
        return CALM_BASE_STRENGTH
    
    def _compute_field_bias(self, entity, calming_sources: List[Tuple]) -> Tuple[float, float]:
        """Compute net magnetic vector from all calming sources."""
        net_x, net_y = 0.0, 0.0
        
        for source, strength, dist in calming_sources:
            dx = getattr(source, 'x', 0) - getattr(entity, 'x', 0)
            dy = getattr(source, 'y', 0) - getattr(entity, 'y', 0)
            
            if dist == 0:
                continue
            
            # Distance weight function (parabolic around optimal distance)
            d = dist
            optimal = MADROX_OPTIMAL_DIST
            spread = (MADROX_OUTER_RADIUS - MADROX_INNER_RADIUS) / 2
            
            w = 1 - ((d - optimal) ** 2) / (spread ** 2)
            w = max(-1, min(1, w))
            w *= strength
            
            net_x += (dx / dist) * w
            net_y += (dy / dist) * w
        
        return (net_x, net_y)
    
    def _apply_proximity_calming(self, entity, calming_sources: List[Tuple]) -> None:
        """Apply calming effect when in proximity."""
        for source, strength, dist in calming_sources:
            if dist <= 3:
                base_rate = CALM_BASE_RATE * strength
                
                # Resistance based on Madrox duration
                madrox = entity.get_component('madrox') if hasattr(entity, 'get_component') else None
                if madrox:
                    duration = MADROX_MAX_DURATION - madrox.timer
                    resistance = min(0.77, duration / MADROX_MAX_DURATION * 0.77)
                    calm_rate = base_rate * (1 - resistance)
                else:
                    calm_rate = base_rate
                
                # Apply anxiety reduction
                if hasattr(entity, 'anx_cur'):
                    entity.anx_cur.anxiety = max(0, getattr(entity.anx_cur, 'anxiety', 0.5) - calm_rate)
                
                # If Carnie in chill mode, offer smoke
                carnie = source.get_component('carnie') if hasattr(source, 'get_component') else None
                if carnie and carnie.sub_mode == CarnieMode.SMOKE_CHILL and madrox:
                    if random.random() < 0.05:
                        if hasattr(entity, 'engine'):
                            entity.engine.add_log(f"[Carnie] Smoke offered to {getattr(entity, 'uid', 'unknown')}.")
                            madrox.timer = max(0, madrox.timer - 100)
                            madrox.bias_multiplier *= 0.5

# =============================================================================
# RUMOR SYSTEM
# =============================================================================

@dataclass
class Rumor:
    """A piece of information that spreads through the world."""
    text: str
    truth: float = 0.5
    source: Optional[str] = None
    timestamp: int = 0
    spread_count: int = 0
    tags: List[str] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []

class RumorManager:
    """Manages global rumor propagation."""
    
    def __init__(self):
        self.rumors: List[Rumor] = []
        self.max_rumors = 100
    
    def create_rumor(self, text: str, truth: float = 0.5, source: str = None, 
                     timestamp: int = 0, tags: List[str] = None) -> Rumor:
        """Create and store a new rumor."""
        rumor = Rumor(
            text=text,
            truth=max(0.0, min(1.0, truth)),
            source=source,
            timestamp=timestamp,
            tags=tags or []
        )
        self.rumors.append(rumor)
        
        if len(self.rumors) > self.max_rumors:
            self.rumors.pop(0)
        
        return rumor
    
    def spread_rumor(self, rumor: Rumor, listener, teller, engine) -> bool:
        """Spread a rumor from teller to listener."""
        # Check if listener is interested
        genes = getattr(listener, 'genes', {})
        if genes.get('curiosity', 0.5) < 0.3:
            return False
        
        # Boost curiosity
        if hasattr(listener, 'curiosity'):
            listener.curiosity = min(1.0, getattr(listener, 'curiosity', 0.5) + 0.05)
        
        # Store in listener's grimoire
        if hasattr(listener, 'grimoire'):
            listener.grimoire.update({
                "type": "rumor",
                "text": rumor.text,
                "source": getattr(teller, 'uid', 'unknown'),
                "truth": rumor.truth,
                "importance": 0.5
            }, is_vivid=True)
        
        # Update rumor spread count
        rumor.spread_count += 1
        
        # Log
        if hasattr(engine, 'add_log'):
            engine.add_log(f"[Rumor] Spreading: \"{rumor.text[:30]}...\" (truth: {rumor.truth:.1f})")
        
        return True
    
    def get_random_rumor(self, min_truth: float = 0.0, max_truth: float = 1.0) -> Optional[Rumor]:
        """Get a random rumor within truth range."""
        candidates = [r for r in self.rumors if min_truth <= r.truth <= max_truth]
        return random.choice(candidates) if candidates else None
    
    def get_rumors_by_tag(self, tag: str) -> List[Rumor]:
        """Get all rumors with a specific tag."""
        return [r for r in self.rumors if tag in r.tags]

# =============================================================================
# MIDWAY BIOME
# =============================================================================

class MidwayBiome:
    """Manages the carnival/festival Midway biome overlay."""
    
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        
        # Festival data: (x, y) -> {cover_crop, field_strength, duration, created_tick}
        self.festival_data: Dict[Tuple[int, int], Dict] = {}
        
        # Field contributions
        self.field_contributors = {}
        
        # Cover crop types
        self.available_crops = list(CoverCropType)
    
    def create_festival(self, x: int, y: int, duration: int = 200, engine=None) -> None:
        """Create a new festival at the given location."""
        if not (0 <= x < self.width and 0 <= y < self.height):
            return
        
        # Choose random cover crop
        crop_type = random.choice(self.available_crops)
        
        self.festival_data[(x, y)] = {
            "cover_crop": crop_type.value,
            "field_strength": MIDWAY_BASE_FIELD,
            "duration": duration,
            "created_tick": 0 if not engine else getattr(engine.time_sys, 'total_ticks', 0),
            "residue": 0
        }
        
        if engine and hasattr(engine, 'add_log'):
            engine.add_log(f"[Midway] Festival created at ({x}, {y}) with {crop_type.value} crops.")
    
    def contribute_to_field(self, amount: float, entity, engine=None) -> None:
        """Contribute to the field strength at entity's location."""
        if not hasattr(entity, 'x') or not hasattr(entity, 'y'):
            return
        
        x, y = entity.x, entity.y
        
        # Find nearest festival
        nearest = None
        nearest_dist = float('inf')
        
        for (fx, fy), data in self.festival_data.items():
            dist = abs(x - fx) + abs(y - fy)
            if dist < nearest_dist and dist <= MIDWAY_RADIUS:
                nearest_dist = dist
                nearest = (fx, fy, data)
        
        if nearest:
            fx, fy, data = nearest
            
            # Apply cover crop multiplier
            crop_type = data.get("cover_crop", "CLOVER")
            crop_data = COVER_CROP_TYPES.get(crop_type, {})
            faygo_boost = crop_data.get("faygo_boost", 1.0)
            
            # Apply consent bonus if applicable
            consent_bonus = 1.0
            if hasattr(entity, 'kanban') and hasattr(entity.kanban, 'consent_level'):
                if entity.kanban.consent_level >= 0.7:
                    consent_bonus = 1.0 + CONSENT_BONUS
            
            data["field_strength"] = min(
                MIDWAY_MAX_FIELD,
                data["field_strength"] + amount * faygo_boost * consent_bonus
            )
    
    def update(self, tick: int, engine=None) -> None:
        """Update all festivals."""
        current_tick = 0
        if engine and hasattr(engine, 'time_sys'):
            current_tick = engine.time_sys.total_ticks
        
        to_remove = []
        
        for (x, y), data in self.festival_data.items():
            # Decay field strength
            data["field_strength"] = max(0, data["field_strength"] * (1 - FIELD_DECAY_RATE))
            
            # Check duration
            created_tick = data.get("created_tick", 0)
            duration = data.get("duration", 200)
            
            if current_tick - created_tick >= duration:
                # Festival ended, apply residue
                if data["field_strength"] > FIELD_HIGH_THRESHOLD:
                    data["residue"] = RESIDUE_DURATION
                to_remove.append((x, y))
            
            # Decay residue
            if data.get("residue", 0) > 0:
                data["residue"] = max(0, data["residue"] - 1)
        
        for pos in to_remove:
            if engine and hasattr(engine, 'add_log'):
                engine.add_log(f"[Midway] Festival at {pos} ended.")
            if self.festival_data[pos].get("residue", 0) <= 0:
                del self.festival_data[pos]
    
    def get_field_strength(self, x: int, y: int) -> float:
        """Get field strength at a position."""
        for (fx, fy), data in self.festival_data.items():
            if abs(x - fx) + abs(y - fy) <= MIDWAY_RADIUS:
                return data["field_strength"]
        return 0.0
    
    def get_cover_crop_effect(self, x: int, y: int) -> Dict:
        """Get cover crop effects at a position."""
        for (fx, fy), data in self.festival_data.items():
            if abs(x - fx) + abs(y - fy) <= MIDWAY_RADIUS:
                crop_type = data.get("cover_crop", "CLOVER")
                return COVER_CROP_TYPES.get(crop_type, {})
        return {}

# =============================================================================
# JUGGALO PARTY
# =============================================================================

@dataclass
class JuggaloParty:
    """A party celebration at a location."""
    x: int
    y: int
    level: int = 1
    temperature: float = 0.5
    growth: float = 0.0
    participants: List[str] = field(default_factory=list)
    created_tick: int = 0
    
    def get_radius(self) -> int:
        """Get party radius based on level."""
        benefits = PARTY_BENEFITS.get(self.level, PARTY_BENEFITS[1])
        return benefits["radius"]
    
    def get_benefits(self) -> Dict:
        """Get party benefits based on level."""
        return PARTY_BENEFITS.get(self.level, PARTY_BENEFITS[1])

class JuggaloPartyManager:
    """Manages all active parties."""
    
    def __init__(self):
        self.parties: List[JuggaloParty] = []
        self.party_timeout = PARTY_TIMEOUT
        self.growth_decay_ticks = PARTY_GROWTH_DECAY_TICKS
    
    def check_party_trigger(self, x: int, y: int, entities, engine=None) -> Optional[JuggaloParty]:
        """Check if a party should be triggered at this location."""
        # Count nearby entities with high valence
        nearby = []
        for e in entities:
            if hasattr(e, 'x') and hasattr(e, 'y') and hasattr(e, 'alive') and e.alive:
                if abs(e.x - x) + abs(e.y - y) <= 2:
                    valence = getattr(e, 'state', type('obj', (), {'valence': 3}))
                    if getattr(valence, 'valence', 3) >= 4:
                        nearby.append(e)
        
        if len(nearby) >= PARTY_MIN_PARTICIPANTS:
            # Create party
            party = JuggaloParty(
                x=x,
                y=y,
                level=1,
                temperature=0.5,
                growth=0.0,
                participants=[getattr(e, 'uid', 'unknown') for e in nearby],
                created_tick=0 if not engine else getattr(engine.time_sys, 'total_ticks', 0)
            )
            self.parties.append(party)
            
            if engine and hasattr(engine, 'add_log'):
                engine.add_log(f"[Party] Juggalo Party started at ({x}, {y}) with {len(nearby)} participants!")
            
            return party
        
        return None
    
    def update(self, tick: int, entities, engine=None) -> None:
        """Update all parties."""
        current_tick = 0
        if engine and hasattr(engine, 'time_sys'):
            current_tick = engine.time_sys.total_ticks
        
        to_remove = []
        
        for party in self.parties:
            # Decay growth
            party.growth = max(0, party.growth - 1.0 / self.growth_decay_ticks)
            
            # Decay temperature
            party.temperature = max(0, party.temperature - PARTY_TEMP_DECAY)
            
            # Check for timeout (no recent activity)
            if party.growth <= 0 and party.temperature < 0.2:
                to_remove.append(party)
                continue
            
            # Pull nearby entities
            self._pull_entities(party, entities, engine)
            
            # Level up if growth is high enough
            if party.growth >= 100 and party.level < 5:
                party.level += 1
                party.growth = 0
                
                if engine and hasattr(engine, 'add_log'):
                    engine.add_log(f"[Party] Party at ({party.x}, {party.y}) leveled up to {party.level}!")
        
        for party in to_remove:
            self.parties.remove(party)
            if engine and hasattr(engine, 'add_log'):
                engine.add_log(f"[Party] Party at ({party.x}, {party.y}) ended.")
    
    def _pull_entities(self, party: JuggaloParty, entities, engine=None) -> None:
        """Pull nearby entities toward the party."""
        radius = party.get_radius() * PULL_RADIUS_MULTIPLIER
        
        for e in entities:
            if not (hasattr(e, 'x') and hasattr(e, 'y') and hasattr(e, 'alive') and e.alive):
                continue
            
            dx = party.x - e.x
            dy = party.y - e.y
            dist = abs(dx) + abs(dy)
            
            if dist <= radius and dist > 0:
                # Pull chance based on party temperature
                pull_chance = PULL_BASE_CHANCE * party.temperature
                
                if random.random() < pull_chance:
                    # Move toward party
                    move_x = 1 if dx > 0 else -1 if dx < 0 else 0
                    move_y = 1 if dy > 0 else -1 if dy < 0 else 0
                    
                    e.x += move_x
                    e.y += move_y
                    
                    # Add to participants if not already
                    uid = getattr(e, 'uid', 'unknown')
                    if uid not in party.participants:
                        party.participants.append(uid)
                        party.temperature = min(1.0, party.temperature + 0.1)
    
    def add_contribution(self, x: int, y: int, contribution_type: str, engine=None) -> None:
        """Add a contribution to a nearby party."""
        for party in self.parties:
            if abs(party.x - x) + abs(party.y - y) <= party.get_radius():
                amount = PARTY_GROWTH_CONTRIBUTIONS.get(contribution_type, 1.0)
                party.growth = min(100, party.growth + amount)
                party.temperature = min(1.0, party.temperature + 0.05)
                break
    
    def get_party_at(self, x: int, y: int) -> Optional[JuggaloParty]:
        """Get party at a specific location."""
        for party in self.parties:
            if abs(party.x - x) + abs(party.y - y) <= party.get_radius():
                return party
        return None

# =============================================================================
# COP MOMENT
# =============================================================================

class CopMoment:
    """A truce scenario between rivals."""
    
    def __init__(self, entity_a, entity_b):
        self.entity_a = entity_a
        self.entity_b = entity_b
        self.timer = 100
        self.active = True
        self.bond_strength_before = 0.0
    
    def update(self, tick: int, engine=None) -> bool:
        """Update the cop moment. Returns True if still active."""
        self.timer -= 1
        
        if self.timer <= 0:
            self.end(engine)
            return False
        
        # Move together
        if hasattr(self.entity_a, 'x') and hasattr(self.entity_b, 'x'):
            mid_x = (self.entity_a.x + self.entity_b.x) // 2
            mid_y = (self.entity_a.y + self.entity_b.y) // 2
            
            # Move toward midpoint
            if self.entity_a.x < mid_x: self.entity_a.x += 1
            elif self.entity_a.x > mid_x: self.entity_a.x -= 1
            
            if self.entity_a.y < mid_y: self.entity_a.y += 1
            elif self.entity_a.y > mid_y: self.entity_a.y -= 1
            
            if self.entity_b.x < mid_x: self.entity_b.x += 1
            elif self.entity_b.x > mid_x: self.entity_b.x -= 1
            
            if self.entity_b.y < mid_y: self.entity_b.y += 1
            elif self.entity_b.y > mid_y: self.entity_b.y -= 1
        
        # Strengthen bond
        if hasattr(self.entity_a, 'bonds') and hasattr(self.entity_b, 'uid'):
            bond = self.entity_a.bonds.get(self.entity_b.uid)
            if bond:
                bond.strengthen(0.01)
        
        return True
    
    def end(self, engine=None) -> None:
        """End the cop moment with awkward aftermath."""
        self.active = False
        
        # Apply aftermath debuff
        for entity in [self.entity_a, self.entity_b]:
            if hasattr(entity, 'energy'):
                entity.energy = max(0, entity.energy - 10)
            
            if hasattr(entity, 'grimoire'):
                entity.grimoire.update({
                    "type": "cop_moment",
                    "description": "That was weird...",
                    "importance": 0.6
                }, is_vivid=True)
        
        if engine and hasattr(engine, 'add_log'):
            engine.add_log(f"[CopMoment] Cop moment between {getattr(self.entity_a, 'uid', 'unknown')} and {getattr(self.entity_b, 'uid', 'unknown')} ended.")

class CopMomentManager:
    """Manages active cop moments."""
    
    def __init__(self):
        self.active_moments: List[CopMoment] = []
    
    def check_trigger(self, entity_a, entity_b, engine=None) -> bool:
        """Check if a cop moment should trigger between two entities."""
        # Check if they are rivals (low bond strength, tense relationship)
        if not hasattr(entity_a, 'bonds') or not hasattr(entity_b, 'uid'):
            return False
        
        bond = entity_a.bonds.get(entity_b.uid)
        if not bond or bond.strength > 0.3:
            return False
        
        # Check if both have high arousal
        arousal_a = getattr(entity_a, 'arousal_level', 0)
        arousal_b = getattr(entity_b, 'arousal_level', 0)
        
        if arousal_a < 3 or arousal_b < 3:
            return False
        
        # Check distance
        if not (hasattr(entity_a, 'x') and hasattr(entity_b, 'x')):
            return False
        
        dist = abs(entity_a.x - entity_b.x) + abs(entity_a.y - entity_b.y)
        if dist > 2:
            return False
        
        # Trigger cop moment
        moment = CopMoment(entity_a, entity_b)
        self.active_moments.append(moment)
        
        if engine and hasattr(engine, 'add_log'):
            engine.add_log(f"[CopMoment] Cop moment triggered between {getattr(entity_a, 'uid', 'unknown')} and {getattr(entity_b, 'uid', 'unknown')}!")
        
        return True
    
    def update(self, tick: int, engine=None) -> None:
        """Update all active cop moments."""
        self.active_moments = [m for m in self.active_moments if m.update(tick, engine)]

# =============================================================================
# DLC 1 PACKAGE INITIALIZATION
# =============================================================================

class DLC1Manager:
    """Main manager for all DLC 1 systems."""
    
    def __init__(self, engine):
        self.engine = engine
        
        # Initialize systems
        self.event_manager = EventManager()
        self.archetype_manager = ArchetypeManager()
        self.dialogue_manager = DialogueManager()
        self.magnetic_fields = MagneticFieldsSystem()
        self.rumor_manager = RumorManager()
        self.midway = MidwayBiome(40, 20)
        self.party_manager = JuggaloPartyManager()
        self.cop_moment_manager = CopMomentManager()
        
        # Track component classes for factory
        self.component_classes = {
            'identity': lambda: Component('identity'),
            'state': lambda: Component('state'),
            'madrox': MadroxComponent,
            'carnie': CarnieComponent,
            'danger_state': DangerStateComponent,
            'faygo': FaygoComponent
        }
        
        # Update archetype manager's component factory
        self.archetype_manager._create_component = self._create_component
    
    def _create_component(self, comp_type: str, data: dict) -> Optional[Component]:
        """Factory method for creating components."""
        comp_class = self.component_classes.get(comp_type)
        if comp_class:
            if callable(comp_class) and not isinstance(comp_class, type):
                return comp_class()
            try:
                return comp_class(**data)
            except:
                return comp_class()
        return Component(comp_type)
    
    def update(self, tick: int) -> None:
        """Update all DLC 1 systems."""
        # Update Midway
        self.midway.update(tick, self.engine)
        
        # Update parties
        entities = getattr(self.engine, 'social_hub', type('obj', (), {'entities': []})).entities
        self.party_manager.update(tick, entities, self.engine)
        
        # Update cop moments
        self.cop_moment_manager.update(tick, self.engine)
        
        # Check for party triggers
        for e in entities:
            if hasattr(e, 'x') and hasattr(e, 'y'):
                party = self.party_manager.check_party_trigger(e.x, e.y, entities, self.engine)
                if party:
                    # Apply party benefits to participants
                    for uid in party.participants:
                        for pe in entities:
                            if getattr(pe, 'uid', None) == uid:
                                benefits = party.get_benefits()
                                if 'energy_regen' in benefits:
                                    pe.energy = min(100, getattr(pe, 'energy', 50) + benefits['energy_regen'])
                                if 'curiosity' in benefits and hasattr(pe, 'curiosity'):
                                    pe.curiosity = min(1.0, getattr(pe, 'curiosity', 0.5) + benefits['curiosity'])
                                break
        
        # Check for cop moment triggers
        for i, e1 in enumerate(entities):
            for e2 in entities[i+1:]:
                self.cop_moment_manager.check_trigger(e1, e2, self.engine)
        
        # Apply magnetic fields to Madrox entities
        for e in entities:
            self.magnetic_fields.update_entity(e, self.engine)
    
    def get_state(self) -> Dict[str, Any]:
        """Get current state of all DLC 1 systems."""
        return {
            "midway": {
                "festivals": len(self.midway.festival_data),
                "locations": list(self.midway.festival_data.keys())
            },
            "parties": [
                {
                    "x": p.x,
                    "y": p.y,
                    "level": p.level,
                    "temperature": p.temperature,
                    "growth": p.growth,
                    "participants": len(p.participants)
                }
                for p in self.party_manager.parties
            ],
            "cop_moments": len(self.cop_moment_manager.active_moments),
            "rumors": len(self.rumor_manager.rumors)
        }


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    # Constants
    'MADROX_FIELD_RADIUS', 'CALM_FIELD_RADIUS', 'MADROX_OPTIMAL_DIST',
    'MADROX_MAX_DURATION', 'MADROX_BIAS_MULTIPLIER', 'CARNIE_DEPLOYMENT_MIN_TICKS',
    'FAYGO_FRESH_DURATION', 'FAYGO_FLAT_THRESHOLD', 'FAYGO_FIZZ_FRESH', 'FAYGO_FIZZ_DECAY',
    'MIDWAY_RADIUS', 'MIDWAY_BASE_FIELD', 'MIDWAY_MAX_FIELD',
    'FIELD_DECAY_RATE', 'PARTY_RADIUS_BASE', 'PARTY_MIN_PARTICIPANTS',
    'DANGER_STATE_DURATIONS', 'LEGENDARY_POWER_THRESHOLD',
    
    # Enums
    'FaygoMode', 'FaygoFlavor', 'CarnieMode', 'CoverCropType', 'DangerState', 'RumorTruth',
    
    # Component System
    'Component', 'ComponentHolder',
    
    # Event System
    'Event', 'EventManager',
    
    # Managers
    'ArchetypeManager', 'DialogueManager', 'MagneticFieldsSystem',
    'RumorManager', 'Rumor', 'MidwayBiome', 'JuggaloParty',
    'JuggaloPartyManager', 'CopMoment', 'CopMomentManager',
    
    # Components
    'FaygoComponent', 'MadroxComponent', 'CarnieComponent', 'DangerStateComponent',
    
    # Main
    'DLC1Manager'
]
```
Here's the complete DLC 1: THE MISSING LINK code in a single code block:

```python
# =============================================================================
# DLC 1: THE MISSING LINK - COMPLETE IMPLEMENTATION
# JOKE YA MIND v2 Expansion Pack
# =============================================================================

import random
import math
from collections import defaultdict, deque
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Tuple
from enum import Enum, IntEnum

# =============================================================================
# CONSTANTS
# =============================================================================

# --- Magnetic Fields ---
MADROX_FIELD_RADIUS = 12
CALM_FIELD_RADIUS = 15
MADROX_OPTIMAL_DIST = 6
MADROX_INNER_RADIUS = 3
MADROX_OUTER_RADIUS = 12
CALM_BASE_RATE = 0.01
MONOXIDE_CALM_STRENGTH = 1.0
CALM_BASE_STRENGTH = 0.3

# --- Madrox State ---
MADROX_MAX_DURATION = 500
MADROX_BIAS_MULTIPLIER = 1.5
MADROX_CHILL_DURATION = 50

# --- Carnie ---
CARNIE_DEPLOYMENT_VARIANCE_THRESHOLD = 0.2
CARNIE_DEPLOYMENT_MIN_TICKS = 200
CARNIE_WORKING_ENERGY_DRAIN = 0.1
CARNIE_SMOKE_BREAK_MIN = 30
CARNIE_SMOKE_BREAK_MAX = 100

# --- Faygo ---
FAYGO_FRESH_DURATION = 100  # ticks until flat
FAYGO_MODES = ["FLAT", "SHOOK", "SPRAY", "BATHE", "HIT_IN_FACE", "CHUG"]

FAYGO_EFFECTS = {
    "FLAT": {"energy": 10, "anxiety": -0.2},
    "SHOOK": {"energy": 20, "arousal": 2, "speed_boost": True},
    "SPRAY": {"target_energy": -5, "target_arousal": -1, "social": True},
    "BATHE": {"cleanse": True, "refresh_buff": True},
    "HIT_IN_FACE": {"target_energy": -15, "hostility": 0.3},
    "CHUG": {"energy": 30, "brain_freeze_chance": 0.2, "burp": True}
}

# --- The Midway ---
MIDWAY_RADIUS = 3
MIDWAY_POWER_DECAY = 0.001
MIDWAY_BASE_FIELD = 10
MIDWAY_MAX_FIELD = 100
RESIDUE_DURATION = 200

COVER_CROP_TYPES = {
    "CLOVER": {"faygo_boost": 1.5, "energy_regen": 0.1},
    "BORAGE": {"gossip_boost": 1.5},
    "COMFREY": {"nutrient_pump": True},
    "BUCKWHEAT": {"pest_suppression": 0.7, "rivalry_suppress": True},
    "TILLAGE_RADISH": {"movement_cost": -0.3, "path_permanence": True},
    "VETCH": {"compound_benefit": True},
    "MUSTARD": {"disease_resist": 0.5},
    "SORGHUM_SUDAN": {"power_growth": 1.5, "lush_bonus": True}
}

# --- Midway Field Strength ---
FIELD_DECAY_RATE = 0.01
FIELD_LOW_THRESHOLD = 5
FIELD_HIGH_THRESHOLD = 50

FIELD_CONTRIBUTIONS = {
    "GAME": 1,
    "FAYGO_FLAT": 1,
    "FAYGO_SHOOK": 2,
    "FAYGO_SPRAY": 2,
    "FAYGO_CHUG": 3,
    "COP_MOMENT": 5,
    "CARNIE_WORKING": 0.5,
    "CARNIE_SMOKE": 0.2
}

STAGE_MULTIPLIERS = {
    "MAIN": 1.0,
    "SIDE1": 1.5,
    "SIDE2": 0.5,
    "SIDE3": 2.0
}

CONSENT_BONUS = 0.2

# --- Juggalo Party ---
PARTY_RADIUS_BASE = 5
PARTY_MIN_PARTICIPANTS = 3
PARTY_TIMEOUT = 50
PARTY_GROWTH_PER_TICK = 1
PARTY_GROWTH_DECAY_TICKS = 50
PARTY_TEMP_DECAY = 0.1
PULL_RADIUS_MULTIPLIER = 2
PULL_BASE_CHANCE = 0.05

PARTY_GROWTH_CONTRIBUTIONS = {
    "GAME": 5,
    "FAYGO": 3,
    "NEW_BOND": 10,
    "WIN_CHALLENGE": 8,
    "COP_MOMENT": 15,
    "CHEER": 2,
    "BUY_ROUND": 20
}

PARTY_BENEFITS = {
    1: {"radius": 5, "bond_mult": 1.2, "curiosity": 0.05, "energy_regen": 0.1},
    2: {"radius": 6, "bond_mult": 1.4, "curiosity": 0.10, "energy_regen": 0.2},
    3: {"radius": 7, "bond_mult": 1.6, "curiosity": 0.15, "energy_regen": 0.3},
    4: {"radius": 8, "bond_mult": 1.8, "curiosity": 0.20, "energy_regen": 0.4},
    5: {"radius": 10, "bond_mult": 2.0, "curiosity": 0.25, "energy_regen": 0.5, "veteran_trait": True}
}

# --- Danger Zone States ---
DANGER_STATE_DURATIONS = {
    "GET_CLOWNED": (50, 150),
    "JUGGALO_PARTY": (30, 100),
    "THE_MIDWAY": None,
    "LOST_AT_THE_CARNIVAL": None,
    "I_FUCKED_A_COP": (100, 300)
}

# --- Legendary Party Spots ---
LEGENDARY_POWER_DECAY = 0.001
LEGENDARY_POWER_INCREASE_VISIT = 0.01
LEGENDARY_POWER_DECREASE_CHICKEN = 0.1
LEGENDARY_POWER_DECREASE_JUFF = 0.15
LEGENDARY_POWER_DECREASE_SKEPTIC = 0.05
LEGENDARY_POWER_THRESHOLD = 1.0

# =============================================================================
# ENUMS
# =============================================================================

class FaygoMode(Enum):
    FLAT = "flat"
    SHOOK = "shook"
    SPRAY = "spray"
    BATHE = "bathe"
    HIT_IN_FACE = "hit_in_face"
    CHUG = "chug"

class CarnieMode(Enum):
    WORKING = "working"
    SMOKE_BREAK = "smoke_break"
    SMOKE_GOSSIP = "smoke_gossip"
    SMOKE_CHILL = "smoke_chill"

class CoverCropType(Enum):
    CLOVER = "clover"
    BORAGE = "borage"
    COMFREY = "comfrey"
    BUCKWHEAT = "buckwheat"
    TILLAGE_RADISH = "tillage_radish"
    VETCH = "vetch"
    MUSTARD = "mustard"
    SORGHUM_SUDAN = "sorghum_sudan"

class DangerState(Enum):
    GET_CLOWNED = "get_clowned"
    JUGGALO_PARTY = "juggalo_party"
    THE_MIDWAY = "the_midway"
    LOST_AT_THE_CARNIVAL = "lost_at_the_carnival"
    I_FUCKED_A_COP = "i_fucked_a_cop"

class RumorTruth(Enum):
    FALSE = 0.0
    MIXED = 0.5
    TRUE = 1.0

# =============================================================================
# COMPONENT SYSTEM
# =============================================================================

class Component:
    """Base class for all components."""
    def __init__(self, name: str):
        self.name = name
        self.entity = None
    
    def on_attach(self, entity) -> None:
        self.entity = entity
    
    def on_detach(self) -> None:
        self.entity = None
    
    def update(self, tick: int) -> None:
        pass
    
    def handle_event(self, event_type: str, data: dict) -> bool:
        return False

class ComponentHolder:
    """Mixin for entities that can hold components."""
    def __init__(self):
        self.components = {}
    
    def add_component(self, name: str, component: Component) -> None:
        component.on_attach(self)
        self.components[name] = component
    
    def remove_component(self, name: str) -> None:
        if name in self.components:
            self.components[name].on_detach()
            del self.components[name]
    
    def get_component(self, name: str) -> Optional[Component]:
        return self.components.get(name)
    
    def update_components(self, tick: int) -> None:
        for comp in self.components.values():
            comp.update(tick)
    
    def dispatch_event_to_components(self, event_type: str, data: dict) -> bool:
        for comp in self.components.values():
            if comp.handle_event(event_type, data):
                return True
        return False

# =============================================================================
# EVENT SYSTEM
# =============================================================================

@dataclass
class Event:
    type: str
    source: Any = None
    target: Any = None
    data: Dict[str, Any] = field(default_factory=dict)
    tick: int = 0

class EventManager:
    """Global event bus for loose coupling."""
    def __init__(self):
        self.listeners: Dict[str, List[Callable]] = defaultdict(list)
        self.history: List[Event] = []
        self.max_history = 1000
    
    def subscribe(self, event_type: str, callback: Callable) -> None:
        self.listeners[event_type].append(callback)
    
    def unsubscribe(self, event_type: str, callback: Callable) -> None:
        if callback in self.listeners[event_type]:
            self.listeners[event_type].remove(callback)
    
    def post(self, event: Event) -> None:
        self.history.append(event)
        if len(self.history) > self.max_history:
            self.history.pop(0)
        
        for callback in self.listeners.get(event.type, []):
            try:
                callback(event)
            except Exception as e:
                print(f"[EventManager] Error in callback for {event.type}: {e}")
    
    def get_recent(self, event_type: str = None, limit: int = 10) -> List[Event]:
        if event_type:
            filtered = [e for e in self.history if e.type == event_type]
            return filtered[-limit:]
        return self.history[-limit:]

# =============================================================================
# ARCHETYPE MANAGER
# =============================================================================

class ArchetypeManager:
    """Loads and applies archetype definitions."""
    def __init__(self, archetype_dir: str = "archetypes/"):
        self.archetype_dir = archetype_dir
        self.archetypes: Dict[str, Dict] = {}
        self._load_all()
    
    def _load_all(self):
        import os
        os.makedirs(self.archetype_dir, exist_ok=True)
        for filename in os.listdir(self.archetype_dir):
            if filename.endswith('.json'):
                filepath = os.path.join(self.archetype_dir, filename)
                try:
                    import json
                    with open(filepath, 'r') as f:
                        data = json.load(f)
                        name = data.get('name')
                        if name:
                            self.archetypes[name] = data
                except Exception as e:
                    print(f"[ArchetypeManager] Failed to load {filename}: {e}")
    
    def get(self, name: str) -> Dict[str, Any]:
        return self.archetypes.get(name, {})
    
    def apply_to_entity(self, entity, archetype_name: str) -> None:
        data = self.get(archetype_name)
        if not data:
            return
        
        if 'base_stats' in data:
            stats = data['base_stats']
            for key, value in stats.items():
                if hasattr(entity, key):
                    setattr(entity, key, value)
        
        if 'components' in data:
            for comp_name, comp_data in data['components'].items():
                component = self._create_component(comp_name, comp_data)
                if component:
                    entity.add_component(comp_name, component)
        
        entity.archetype_data = data
    
    def _create_component(self, comp_type: str, data: dict) -> Optional[Component]:
        component_classes = {
            'identity': IdentityComponent,
            'state': StateComponent,
            'madrox': MadroxComponent,
            'carnie': CarnieComponent,
            'danger_state': DangerStateComponent,
            'faygo': FaygoComponent
        }
        comp_class = component_classes.get(comp_type)
        if comp_class:
            return comp_class(**data)
        return None

# =============================================================================
# DIALOGUE MANAGER
# =============================================================================

class DialogueManager:
    """Manages dialogue templates and generates responses."""
    def __init__(self, template_dir: str = "dialogue/"):
        self.template_dir = template_dir
        self.templates: Dict[str, List[dict]] = defaultdict(list)
        self.mood_modifiers: Dict[str, dict] = {}
        self._load_all()
    
    def _load_all(self):
        self._load_builtin_templates()
    
    def _load_builtin_templates(self):
        self.templates["greeting"] = [
            {"text": "Hello, {name}.", "weight": 1.0},
            {"text": "Oh, it's you again.", "weight": 0.5},
            {"text": "What brings you here?", "weight": 0.8}
        ]
        
        self.templates["madrox_rant"] = [
            {"text": "You think you understand? You don't. {cause} demands that I...", "weight": 1.0},
            {"text": "They're all watching. I know it. {cause} is the only truth.", "weight": 0.8},
            {"text": "I've seen things. Patterns you wouldn't believe. {cause}.", "weight": 0.6}
        ]
        
        self.templates["carnie_offer"] = [
            {"text": "Step right up! Test your luck!", "weight": 1.0},
            {"text": "Hey, you look like you need a distraction. Care to play?", "weight": 0.8},
            {"text": "Three rings, one treasure. What do you say?", "weight": 0.7}
        ]
        
        self.templates["faygo_offer"] = [
            {"text": "Want a Faygo? It's {fizz}.", "weight": 1.0},
            {"text": "Care for a drink? Fresh from the midway.", "weight": 0.7}
        ]
        
        self.mood_modifiers = {
            "angry": {"weight_multiplier": 1.2, "prefer": ["madrox_rant"]},
            "playful": {"weight_multiplier": 1.5, "prefer": ["greeting", "carnie_offer"]},
            "tense": {"weight_multiplier": 0.8, "prefer": []}
        }
    
    def get_response(self, entity, context: str, **kwargs) -> str:
        templates = self.templates.get(context, [])
        if not templates:
            return "..."
        
        mood = self._determine_mood(entity)
        mod = self.mood_modifiers.get(mood, {})
        
        if "prefer" in mod and context in mod["prefer"]:
            templates = [t for t in templates if "weight" in t]
        
        multiplier = mod.get("weight_multiplier", 1.0)
        
        total_weight = sum(t.get("weight", 1.0) for t in templates) * multiplier
        r = random.random() * total_weight
        
        chosen = templates[0]["text"]
        for t in templates:
            r -= t.get("weight", 1.0) * multiplier
            if r <= 0:
                chosen = t["text"]
                break
        
        placeholders = self._get_placeholders(entity, context, **kwargs)
        return chosen.format(**placeholders)
    
    def _determine_mood(self, entity) -> str:
        if hasattr(entity, 'get_component'):
            madrox = entity.get_component('madrox')
            if madrox and madrox.active:
                return "angry"
        
        if entity.energy > 80:
            return "playful"
        elif entity.energy < 20:
            return "tense"
        
        return "neutral"
    
    def _get_placeholders(self, entity, context: str, **kwargs) -> dict:
        placeholders = {
            "name": getattr(entity, 'name', str(entity.uid)),
            "energy": f"{entity.energy:.0f}",
            "role": getattr(entity, 'role', 'unknown'),
            "cause": "",
            "fizz": kwargs.get("fizz", "fresh")
        }
        
        if hasattr(entity, 'get_component'):
            madrox = entity.get_component('madrox')
            if madrox and madrox.active:
                placeholders["cause"] = madrox.cause
        
        return placeholders

# =============================================================================
# CORE COMPONENTS
# =============================================================================

class IdentityComponent(Component):
    def __init__(self, name: str, role: str = "NORMAL", age: float = 18.0):
        super().__init__("identity")
        self.name = name
        self.role = role
        self.age = age
        self.original_role = role

class StateComponent(Component):
    def __init__(self, energy: float = 80.0, valence: int = 3, engagement: int = 3):
        super().__init__("state")
        self.energy = max(0.0, min(100.0, energy))
        self.valence = max(1, min(5, valence))
        self.engagement = max(1, min(5, engagement))

class MadroxComponent(Component):
    def __init__(self):
        super().__init__("madrox")
        self.active = False
        self.timer = 0
        self.counter = 0
        self.bias_multiplier = MADROX_BIAS_MULTIPLIER
        self.cause = ""
        self.biases = {}
    
    def enter(self, cause: str = "") -> None:
        self.active = True
        self.timer = MADROX_MAX_DURATION
        self.cause = cause or "defending the truth"
        if self.entity:
            self.entity.engine.add_log(f"[Madrox] {self.entity.uid} has entered the Madrox state. Cause: {self.cause}")
    
    def exit(self) -> None:
        self.active = False
        self.timer = 0
        self.biases.clear()
        if self.entity:
            self.entity.engine.add_log(f"[Madrox] {self.entity.uid} has emerged from the Madrox state.")
    
    def update(self, tick: int) -> None:
        if not self.active:
            return
        
        self.timer -= 1
        
        anxiety = getattr(self.entity, 'anx_cur', type('obj', (object,), {'anxiety': 0}))
        if self.timer <= 0 or anxiety.anxiety < 0.4:
            self.exit()

class CarnieComponent(Component):
    def __init__(self):
        super().__init__("carnie")
        self.active = False
        self.mode = CarnieMode.WORKING
        self.sub_mode = None
        self.timer = 0
        self.original_role = ""
        self.games_offered = 0
        self.rumors_generated = 0
    
    def activate(self, original_role: str) -> None:
        self.active = True
        self.mode = CarnieMode.WORKING
        self.original_role = original_role
        self.timer = 0
        if self.entity:
            self.entity.role = "CARNIE"
            self.entity.engine.add_log(f"[Carnie] {self.entity.uid} is now running the midway.")
    
    def deactivate(self) -> None:
        self.active = False
        if self.entity and self.original_role:
            self.entity.role = self.original_role
            self.entity.engine.add_log(f"[Carnie] {self.entity.uid} returns to being {self.original_role}.")
    
    def update(self, tick: int) -> None:
        if not self.active:
            return
        
        if self.mode == CarnieMode.WORKING:
            if self.entity.energy < 30:
                self.enter_smoke_break()
            else:
                self.entity.energy -= CARNIE_WORKING_ENERGY_DRAIN
        else:
            self.timer -= 1
            if self.timer <= 0:
                self.exit_smoke_break()
    
    def enter_smoke_break(self):
        self.mode = CarnieMode.SMOKE_BREAK
        self.sub_mode = random.choice([CarnieMode.SMOKE_GOSSIP, CarnieMode.SMOKE_CHILL])
        self.timer = random.randint(CARNIE_SMOKE_BREAK_MIN, CARNIE_SMOKE_BREAK_MAX)
    
    def exit_smoke_break(self):
        self.mode = CarnieMode.WORKING
        self.sub_mode = None
    
    def offer_game(self, participant):
        self.games_offered += 1
        games = ["ring_toss", "milk_bottle", "guess_weight"]
        game = random.choice(games)
        success_chance = 0.3 + participant.stats.playfulness / 200.0
        
        if random.random() < success_chance:
            reward = "Faygo" if random.random() < 0.5 else "energy"
            return {"game": game, "won": True, "reward": reward}
        return {"game": game, "won": False, "reward": None}

class DangerStateComponent(Component):
    def __init__(self):
        super().__init__("danger_state")
        self.current_state: Optional[DangerState] = None
        self.timer = 0
        self.data = {}
    
    def enter(self, state: DangerState, data: dict = None) -> None:
        self.current_state = state
        self.data = data or {}
        
        duration_range = DANGER_STATE_DURATIONS.get(state.value, (50, 150))
        if duration_range:
            self.timer = random.randint(*duration_range)
        else:
            self.timer = -1
        
        if self.entity:
            self.entity.engine.add_log(f"[Danger] {self.entity.uid} enters {state.value} state.")
    
    def exit(self) -> None:
        if self.entity and self.current_state:
            self.entity.engine.add_log(f"[Danger] {self.entity.uid} exits {self.current_state.value} state.")
        self.current_state = None
        self.timer = 0
        self.data.clear()
    
    def update(self, tick: int) -> None:
        if self.current_state is None:
            return
        
        if self.timer > 0:
            self.timer -= 1
            if self.timer == 0:
                self.exit()

class FaygoComponent(Component):
    def __init__(self):
        super().__init__("faygo")
        self.inventory = 0
        self.fizz_timers = []
    
    def acquire(self, amount: int = 1) -> None:
        current_tick = getattr(self.entity, 'engine', type('obj', (), {})).time_sys.total_ticks
        for _ in range(amount):
            self.inventory += 1
            self.fizz_timers.append(current_tick)
    
    def use(self, mode: FaygoMode, target=None) -> dict:
        if self.inventory <= 0:
            return {"success": False, "reason": "no_faygo"}
        
        current_tick = self.entity.engine.time_sys.total_ticks
        oldest_timer = self.fizz_timers[0] if self.fizz_timers else current_tick
        age = current_tick - oldest_timer
        is_fresh = age < FAYGO_FRESH_DURATION
        
        if not is_fresh and mode in [FaygoMode.SHOOK, FaygoMode.CHUG]:
            mode = FaygoMode.FLAT
        
        self.inventory -= 1
        if self.fizz_timers:
            self.fizz_timers.pop(0)
        
        effects = FAYGO_EFFECTS.get(mode.value, {})
        result = {"success": True, "mode": mode.value, "effects": effects.copy()}
        
        if "energy" in effects:
            self.entity.energy = max(0, min(100, self.entity.energy + effects["energy"]))
        
        if "anxiety" in effects:
            self.entity.anx_cur.anxiety = max(0, min(1, self.entity.anx_cur.anxiety + effects["anxiety"]))
        
        if "arousal" in effects and hasattr(self.entity, 'arousal'):
            self.entity.arousal.excitation = min(5, max(0, self.entity.arousal.excitation + effects["arousal"]))
        
        if "target_energy" in effects and target:
            target.energy = max(0, min(100, target.energy + effects["target_energy"]))
        
        if "cleanse" in effects and effects["cleanse"]:
            self.entity.poison_level = 0
            self.entity.thirst = max(0, self.entity.thirst - 0.5)
        
        if "brain_freeze_chance" in effects and random.random() < effects["brain_freeze_chance"]:
            if hasattr(self.entity, 'scg'):
                self.entity.scg.clarity_score *= 0.8
            result["brain_freeze"] = True
        
        return result

# =============================================================================
# MAGNETIC FIELDS SYSTEM
# =============================================================================

class MagneticFieldsSystem:
    def __init__(self):
        self.field_vectors = {}
    
    def update_entity(self, entity, engine) -> None:
        if not hasattr(entity, 'get_component'):
            return
        
        madrox = entity.get_component('madrox')
        if not (madrox and madrox.active):
            return
        
        calming_sources = self._find_calming_sources(entity, engine)
        if not calming_sources:
            return
        
        net_vector = self._compute_field_bias(entity, calming_sources)
        
        if random.random() < 0.1 and (abs(net_vector[0]) > 0 or abs(net_vector[1]) > 0):
            dx = 1 if net_vector[0] > 0 else -1 if net_vector[0] < 0 else 0
            dy = 1 if net_vector[1] > 0 else -1 if net_vector[1] < 0 else 0
            
            new_x = max(0, min(engine.biome.w - 1, entity.x + dx))
            new_y = max(0, min(engine.biome.h - 1, entity.y + dy))
            
            entity.x, entity.y = new_x, new_y
        
        self._apply_proximity_calming(entity, calming_sources)
    
    def _find_calming_sources(self, entity, engine) -> List[tuple]:
        sources = []
        
        for e in engine.social_hub.entities:
            if not e.alive or e.uid == entity.uid:
                continue
            
            strength = self._get_calm_strength(e)
            if strength <= 0:
                continue
            
            dist = math.sqrt((e.x - entity.x)**2 + (e.y - entity.y)**2)
            if dist <= CALM_FIELD_RADIUS:
                sources.append((e, strength, dist))
        
        return sources
    
    def _get_calm_strength(self, entity) -> float:
        if hasattr(entity, 'get_component'):
            carnie = entity.get_component('carnie')
            if carnie and carnie.active and carnie.sub_mode == CarnieMode.SMOKE_CHILL:
                return MONOXIDE_CALM_STRENGTH * 1.5
            
            if carnie and carnie.active:
                return MONOXIDE_CALM_STRENGTH * 0.7
        
        return CALM_BASE_STRENGTH
    
    def _compute_field_bias(self, entity, calming_sources: List[tuple]) -> tuple:
        net_x, net_y = 0.0, 0.0
        
        for source, strength, dist in calming_sources:
            dx = source.x - entity.x
            dy = source.y - entity.y
            
            if dist == 0:
                continue
            
            d = dist
            optimal = MADROX_OPTIMAL_DIST
            spread = (MADROX_OUTER_RADIUS - MADROX_INNER_RADIUS) / 2
            
            w = 1 - ((d - optimal) ** 2) / (spread ** 2)
            w = max(-1, min(1, w))
            w *= strength
            
            net_x += (dx / dist) * w
            net_y += (dy / dist) * w
        
        return (net_x, net_y)
    
    def _apply_proximity_calming(self, entity, calming_sources: List[tuple]) -> None:
        for source, strength, dist in calming_sources:
            if dist <= 3:
                base_rate = CALM_BASE_RATE * strength
                
                madrox = entity.get_component('madrox')
                if madrox:
                    duration = MADROX_MAX_DURATION - madrox.timer
                    resistance = min(0.77, duration / MADROX_MAX_DURATION * 0.77)
                    calm_rate = base_rate * (1 - resistance)
                else:
                    calm_rate = base_rate
                
                entity.anx_cur.anxiety = max(0, entity.anx_cur.anxiety - calm_rate)

# =============================================================================
# RUMOR SYSTEM
# =============================================================================

@dataclass
class Rumor:
    text: str
    truth: float = 0.5
    source: Optional[str] = None
    timestamp: int = 0
    spread_count: int = 0
    tags: list = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []

class RumorManager:
    def __init__(self):
        self.rumors: List[Rumor] = []
        self.max_rumors = 100
    
    def create_rumor(self, text: str, truth: float = 0.5, source: str = None, 
                     timestamp: int = 0, tags: list = None) -> Rumor:
        rumor = Rumor(
            text=text,
            truth=max(0.0, min(1.0, truth)),
            source=source,
            timestamp=timestamp,
            tags=tags or []
        )
        self.rumors.append(rumor)
        
        if len(self.rumors) > self.max_rumors:
            self.rumors.pop(0)
        
        return rumor
    
    def spread_rumor(self, rumor: Rumor, listener, teller, engine) -> bool:
        if listener.genes['curiosity'] < 0.3:
            return False
        
        listener.curiosity = min(1.0, listener.curiosity + 0.05)
        
        listener.grimoire.update({
            "type": "rumor",
            "text": rumor.text,
            "source": teller.uid if teller else "unknown",
            "truth": rumor.truth,
            "importance": 0.5
        }, is_vivid=True)
        
        rumor.spread_count += 1
        engine.add_log(f"[Rumor] Spreading: \"{rumor.text[:30]}...\" (truth: {rumor.truth:.1f})")
        
        return True
    
    def get_random_rumor(self, min_truth: float = 0.0, max_truth: float = 1.0) -> Optional[Rumor]:
        candidates = [r for r in self.rumors if min_truth <= r.truth <= max_truth]
        return random.choice(candidates) if candidates else None

# =============================================================================
# MIDWAY BIOME
# =============================================================================

class MidwayBiome:
    def __init__(self, width: int, height: int):
        self.width = width
        self.height = height
        self.festival_data: dict = {}
        self.field_strength = MIDWAY_BASE_FIELD
        self.parties = []
    
    def create_festival(self, x: int, y: int, cover_crop: str = "CLOVER"):
        if 0 <= x < self.width and 0 <= y < self.height:
            self.festival_data[(x, y)] = {
                'cover_crop': cover_crop,
                'field_strength': MIDWAY_BASE_FIELD,
                'created_tick': 0,
                'duration': 0
            }
    
    def update(self, tick: int, engine):
        # Decay field strength
        for key, data in self.festival_data.items():
            data['field_strength'] = max(0, data['field_strength'] - FIELD_DECAY_RATE)
            data['duration'] += 1
            
            if data['field_strength'] <= 0:
                del self.festival_data[key]
        
        # Apply cover crop effects
        for (x, y), data in self.festival_data.items():
            crop_type = data['cover_crop']
            effects = COVER_CROP_TYPES.get(crop_type, {})
            
            for e in engine.social_hub.entities:
                if abs(e.x - x) + abs(e.y - y) <= MIDWAY_RADIUS:
                    if 'faygo_boost' in effects:
                        # Boost Faygo generation
                        pass
                    if 'energy_regen' in effects:
                        e.energy = min(100, e.energy + effects['energy_regen'])
    
    def contribute_to_field(self, amount: float, entity):
        x, y = entity.x, entity.y
        if (x, y) in self.festival_data:
            self.festival_data[(x, y)]['field_strength'] = min(
                MIDWAY_MAX_FIELD,
                self.festival_data[(x, y)]['field_strength'] + amount
            )

# =============================================================================
# JUGGALO PARTY
# =============================================================================

class JuggaloParty:
    def __init__(self, x: int, y: int, participants: List):
        self.x = x
        self.y = y
        self.participants = participants
        self.level = 1
        self.temperature = 0.5
        self.growth_meter = 0
        self.timer = PARTY_TIMEOUT
    
    def update(self, engine):
        self.timer -= 1
        
        # Apply benefits based on level
        benefits = PARTY_BENEFITS.get(self.level, PARTY_BENEFITS[1])
        
        for p in self.participants:
            if p.alive:
                p.energy = min(100, p.energy + benefits['energy_regen'])
                p.curiosity = min(1.0, p.curiosity + benefits['curiosity'])
        
        # Decay temperature
        self.temperature = max(0.0, self.temperature - PARTY_TEMP_DECAY)
        
        # Growth decay
        if self.growth_meter > 0:
            self.growth_meter = max(0, self.growth_meter - PARTY_GROWTH_PER_TICK)
        
        # Level up
        if self.growth_meter >= 100 * self.level:
            self.level = min(5, self.level + 1)
            self.growth_meter = 0
            engine.add_log(f"[JuggaloParty] Party at ({self.x}, {self.y}) leveled up to {self.level}!")
        
        # Check if party should disband
        if self.timer <= 0 or len(self.participants) < PARTY_MIN_PARTICIPANTS:
            return False  # Party over
        
        return True  # Party continues

class JuggaloPartyManager:
    def __init__(self):
        self.parties: List[JuggaloParty] = []
    
    def update(self, engine):
        # Update existing parties
        self.parties = [p for p in self.parties if p.update(engine)]
        
        # Check for new party formation
        for x in range(engine.biome.w):
            for y in range(engine.biome.h):
                nearby = [e for e in engine.social_hub.entities 
                          if e.alive and abs(e.x - x) + abs(e.y - y) <= 1]
                
                if len(nearby) >= PARTY_MIN_PARTICIPANTS:
                    # Check if high valence
                    avg_valence = sum(e.valence for e in nearby) / len(nearby)
                    if avg_valence > 3:
                        # Check if not already in a party
                        if not any(p.x == x and p.y == y for p in self.parties):
                            self.parties.append(JuggaloParty(x, y, nearby))

# =============================================================================
# COP MOMENT
# =============================================================================

class CopMoment:
    def __init__(self, entity_a, entity_b):
        self.entity_a = entity_a
        self.entity_b = entity_b
        self.timer = 100
        self.active = True
        self.ride_along = True
    
    def update(self, engine):
        self.timer -= 1
        
        if self.ride_along:
            # Move together
            dx = self.entity_b.x - self.entity_a.x
            dy = self.entity_b.y - self.entity_a.y
            
            if abs(dx) > 1 or abs(dy) > 1:
                move_x = 1 if dx > 0 else -1 if dx < 0 else 0
                move_y = 1 if dy > 0 else -1 if dy < 0 else 0
                
                self.entity_a.x = max(0, min(engine.biome.w - 1, self.entity_a.x + move_x))
                self.entity_a.y = max(0, min(engine.biome.h - 1, self.entity_a.y + move_y))
        
        # Strengthen bond
        if self.entity_b.uid in self.entity_a.bonds:
            self.entity_a.bonds[self.entity_b.uid].strengthen(0.05)
        
        if self.timer <= 0:
            self.active = False
            # Apply aftermath debuff
            self.entity_a.energy *= 0.8
            engine.add_log(f"[CopMoment] {self.entity_a.uid} and {self.entity_b.uid} finished their ride-along.")
        
        return self.active

# =============================================================================
# DLC INITIALIZER
# =============================================================================

class DLC1System:
    """Main DLC 1 system that integrates all components."""
    
    def __init__(self, engine):
        self.engine = engine
        self.event_manager = EventManager()
        self.dialogue_manager = DialogueManager()
        self.archetype_manager = ArchetypeManager()
        self.rumor_manager = RumorManager()
        self.magnetic_fields = MagneticFieldsSystem()
        self.midway = MidwayBiome(engine.biome.w, engine.biome.h)
        self.party_manager = JuggaloPartyManager()
        self.cop_moments: List[CopMoment] = []
    
    def update(self, tick: int):
        # Update midway
        self.midway.update(tick, self.engine)
        
        # Update parties
        self.party_manager.update(self.engine)
        
        # Update cop moments
        self.cop_moments = [cm for cm in self.cop_moments if cm.update(self.engine)]
        
        # Update magnetic fields for Madrox entities
        for entity in self.engine.social_hub.entities:
            if entity.alive:
                self.magnetic_fields.update_entity(entity, self.engine)
    
    def trigger_cop_moment(self, entity_a, entity_b):
        """Trigger a Cop Moment between two entities."""
        if entity_a.uid != entity_b.uid:
            self.cop_moments.append(CopMoment(entity_a, entity_b))
            self.engine.add_log(f"[CopMoment] {entity_a.uid} and {entity_b.uid} enter a ride-along!")

# Export all main classes
__all__ = [
    'Component', 'ComponentHolder',
    'EventManager', 'Event',
    'ArchetypeManager', 'DialogueManager',
    'MadroxComponent', 'CarnieComponent', 'DangerStateComponent', 'FaygoComponent',
    'IdentityComponent', 'StateComponent',
    'MagneticFieldsSystem', 'Rumor', 'RumorManager',
    'MidwayBiome', 'JuggaloParty', 'JuggaloPartyManager', 'CopMoment',
    'DLC1System',
    'FaygoMode', 'CarnieMode', 'CoverCropType', 'DangerState', 'RumorTruth'
]
```
